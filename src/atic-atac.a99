* Atic Atac for Sinclair ZX Spectrum
* (c) 1983 Ashby Computers and Graphics Ltd.
* 
* Disassembled by obo
* 
* Differences from original release:
* 6009: C0->00 - disable protection check on FRAMES sysvar after loading
* 7E91: B0->05 - new LSB of JP (HL) instruction (below)
* 7E92: 5C->D5 - new MSB of JP (HL) instruction
* 971F: D4->D3 - fixed typo in congratulations message
* D505: 00->E9 - JP (HL) instruction moved from printer buffer

* RM: I found that after a byte compare (cp on Z80, cb on the TI) the carry condition on the Z80 correspond to JL on the TI
* or JHE for the inverse condition. If the carry flag is checked after a subtraction instead of a compare this has to be
* turned into a compare followed by a (possible) subtraction on the TI.

*********************************************************************
*
* Routine at 6000
*
start:                                 ; >6000
      limi 0
      lwpi wrksp
      bl   @ti_setup_environment
;       limi 0                          ; DI                ;
;       li   sp,menu_selection          ; LD SP,$5E00       ;
;_6004:                                 ; >6004
;       movb @zx_frames+>0001,a         ; LD A,($5C79)      ;
;       cb   a,@bytes+>25               ; CP $25            ; is frames MSB as expected?
;       jeq  !                          ; RET NZ            ;
;       .ret                            ;
;!
        b    @reset_menu                ; JP $7C19          ;

*********************************************************************
*
* Routine at 7c19
* 
* Used by the routine at #R$6000.
reset_menu:                            ; >7c19
       li   hl,menu_selection          ; LD HL,$5E00       ; 
       movb @bytes+>10,b               ; LD B,$10          ; 
clear_menu_data:                       ; >7c1e
       sb   *hl,*hl                    ; LD (HL),$00       ; clear menu data
       inc  hl                         ; INC HL            ; 
       sb   one,b                      ; DJNZ $7C1E        ; 
       jne  clear_menu_data            ;
       li   hl,charset_base            ; LD HL,$BE4C       ;
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
* This entry point is used by the routine at #R$8c35.
main_menu:                             ; >7c29
       .call @clear_screen             ; CALL $80AA        ; clear display, attributes, and set black border
       .call @draw_menu_icons          ; CALL $A311        ; draw menu icons for controls and player acharacters
menu_loop:                             ; >7c2f
       .call @draw_menu_text           ; CALL $7CAF        ; 

       bl   @ti_upload_zx_screen
!      li   r0,KEY_0
       bl   @ti_check_key
       jeq  -!
       b    @start_game

       movb @bytes+>f7,a               ; LD A,$F7          ; xxx54321
       ; OUT ($FD),A                   ; OUT ($FD),A       ; 
       ; IN A,($FE)                    ; IN A,($FE)        ; 
       inv  a                          ; CPL               ; set bits now mean pressed keys
       movb a,@e                       ; LD E,A            ; 
       movb @menu_selection,a          ; LD A,($5E00)      ; 
       movb @e,r0                      ; BIT 0,E           ; 1 pressed?
       andi r0,>0100                   ;                   
       jeq  loc_7c43                   ; JR Z,$7C43        ; jump if not
       andi a,>f900                    ; AND $F9           ; select Keyboard
loc_7c43:                              ; >7c43
       movb @e,r0                      ; BIT 1,E           ; 2 pressed?
       andi r0,>0200                   ;                   
       jeq  loc_7c4b                   ; JR Z,$7C4B        ; jump if not
       andi a,>f900                    ; AND $F9           ; 
       socb @bytes+>02,a               ; OR $02            ; select Kempston joystick
loc_7c4b:                              ; >7c4b
       movb @e,r0                      ; BIT 2,E           ; 3 pressed?
       andi r0,>0400                   ;                   
       jeq  loc_7c53                   ; JR Z,$7C53        ; jump if not
       andi a,>f900                    ; AND $F9           ; 
       socb @bytes+>04,a               ; OR $04            ; select Cursor joystick
loc_7c53:                              ; >7c53
       movb @e,r0                      ; BIT 3,E           ; 4 pressed?
       andi r0,>0800                   ;                   
       jeq  loc_7c59                   ; JR Z,$7C59        ; jump if not
       andi a,>e700                    ; AND $E7           ; select Knight
loc_7c59:                              ; >7c59
       movb @e,r0                      ; BIT 4,E           ; 5 pressed?
       andi r0,>1000                   ;                   
       jeq  loc_7c61                   ; JR Z,$7C61        ; jump if not
       andi a,>e700                    ; AND $E7           ; 
       socb @bytes+>08,a               ; OR $08            ; select Wizard
loc_7c61:                              ; >7c61
       movb a,d                        ; LD D,A            ; 
       movb @bytes+>ef,a               ; LD A,$EF          ; xxx67890
       ; OUT ($FD),A                   ; OUT ($FD),A       ; 
       ; IN A,($FE)                    ; IN A,($FE)        ; 
       inv  a                          ; CPL               ; set bits now mean pressed keys
       movb a,@e                       ; LD E,A            ; 
       movb d,a                        ; LD A,D            ; 
       movb @e,r0                      ; BIT 4,E           ; 6 pressed?
       andi r0,>1000                   ;                   
       jeq  loc_7c73                   ; JR Z,$7C73        ; jump if not
       andi a,>e700                    ; AND $E7           ; 
       socb @bytes+>10,a               ; OR $10            ; select Serf
loc_7c73:                              ; >7c73
       movb a,@menu_selection          ; LD ($5E00),A      ; 
       movb a,@c                       ; LD C,A            ; 
       movb @e,r0                      ; BIT 0,E           ; 0 pressed?
       andi r0,>0100                   ;                   
       jeq  !                          ; JP NZ,$7D9A       ; jump if so
       b    @start_game                ;                   
!
       li   hl,menu_attrs              ; LD HL,$7CEA       ; 
       movb @bytes+>03,b               ; LD B,$03          ; 
       movb @c,a                       ; LD A,C            ; 
       .call @set_menu_attrs           ; CALL $7C90        ; highlight keyboard/kempston/cursor
       movb @bytes+>03,b               ; LD B,$03          ; 
       movb @c,a                       ; LD A,C            ; 
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 
       .call @set_menu_attrs           ; CALL $7C90        ; highlight knight/wizard/serf
       b    @menu_loop                 ; JP $7C2F          ; 

*********************************************************************
*
* draw menu icons for controls and player characters
*
* Used by the routine at #R$7c19.
draw_menu_icons:                       ; >a311
       .proc
       li   ix,entity_to_draw          ; LD IX,$A17D       ;
       li   hl,menu_entities           ; LD HL,$A331       ; entities for icons in the menu position
       movb @bytes+>09,b               ; LD B,$09          ; 3*2 icons for controls, 3 player characters
draw_menu_icons_1:                     ; >a31a
       .push bc                        ; PUSH BC           ;
       li   de,entity_to_draw          ; LD DE,$A17D       ;
       li   bc,>0008                   ; LD BC,$0008       ;
       .ldir                           ; LDIR              ;
       .push hl                        ; PUSH HL           ;
       .push de                        ; PUSH DE           ;
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .call @set_entity_attrs         ; CALL $A00E        ; paint entity with its current attr colour
       .pop de                         ; POP DE            ;
       .pop hl                         ; POP HL            ;
       .pop bc                         ; POP BC            ;
       sb   one,b                      ; DJNZ $A31A        ;
       jne  draw_menu_icons_1                   ;
       .endproc                        ; RET               ;

*********************************************************************
*
* set menu attrs to reflect current selection
* 
* Used by the routine at #R$7c19.
set_menu_attrs:                        ; >7c90
       .proc
       srl  a,1                        ; RRCA              ;
set_menu_attrs_1:                      ; >7c91
       andi a,>0300                    ; AND $03           ; 
       jeq  set_menu_attrs_3           ; JR Z,$7C9C        ;
       .call @set_flash_off            ; CALL $7CA4        ; 
set_menu_attrs_2:                      ; >7c98
       sb   one,a                      ; DEC A             ; 
       sb   one,b                      ; DJNZ $7C91        ; 
       jne  set_menu_attrs_1           ;
       .endproc                        ; RET               ;
set_menu_attrs_3:                      ; >7c9c
       .call @set_flash_on             ; CALL $7CAB        ; 
       jmp  set_menu_attrs_2           ; JR $7C98          ;
       socb @bits+7,*hl                ; SET 7,(HL)        ; flash on
       inc  hl                         ; INC HL            ; 
       jmp  set_flash_off_branch

*********************************************************************
*
* Routine at 7ca4
* 
* Used by the routine at #R$7c90.
set_flash_off:                         ; >7ca4
       .proc
set_flash_off_branch
       szcb @bits+7,*hl                ; RES 7,(HL)        ; clear flash attribute
       inc  hl                         ; INC HL            ; 
       .endproc                        ; RET               ;

*********************************************************************
*
* Routine at 7cab
* 
* Used by the routine at #R$7c90.
set_flash_on:                          ; >7cab
       socb @bits+7,*hl                ; SET 7,(HL)        ; set flash attribute
       inc  hl                         ; INC HL            ; 
       .ret                            ; RET               ; OK

*********************************************************************
*
* Routine at 7caf
* 
* Used by the routine at #R$7c19.
draw_menu_text:                        ; >7caf
       .proc
       li   hl,charset_base            ; LD HL,$BE4C       ;
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   de,menu_attrs              ; LD DE,$7CEA       ; 
       .exx                            ; EXX               ; 
       li   hl,menu_ycoords            ; LD HL,$7CF1       ; 
       li   de,menu_options            ; LD DE,$7CF8       ; "1  KEYBOAR"
       movb @bytes+>07,b               ; LD B,$07          ; 7 lines
loc_7cc1:                              ; >7cc1
       .exx                            ; EXX               ; 
       movb *de+,a                     ; LD A,(DE)         ; text attribute colour
       movb a,@text_attr               ; LD ($5E22),A      ; 
;      inc  de                         ; INC DE            ;
       .exx                            ; EXX               ; 
       .push bc                        ; PUSH BC           ; 
       movb *hl+,a                     ; LD A,(HL)         ; next text character
;      inc  hl                         ; INC HL            ;
       .push hl                        ; PUSH HL           ; 
       movb a,h                        ; LD H,A            ; 
       movb @bytes+>58,@l              ; LD L,$58          ; x coord for text
       .call @print_text               ; CALL $7D8A        ; 
       .exx                            ; EXX               ; 
       .pop hl                         ; POP HL            ; 
       .pop bc                         ; POP BC            ; 
       inc  de                         ; INC DE            ; 
       sb   one,b                      ; DJNZ $7CC1        ; 
       jne  loc_7cc1                   ;                   
       li   hl,>b800                   ; LD HL,$B800       ; copyright at 0,184
       li   de,copyright_msg           ; LD DE,$7D51       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       li   hl,>0020                   ; LD HL,$0020       ; header at 32,0
       li   de,header_msg              ; LD DE,$7D72       ; 
       b    @colour_text_jump_target   ; JP $A1F3          ; show a line of text, first byte is attr

* Routine at 7d8a
* 
* Used by the routine at #R$7caf.
print_text:                            ; >7d8a
       .proc
       .push hl                        ; PUSH HL           ; 
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       movb @text_attr,a               ; LD A,($5E22)      ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       .exx                            ; EXX               ; 
       .pop hl                         ; POP HL            ; 
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       b    @loc_a1ff                  ; JP $A1FF          ; 

*********************************************************************
*
* Routine at 7d9a
* 
* Used by the routine at #R$7c19.
start_game:                            ; >7d9a
       .call @clear_game_data          ; CALL $80CB        ; clear 5E10-5FFF
       movb @bytes+>03,a               ; LD A,$03          ; 3 lives on startup
       movb a,@lives                   ; LD ($5E21),A      ; 
       li   hl,food_items              ; LD HL,$EB58       ; 
       mov  hl,@food_ptr               ; LD ($5E55),HL     ; 
       .call @clear_screen             ; CALL $80AA        ; clear display, attributes, and set black border
       .call @draw_side_panel          ; CALL $A219        ; draw side panel background scroll
       .call @draw_lives               ; CALL $A2CE        ; draw lives sprites in side panel
;      .call @place_key_pieces         ; CALL $94B6        ; set locations of ACG key pieces (moved)
;      .call @set_key_positions        ; CALL $98D2        ; set positions of red/green/cyan keys, and mummy (moved)
       .call @reset_game_state         ; CALL $8D61        ; copy initial game state to working state area
       .call @place_key_pieces         ; CALL $94B6        ; set locations of ACG key pieces
       .call @set_key_positions        ; CALL $98D2        ; set positions of red/green/cyan keys, and mummy
       .call @randomise_doors          ; CALL $94F5        ; randomise which doors can open/close
       .call @prepare_player           ; CALL $9443        ; prepare player to spawn
       b    @enter_room                ; JP $9147          ; Will jump back to main_loop

*********************************************************************
*
* Routine at 7dc3
* 
* Used by the routines at #R$7e13 and #R$9117.
main_loop:                             ; >7dc3
       li   sp,stack                   ; LD SP,$5E00       ;
       ; EI                            ; EI                ; 
       sb   a,a                        ; XOR A             ; 
loc_7dc8:                              ; >7dc8
       movb a,@num_creatures           ; LD ($5E25),A      ; number of creatures processed this frame
       li   ix,acg_key_1               ; LD IX,$EAA8       ; first entity
       movb @game_flags,r0             ; LD A,($5E14)      ; b0 set if room content drawn
;      movb a,r0                       ; BIT 0,A           ; room content drawn?
       andi r0,>0100                   ;                   
       jne  main_loop_1                ; JR NZ,$7DDC       ; jump if so
       li   ix,linked_items            ; LD IX,$EEE0       ; pairs of linked items, including doors
       jmp  draw_room                  ; JR $7E23          ;
main_loop_1:                           ; >7ddc
       movb @zx_frames,a               ; LD A,($5C78)      ;
       movb a,@c                       ; LD C,A            ; 
       movb @last_frames,a             ; LD A,($5E03)      ; 
       cb   a,@c                       ; CP C              ; same frame as last time?
       jeq  !                          ; CALL NZ,$7EB2     ; call if not
       .call @run_player               ;
!
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; entity in player room?
       jne  !                          ; JP Z,$7E7E        ; jump if so
       li   hl,loop_return_1           ; LD HL,$7DF3       ;
       b    @process_action           ;
!
loop_return_1:                         ; >7df3
;      li   de,>0008                   ; LD DE,$0008       ; entity size
       ai    ix,8                       ; ADD IX,DE         ; next entity
;      .push ix                        ; PUSH IX           ;
;      .pop hl                         ; POP HL            ;
;      li   de,creature1               ; LD DE,$EE60       ; end marker
;      ; AND A                         ; AND A             ;
;       c    de,hl                     ; SBC HL,DE         ; end of list?
       ci   ix,creature1
       jl   main_loop_1                ; JR C,$7DDC        ; jump if not
**
* This entry point is used by the routine at #R$7e13.
main_loop_2:                           ; >7e03
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       movb a,@c                       ; LD C,A            ; 
       movb @last_frames,a             ; LD A,($5E03)      ; 
       cb   a,@c                       ; CP C              ; same frame as last time?
       jeq  !                          ; CALL NZ,$7EB2     ; call if not
      .call @run_player               ;
!
       li   hl,loop2_return            ; LD HL,$7E13       ; 
       b    @process_action            ; JR $7E7E          ;
* Routine at 7e13
loop2_return:                          ; >7e13
;      li   de,>0010                   ; LD DE,$0010       ; 16 bytes per linked entity pair
       ai   ix,16                      ; ADD IX,DE         ; next pair
;      .push ix                        ; PUSH IX           ;
;      .pop hl                         ; POP HL            ;
;      mov  ix,hl
;      li   de,linked_items            ; LD DE,$EEE0       ; pairs of linked items, including doors
;      ; AND A                         ; AND A             ;
       ci   ix,linked_items            ; SBC HL,DE         ;
       jl  main_loop_2                 ; JR C,$7E03         ;

*********************************************************************
*
draw_room:
       .call @draw_room_decor
       movb @counter_low,@l            ; LD HL,($5E12)     ;
       movb @counter_high,h
       inc  hl                         ; INC HL            ; advance game loop counter
       movb @l,@counter_low            ; LD ($5E12),HL     ;
       movb h,@counter_high
;      li   hl,game_flags              ; LD HL,$5E14       ; b0 set if room content drawn
       movb @game_flags,r0             ; BIT 0,(HL)        ; room drawn yet?
       andi r0,>0100                   ;                   
       jne  loc_7e55                   ; JR NZ,$7E55       ; jump if so
       .call @draw_entities            ; CALL $9291        ; draw all non-monster entities in the current room
loc_7e55:                              ; >7e55
;      li   hl,game_flags              ; LD HL,$5E14       ; b0 set if room content drawn
       socb @bits+0,@game_flags        ; SET 0,(HL)        ; mark room as drawn
*      Update random number
;       mov  @rand8,hl                  ; LD HL,($5E05)     ; another random number source
;       mov  @zx_frames,de              ; LD DE,($5C78)     ;
;       a    de,hl                      ; ADD HL,DE         ; add in frames
;       movb @counter_low,a             ; LD A,($5E12)      ;
;       ab   @l,a                       ; ADD A,L           ; add in counter low
;       movb a,@l                       ; LD L,A            ;
;       mov  hl,@rand8                  ; LD ($5E05),HL     ; only low 8 bits are meaningfully random
       bl   @ti_rnd
       mov  r0,@rand8
       .call @check_pickup_key         ; CALL $938B        ; check whether pick-up key has been pressed
       .call @check_pause              ; CALL $9489        ; check for pause key, return when not paused
       .call @replenish_food           ; CALL $9924        ; periodically replenish consumed food
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@bytes+>8e               ; CP $8E            ; end room?
       jne  !                          ; JP Z,$96EC        ; congratulate player on completion
       b    @game_complete             ;                   
!
       ab   one,@zx_frames
       bl   @ti_upload_zx_screen
       b    @main_loop                 ; JP $7DC3          ;

*********************************************************************
*
* clear screen and attrs of play area
* 
* Used by the routines at #R$8c35, #R$9117 and #R$9731.
clear_play_area:                       ; >8093
       .proc
       li   hl,zx_screen               ; LD HL,$4000       ;
       li   bc,>18c0                   ; LD BC,$18C0       ; 24x192
       sb   a,a                        ; XOR A             ; 
       jmp  !

* fill C rows of B columns of value A at address HL
* 
* Used by the routines at #R$9bea and #R$a240.
fill_bc_hl_a:                          ; >809a
       .proc
!:
       .push bc                        ; PUSH BC           ;
       .push hl                        ; PUSH HL           ; 
       li   de,>0020                   ; LD DE,$0020       ; line stride is 32 bytes
loc_809f:                              ; >809f
       movb a,*hl+                     ; LD (HL),A         ;
;      inc  hl                         ; INC HL            ;
       sb   one,b                      ; DJNZ $809F        ; 
       jne  loc_809f                   ;                   
       .pop hl                         ; POP HL            ; 
       a    de,hl                      ; ADD HL,DE         ; 
       .pop bc                         ; POP BC            ; 
       sb   one,@c                     ; DEC C             ; 
       jne  -!                         ; JR NZ,$809A       ; fill C rows of B columns of value A at address HL
       .endproc                        ; RET               ;

*********************************************************************
*
* clear display, attributes, and set black border
* 
* Used by the routines at #R$7c19 and #R$7d9a.
clear_screen:                          ; >80aa
       .proc
       .call @clear_attrs             ; CALL $80C2         ; clear attribute file
       .call @clear_display           ; CALL $80B4         ; clear display file
       sb   a,a                        ; XOR A             ; 
       bl   @ti_set_border_color
       ; OUT ($FE),A                   ; OUT ($FE),A       ; black border
       .endproc                        ; RET               ;

*********************************************************************
*
* clear display file
* 
* Used by the routine at #R$80aa.
clear_display:                         ; >80b4
       .proc
       li   hl,zx_screen               ; LD HL,$4000       ; 
;      movb @bytes+zx_attrs_msb,b      ; LD B,$58          ;
       li   bc,>1800
clear_display_1:
       bl   @ti_clear
       .endproc

;* This entry point is used by the routine at #R$80cb.
;loc_80b9:                              ; >80b9
;       sb   @c,@c                      ; LD C,$00          ;
;* This entry point is used by the routine at #R$80c2.
;loc_80bb:                              ; >80bb
;       movb @c,*hl                     ; LD (HL),C         ;
;       inc  hl                         ; INC HL            ;
;       movb h,a                        ; LD A,H            ;
;       cb   a,b                        ; CP B              ;
;       jne  loc_80bb                   ; JR NZ,$80BB       ;
;       .ret                            ; RET               ;

*********************************************************************
*
* clear attribute file
* 
* Used by the routine at #R$80aa.
clear_attrs:                           ; >80c2
       .proc
       li   hl,zx_attrs                ; LD HL,$5800       ; 
;       movb @bytes+zx_attrs_msb+3,b    ; LD B,$5B          ;
;       sb   @c,@c                      ; LD C,$00          ;
;       jmp  loc_80bb                   ; JR $80BB          ;
       li   bc,>300
       jmp  clear_display_1

*********************************************************************
*
* clear 5E10-5FFF
* 
* Used by the routine at #R$7d9a.
clear_game_data:                       ; >80cb
       .proc
       li   hl,game_data               ; LD HL,$5E10       ;
;      movb @bytes+>60,b               ; LD B,$60          ; clear up to address 6000
;      jmp  loc_80b9                   ; JR $80B9          ;
       li   bc,game_data_end-game_data
       jmp  clear_display_1

*********************************************************************
*
* draw chicken energy bar
* 
* Used by the routines at #R$8a1e, #R$8c63, #R$8e26, #R$8ed7, #R$9443 and
* #R$988b.
draw_chicken:                          ; >8b8a
       .proc
draw_chicken_branch:
       seto @background_graphics_rom_bank
       movb @player_energy,a           ; LD A,($5E28)      ;
;      srl  a,1                        ; SRL A             ;
;      srl  a,1                        ; SRL A             ;
;      srl  a,1                        ; SRL A             ;
       srl  a,3
       movb a,@c                       ; LD C,A            ; desired height
       movb @chicken_level,a           ; LD A,($5E29)      ; last drawn chicken level
;      srl  a,1                        ; SRL A             ;
;      srl  a,1                        ; SRL A             ;
;      srl  a,1                        ; SRL A             ;
       srl  a,3
       movb a,b                        ; LD B,A            ; Last drawn height
       cb   a,@c                       ; CP C              ; if desired height = last drawn then return
       jeq  draw_chicken_end           ; RET Z             ;
       movb @g_chicken_full+1,@e       ; LD A,($C543)      ; e = full chicken height
;      movb a,@e                       ; LD E,A            ;
       movb @g_chicken_empty+1,d       ; LD A,($C48D)      ; d = empty chicken height
;      movb a,d                        ; LD D,A            ;
       .push ix                        ; PUSH IX           ; 
       li   ix,chicken_entity          ; LD IX,$8C2D       ; Entity to draw
       .push de                        ; PUSH DE           ; Save original heights
       cb   a,@c                                           ; Compare last drawn to desired height again
       jle   loc_8c12                   ; JR C,$8C12       ; Jump if last drawn height was lower or equal
       movb @g_chicken_empty,@e        ; LD A,($C48C)      ; e = width
;      movb a,@e                       ; LD E,A            ;
       sb   d,d                        ; LD D,$00          ; de = width
       movb @c,a                       ; LD A,C            ; a = desired height
;      .push bc                        ; PUSH BC           ;
       .call @mpy_de_a                ; CALL $9AAD        ; HL = DE * A = width * desired height
;      .pop bc                         ; POP BC            ;
       mov  @chicken_empty_addr,de     ; LD DE,($A626)     ; de = address of empty chicken graphics
       .push de                        ; PUSH DE           ; Save address
       a    de,hl                      ; ADD HL,DE         ; Add offset
       mov  hl,@chicken_empty_addr_ram ; LD ($A626),HL     ; Update the address in the graphics table.
       movb @chicken_empty_size,@e     ; LD E,(HL)         ; Get the graphics data at the offset
;      inc  hl                         ; INC HL            ;
       movb @chicken_empty_size+1,d    ; LD D,(HL)         ; Get the graphics data at the offset
       movb @g_chicken_empty+1,a       ; LD A,($C48D)      ; Original height
       sb   @c,a                       ; SUB C             ; Minus desired height
       jeq  loc_8bfc                   ; JR Z,$8BFC        ; Return if they are the same
       .push de                        ; PUSH DE           ; Save the graphics data at the offset
       movb a,@chicken_empty_size+1    ; LD (HL),A         ; Update graphics height at offset with modified value.
       movb @g_chicken_empty,a         ; LD A,($C48C)      ; Original width
;      dec  hl                         ; DEC HL            ; Point hl to width
       movb a,@chicken_empty_size      ; LD (HL),A         ; Update graphics width at offset with modified value.
;      .push hl                        ; PUSH HL           ; Save the address at the offset
;      movb @bytes+>14,a               ; LD A,$14          ; empty chicken graphic
       movb @bytes+>14,*ix             ; LD (IX+$00),A     ; Set entity to draw
       li   hl,>77C8                   ; LD HL,$77C8       ; chicken draw coords
;      movb h,a                        ; LD A,H            ;
       sb   @c,h                       ; SUB C             ; Subtract desired height from y
;      movb a,h                        ; LD H,A            ;
;      mov  hl,@chicken_entity+>0003   ; LD ($8C30),HL     ; coords
       movb @l,@chicken_entity+entity_x                    ; Write x
       movb h,@chicken_entity+entity_y                     ; Write y
       .call @draw_bgrnd_graphics      ; CALL $9213        ;
;      mov  @chicken_entity+>0003,hl   ; LD HL,($8C30)     ;
       movb @chicken_entity+entity_x,@l                    ; Get coordinates back
       movb @chicken_entity+entity_y,h
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       movb @g_chicken_empty,a         ; LD A,($C48C)      ; a = Width
       movb a,b                        ; LD B,A            ; b = width
loc_8bf2:                              ; >8bf2
       sb   *hl,*hl                    ; LD (HL),$00       ; Clear screen byte
       ab   one,@l                     ; INC L             ; Next byte
       sb   one,b                      ; DJNZ $8BF2        ; Clear width bytes
       jne  loc_8bf2                   ;                   
;      .pop hl                         ; POP HL            ; Restore address at the offset
       .pop de                         ; POP DE            ; Restore data at offset
       movb @e,@chicken_empty_size     ; LD (HL),E         ; Restore first byte
;      inc  hl                         ; INC HL            ;
       movb d,@chicken_empty_size+1    ; LD (HL),D         ; Restore second byte
loc_8bfc:                              ; >8bfc
       .pop hl                         ; POP HL            ; Restore original address of empty chicken
       mov  hl,@chicken_empty_addr_ram ; LD ($A626),HL     ; Write it to the graphics table.
loc_8c00:                              ; >8c00
       .pop de                         ; POP DE            ; Restore original heights
;      movb @e,a                       ; LD A,E            ;
       movb @e,@chicken_full_size+1   ; LD ($C543),A       ; Restore height.
;      movb d,a                        ; LD A,D            ;
       movb d,@chicken_empty_size+1   ; LD ($C48D),A       ; Restore height.
       .pop ix                         ; POP IX            ; 
       movb @player_energy,@chicken_level ; LD A,($5E28)   ; Save new level
;      movb a,@chicken_level           ; LD ($5E29),A      ; last drawn chicken height
draw_chicken_end:
       .endproc                        ; RET               ;
loc_8c12:                              ; >8c12
       movb @c,a                       ; LD A,C            ; Desired height
       movb a,@chicken_full_size+1     ; LD ($C543),A      ; Set height of graphics.
       movb @bytes+>13,*ix             ; LD A,$13          ; full chicken graphic
;      movb a,*ix                      ; LD (IX+$00),A     ;
       li   hl,>77c8                   ; LD HL,$77C8       ; Coordinates
;      mov  hl,@chicken_entity+>0003   ; LD ($8C30),HL     ; coords
       movb @l,@chicken_entity+entity_x
       movb h,@chicken_entity+entity_y
       .call @draw_bgrnd_graphics             ; CALL $9213        ;
       movb @bytes+>06,b               ; LD B,$06          ; Width
loc_8c26:                              ; >8c26
       sb   *hl,*hl                    ; LD (HL),$00       ; Clear screen byte
       ab   one,@l                     ; INC L             ; Next byte
       sb   one,b                      ; DJNZ $8C26        ; Clear width bytes
       jne  loc_8c26                   ;                   
       jmp  loc_8c00                   ; JR $8C00          ; Jump to return
*// draw_chicken

*********************************************************************
*
* Routine at 8c35
* 
* Used by the routine at #R$8e26.
game_over:                             ; >8c35
       .call @clear_play_area          ; CALL $8093        ; clear screen and attrs of play area
       li   hl,charset_base                   ; LD HL,$BE4C       ;
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   hl,>3040                   ; LD HL,$3040       ; game over at 64,48
       li   de,gameover_msg            ; LD DE,$8C59       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       .call @game_stats               ; CALL $9641        ; show game statistics
* This entry point is used by the routine at #R$96c9.
loc_8c4a:                              ; >8c4a
       movb @bytes+>14,b               ; LD B,$14          ; 20 loops of 65536 delay
       clr  hl                         ; LD HL,$0000       ;
gameover_delay:                        ; >8c4f
       dec  hl                         ; DEC HL            ; 
;       movb h,a                        ; LD A,H            ;
;       socb @l,a                       ; OR L              ;
       jne  gameover_delay             ; JR NZ,$8C4F       ; 
       sb   one,b                      ; DJNZ $8C4F        ; 
       jne  gameover_delay             ;                   
       b    @main_menu                 ; JP $7C29          ; 

*********************************************************************
*
* copy initial game state to working state area
* 
* Used by the routine at #R$7d9a.
reset_game_state:                      ; >8d61
       seto @sprite_graphics_rom_bank
       li   hl,player_init             ; LD HL,$600D       ; initial game state
       li   de,player                  ; LD DE,$EA90       ; working game state
       li   bc,player_init_size        ; LD BC,$1570       ; 0x10000-player, rather than real init data size!
       .ldir                           ; LDIR              ;
       seto @room_data_rom_bank
       li   hl,door_07_00
       li   de,linked_items
       li   bc,linked_items_size
       .ldir
       .ret                            ; RET               ; OK

*********************************************************************
*
* move player to room linked to entity (usually door)
* 
* Used by the routines at #R$91f2, #R$9244 and #R$9731.
change_room:                           ; >9117
       .proc
change_room_branch:
       .call @get_linked_door          ; CALL $9286        ; get connected door exit
       movb @>01(ix),a                 ; LD A,(IX+$01)     ; 
       movb a,@player_room             ; LD ($EA91),A      ; move player to connected room
       movb @>02(ix),a                 ; LD A,(IX+$02)     ; bits 3-0 used for x offset
       sla  a,1                        ; RLCA              ; * 2
       andi a,>1e00                    ; AND $1E           ; 
       ab   @>03(ix),a                 ; ADD A,(IX+$03)    ; add x
       movb a,@player_x                ; LD ($EA93),A      ; set player x to exit
       movb @>02(ix),a                 ; LD A,(IX+$02)     ; bits 7-4 used for y offset
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; * 2 (effectively)
       srl  a,3
       andi a,>1e00                    ; AND $1E           ; 
       neg  a                          ; NEG               ; invert
       ab   @>04(ix),a                 ; ADD A,(IX+$04)    ; add y
       movb a,@player_y                ; LD ($EA94),A      ; set player y to exit
       .call @set_entry_walk           ; CALL $986A        ; auto-walk into the room
       movb @player_contact,a          ; LD A,($EA92)      ; 
       socb @bytes+>0f,a               ; OR $0F            ; 
       movb a,@player_contact          ; LD ($EA92),A      ; 
       jmp  enter_room

*********************************************************************
*
* This entry point is used by the routine at #R$7d9a.
*
enter_room:                            ; >9147
       movb @player_room,a             ; LD A,($EA91)      ;
       .call @visit_room               ; CALL $96AF        ; mark room A as visited
       .call @clear_play_area          ; CALL $8093        ; clear screen and attrs of play area
       .call @draw_room_frame          ; CALL $9BEA        ; draw lines that make up outer room frame
       .call @draw_panel_attrs         ; CALL $A240        ; draw side-panel colours, which follow room colour
       .call @draw_inventory           ; CALL $A13B        ; draw any items in player inventory
       .call @entry_sound              ; CALL $A403        ; room entry sound effect
       b    @main_loop                 ; JP $7DC3          ; 

*********************************************************************
*
* draw all non-monster entities in the current room
* 
* Used by the routine at #R$7e13.
draw_entities:                         ; >9291
       .proc
       li   ix,player                  ; LD IX,$EA90       ;
draw_entities_1:                       ; >9295
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; AND A                         ; AND A             ; slot used?
       jeq  draw_entities_2            ; JR Z,$92A6        ; jump if not
;      movb @player_room,a             ; LD A,($EA91)      ;
       cb   @player_room,@entity_screen(ix)                ; CP (IX+$01)       ; in player room?
       jne  draw_entities_2            ; JR NZ,$92A6       ; jump if not
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
draw_entities_2:                       ; >92a6
;      li   de,>0008                   ; LD DE,$0008       ; 8 bytes per entry
       ai   ix,8                       ; ADD IX,DE         ;
;      .push ix                        ; PUSH IX           ;
;      .pop hl                         ; POP HL            ;
;      li   de,creature1               ; LD DE,$EE60       ; end marker
       ; AND A                         ; AND A             ; 
;      s    de,hl                      ; SBC HL,DE         ; more 8-byte entries to process?
       ci   ix,creature1
       jl  draw_entities_1             ; JR C,$9295        ; jump back if so
draw_entities_3:                       ; >92b6
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; AND A                         ; AND A             ; slot used?
       jeq  draw_entities_4            ; JR Z,$92C7        ; jump if not
;      movb @player_room,a             ; LD A,($EA91)      ;
       cb   @player_room,@entity_screen(ix)                ; CP (IX+$01)       ; in player room?
       jne  draw_entities_4            ; JR NZ,$92C7       ; jump if not
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
draw_entities_4:                       ; >92c7
;      li   de,>0010                   ; LD DE,$0010       ; 16 bytes per entry
       ai   ix,16                      ; ADD IX,DE         ;
;      .push ix                        ; PUSH IX           ;
;      .pop hl                         ; POP HL            ;
;      li   de,linked_items            ; LD DE,$EEE0       ; end of 16-byte entities
       ; AND A                         ; AND A             ; 
;      s    de,hl                      ; SBC HL,DE         ; more 16-byte entries to draw?
       ci   ix,linked_items
       jl   draw_entities_3            ; JR C,$92B6        ; jump back if so
       .endproc                        ; RET               ;

*********************************************************************
*
* prepare player to spawn
* 
* Used by the routines at #R$7d9a and #R$8d45.
prepare_player:                        ; >9443
       .proc
       movb @menu_selection,a          ; LD A,($5E00)      ; 
       sla  a,1                        ; RLCA              ;
       andi a,>3000                    ; AND $30           ; base character graphic
       ab   @bytes+>08,a               ; ADD A,$08         ; offset to desired facing direction
       movb a,@player_template+>0007   ; LD ($9488),A      ; set spawn graphic
       movb @player_room,a             ; LD A,($EA91)      ; current player room
       movb a,@player_template+>0001   ; LD ($9482),A      ; respawn in same room
       li   hl,player_template         ; LD HL,$9481       ; 
       li   de,player                  ; LD DE,$EA90       ; 
       li   bc,>0008                   ; LD BC,$0008       ; player entity size
       .ldir                           ; LDIR              ; copy to live player
       movb @bytes+>8,@flash_timer     ; LD A,$68          ; flash score for 104 frames TODO: Chaged to 8
;      movb a,@flash_timer             ; LD ($5E3C),A      ; score flash timer
       movb @lives,a                   ; LD A,($5E21)      ; 
       cb   a,@bytes+>03               ; CP $03            ; first game spawn? (full lives)
       jeq  loc_9476                   ; JR Z,$9476        ; jump if so (skip drawing player)
       .push ix                        ; PUSH IX           ; 
       li   ix,player                  ; LD IX,$EA90       ; 
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .pop ix                         ; POP IX            ; 
loc_9476:                              ; >9476
       movb @bytes+>f0,@player_energy  ; LD A,$F0          ; starting energy
;      movb a,@player_energy           ; LD ($5E28),A      ;
       .call @draw_chicken             ; CALL $8B8A        ; draw chicken energy bar
       b    @draw_lives_branch         ; JP $A2CE          ; draw lives sprites in side panel

*********************************************************************
*
* check for pause key, return when not paused
* 
* Used by the routine at #R$7e13.
check_pause:                           ; >9489             ;
       .proc
;      limi 0                          ; DI                ; disable interrupts to suspend FRAMES counter advance
;       movb @bytes+>7e,a               ; LD A,$7E          ;
;       ; OUT ($FD),A                   ; OUT ($FD),A       ;
;       ; IN A,($FE)                    ; IN A,($FE)        ;
;       movb a,r0                       ; BIT 0,A           ; pause (space/shift) pressed?
;       andi r0,>0100                   ;
;       jeq  !                          ; RET NZ            ; return if not
;       .ret                            ;
;!
;       inv  a                          ; CPL               ;
;       andi a,>1e00                    ; AND $1E           ; any other key on the same row pressed?
;       jeq  !                          ; RET NZ            ; return if so
;       .ret                            ;
;!
       li   r0,KEY_P
       bl   @ti_check_key
       jeq  check_pause_3
;loc_9497:                              ; >9497
;       equ  $
;       movb @bytes+>7e,a               ; LD A,$7E          ;
;       ; OUT ($FD),A                   ; OUT ($FD),A       ;
;       ; IN A,($FE)                    ; IN A,($FE)        ;
;       movb a,r0                       ; BIT 0,A           ; space/shift pressed?
;       andi r0,>0100                   ;
;       jeq  loc_9497                   ; JR Z,$9497        ; jump if so (wait until released)
;loc_94a1:                              ; >94a1
;       movb @bytes+>7e,a               ; LD A,$7E          ;
;       ; OUT ($FD),A                   ; OUT ($FD),A       ;
;       ; IN A,($FE)                    ; IN A,($FE)        ;
;       movb a,r0                       ; BIT 0,A           ; space/shift pressed?
;       andi r0,>0100                   ;
;       jne  loc_94a1                   ; JR NZ,$94A1       ; jump if not (main pause loop)
;loc_94ab:                              ; >94ab
;       movb @bytes+>7e,a               ; LD A,$7E          ;
;       ; OUT ($FD),A                   ; OUT ($FD),A       ;
;       ; IN A,($FE)                    ; IN A,($FE)        ;
;       movb a,r0                       ; BIT 0,A           ; space/shift pressed?
;       andi r0,>0100                   ;
;       jeq  loc_94ab                   ; JR Z,$94AB        ; jump if so (wait until pause key released)
check_pause_1:
       li   r0,KEY_P
       bl   @ti_check_key
       jne  check_pause_1
check_pause_2:
       li   r0,KEY_P
       bl   @ti_check_key
       jeq  check_pause_2
check_pause_3:
       .endproc                        ; RET               ;

*********************************************************************
*
* set locations of ACG key pieces
* 
* Used by the routine at #R$7d9a.
place_key_pieces:                      ; >94b6
       .proc
       bl   @ti_rnd
       movb r0,a                       ; LD A,($5C78)      ; zx_frames
       movb a,@c                       ; LD C,A            ; 
       movb @counter_low,a             ; LD A,($5E12)      ; 
       ab   @c,a                       ; ADD A,C           ; 
       andi a,>0700                    ; AND $07           ; 
       movb a,@c                       ; LD C,A            ; 
       ab   a,a                        ; ADD A,A           ; * 2
       ab   @c,a                       ; ADD A,C           ; * 3 (3 key pieces per entry)
       movb a,@l                       ; LD L,A            ; 
       sb   h,h                        ; LD H,$00          ; 
       li   bc,acg_key_rooms           ; LD BC,$94DD       ; 
       a    bc,hl                      ; ADD HL,BC         ; 
       .ex_de_hl                       ; EX DE,HL          ; 
;      li   hl,acg_key_init+>0001      ; LD HL,$6026       ; first key piece room
       li   hl,acg_key_1+>0001         ; LD HL,$6026       ; first key piece room
       li   bc,>0008                   ; LD BC,$0008       ; 8 bytes per entity
       movb @bytes+>03,a               ; LD A,$03          ; 3 key pieces
loc_94d3:                              ; >94d3
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       a    bc,hl                      ; ADD HL,BC         ; 
       inc  de                         ; INC DE            ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       sb   one,a                      ; DEC A             ; 
       jne  loc_94d3                   ; JR NZ,$94D3       ; 
       .endproc                        ; RET               ;

*********************************************************************
*
* randomise which doors can open/close
* 
* Used by the routine at #R$7d9a.
randomise_doors:                       ; >94f5
       .proc
       movb @counter_low,a             ; LD A,($5E12)      ;
       movb a,@l                       ; LD L,A            ; set ROM addr LSB
       bl   @ti_rnd
       movb r0,a                       ; LD A,($5C78)      ; 0-49
       andi a,>0f00                    ; AND $0F           ; limit to 4K (0000-0FFF)
       socb @bytes+>10,a               ; OR $10            ; add 4K (1000-1FFF)
       movb a,h                        ; LD H,A            ; set ROM addr MSB
       .exx                            ; EXX               ; 
       li   hl,linked_items            ; LD HL,$EEE0       ; pairs of linked items, including doors
       li   de,second_linked_item                   ; LD DE,$EEE8       ; pairs of linked items, including doors
       li   bc,>0010                   ; LD BC,$0010       ; 16 bytes per entry
loc_950b:                              ; >950b
       .exx                            ; EXX               ; 
       movb *hl,a                      ; LD A,(HL)         ; read ROM byte
       inc  hl                         ; INC HL            ; 
       .exx                            ; EXX               ; 
       cb   a,@bytes+>70               ; CP $70            ; ROM value >= 0x70 (~56% chance)
       jhe  loc_951f                   ; JR NC,$951F       ; jump if so (door always open)
       movb *de,a                      ; LD A,(DE)         ; 
       cb   a,*hl                      ; CP (HL)           ; same value?
       jne  loc_951f                   ; JR NZ,$951F       ; jump if not (no change)
       cb   a,one                      ; CP $01            ; cave doorway?
       jeq  loc_9526                   ; JR Z,$9526        ; jump if so
       cb   a,@bytes+>02               ; CP $02            ; normal doorway?
       jeq  loc_9542                   ; JR Z,$9542        ; jump if so
loc_951f:                              ; >951f
       a    bc,hl                      ; ADD HL,BC         ; next entry
       .ex_de_hl                       ; EX DE,HL          ; 
       a    bc,hl                      ; ADD HL,BC         ; next entry
       jno  !                          ; RET C             ; return if hit end of RAM
       .endproc                        ;
!
       .ex_de_hl                       ; EX DE,HL          ; 
       jmp  loc_950b                   ; JR $950B          ; 
loc_9526:                              ; >9526
       movb @bytes+>22,a               ; LD A,$22          ; mode?
loc_9528:                              ; >9528
       movb a,*de                      ; LD (DE),A         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .push de                        ; PUSH DE           ; 
;      inc  de                         ; INC DE            ;
;      inc  de                         ; INC DE            ;
;      inc  de                         ; INC DE            ;
;      inc  de                         ; INC DE            ;
;      inc  de                         ; INC DE            ; + 5
       ai   de,5
       movb *de,a                      ; LD A,(DE)         ;
       socb @bytes+>08,a               ; OR $08            ; 
       movb a,*de                      ; LD (DE),A         ; 
       .pop de                         ; POP DE            ; 
       .push hl                        ; PUSH HL           ; 
;      inc  hl                         ; INC HL            ;
;      inc  hl                         ; INC HL            ;
;      inc  hl                         ; INC HL            ;
;      inc  hl                         ; INC HL            ;
;      inc  hl                         ; INC HL            ;
       ai   hl,5
       movb *hl,a                      ; LD A,(HL)         ;
       socb @bytes+>08,a               ; OR $08            ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .pop hl                         ; POP HL            ; 
       jmp  loc_951f                   ; JR $951F          ; 
loc_9542:                              ; >9542
       movb @bytes+>20,a               ; LD A,$20          ; mode?
       jmp  loc_9528                   ; JR $9528          ; 

*********************************************************************
*
* show game statistics
* 
* Used by the routines at #R$8c35 and #R$96c9.
game_stats:                            ; >9641
       .proc
       .call @calc_visited             ; CALL $96C9        ; calculate percentage of rooms visited
       li   hl,zx_screen+>0040         ; LD HL,$4040       ; time header at 64,64
       li   de,time_msg                ; LD DE,$967F       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       li   hl,zx_screen+>1040         ; LD HL,$5040       ; score header at 64,80
       li   de,score_msg               ; LD DE,$968F       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       li   hl,green_key_init+>0003    ; LD HL,$6040       ; percent header at 64,96
       li   de,percent_msg             ; LD DE,$969F       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       li   hl,digit_charset           ; LD HL,$BFCC       ; 
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   hl,zx_screen+>0080         ; LD HL,$4080       ; clock at 128,64
       .call @print_clock              ; CALL $9607        ; print clock time at position HL
       li   hl,zx_screen+>1080         ; LD HL,$5080       ; score at 128,80
       .call @print_score              ; CALL $A1B7        ; print player score at position HL
       li   hl,cyan_key_init+>0033     ; LD HL,$6080       ; percent at 128,96
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       li   de,visited_percent         ; LD DE,$5E54       ; 
       movb one,b                      ; LD B,$01          ; 
       b    @print_bcd_bytes           ; JP $A1BF          ; print B BCD bytes at DE

*********************************************************************
*
* mark room A as visited
* 
* Used by the routine at #R$9117.
*
visit_room:                            ; >96af
       movb a,@c                       ; LD C,A            ; room A
       ; SRL C                         ; SRL C             ; 
       ; SRL C                         ; SRL C             ; 
       ; SRL C                         ; SRL C             ; 
       sb   b,b                        ; LD B,$00          ;
       srl  bc,3
       li   hl,visited_rooms           ; LD HL,$5E40       ; visit rooms bit array
       a    bc,hl                      ; ADD HL,BC         ; 
;      sla  a,1                        ; RLCA              ;
;      sla  a,1                        ; RLCA              ;
;      sla  a,1                        ; RLCA              ;
;      andi a,>3800                    ; AND $38           ;
;      socb @bytes+>c6,a               ; OR $C6            ;
;      movb a,@loc_96c6+>0001          ; LD ($96C7),A      ; self-modify bit in SET below
       movb a,r0
       swpb r0
       andi r0,7
       ai   r0,bits
       mov  r0,@loc_96c6+2
loc_96c6:                              ; >96c6
       socb @bits+0,*hl                ; SET 0,(HL)        ; mark room as visited
       .ret                            ; RET               ; OK

*********************************************************************
*
* calculate percentage of rooms visited
* 
* Used by the routine at #R$9641.
*
calc_visited:                          ; >96c9
       .proc
       li   hl,visited_rooms           ; LD HL,$5E40       ; visit rooms bit array
       li   bc,>0813                   ; LD BC,$0813       ; 8*19 bits covers all rooms
       movb @bytes+>03,d               ; LD D,$03          ; D decremented for every visited room
       sb   a,a                        ; XOR A             ; 
loc_96d2:                              ; >96d2
       .push bc                        ; PUSH BC           ; 
       movb *hl+,@e                    ; LD E,(HL)         ; 8 visited bits
;      inc  hl                         ; INC HL            ;
loc_96d5:                              ; >96d5
       mov  de,r0
       srl  r0,1                       ; RR E              ;
       movb @r0lb,@e
       jnc  loc_96e1                   ; JR NC,$96E1       ;
       sb   one,d                      ; DEC D             ; counter zero?
       jne  loc_96e1                   ; JR NZ,$96E1       ; jump if not
       movb @bytes+>03,d               ; LD D,$03          ; reset counter
       ab   @bytes+>02,a               ; ADD A,$02         ; add 2% for every 3 visited rooms
       .daa                            ; DAA               ; 
loc_96e1:                              ; >96e1
       sb   one,b                      ; DJNZ $96D5        ; 
       jne  loc_96d5                   ;                   
       .pop bc                         ; POP BC            ; 
       sb   one,@c                     ; DEC C             ; 
       jne  loc_96d2                   ; JR NZ,$96D2       ; 
       ab   one,a                      ; INC A             ; add 1% to total
       movb a,@visited_percent         ; LD ($5E54),A      ; 
       .endproc                        ; RET               ;

*********************************************************************
*
* This entry point is used by the routine at #R$7e13.
game_complete:                         ; >96ec
       li   hl,player                  ; LD HL,$EA90       ; congratulate player on completion
       .call @draw_entity_hl           ; CALL $95CC        ; undraw player
       li   hl,charset_base            ; LD HL,$BE4C       ;
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   hl,>2040                   ; LD HL,$2040       ; congratulations at 64,32
       li   de,congrat_msg             ; LD DE,$9710       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       li   hl,>3040                   ; LD HL,$3040       ; escaped message at 64,48
       li   de,escape_msg              ; LD DE,$9720       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       .call @game_stats               ; CALL $9641        ; show game statistics
       b    @loc_8c4a                  ; JP $8C4A          ; 

*********************************************************************
*
* auto-walk into the room
* 
* Used by the routine at #R$9117.
set_entry_walk:                        ; >986a
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; b7-6 is door facing direction (00=down, 01=left, 10=up,
                                                           ; 11=right)
;      sla  a,1                        ; RLCA              ;
;      sla  a,1                        ; RLCA              ; move to b1-0
;      sla  a,1                        ; RLCA              ; * 2
       srl  a,5
       andi a,>0600                    ; AND $06           ; mask to look-up offset
       movb a,@c                       ; LD C,A            ; 
       sb   b,b                        ; LD B,$00          ; 
       li   hl,walk_dir                ; LD HL,$9883       ; 
       a    bc,hl                      ; ADD HL,BC         ; 
       movb *hl+,a                     ; LD A,(HL)         ;
;      inc  hl                         ; INC HL            ;
       movb a,@player_steps_x          ; LD ($EA96),A      ; 
;      movb *hl,a                      ; LD A,(HL)         ;
       movb *hl,@player_steps_y        ; LD ($EA97),A      ;
       .ret                            ; RET               ; OK

*********************************************************************
*
* set positions of red/green/cyan keys, and mummy
* 
* Used by the routine at #R$7d9a.
set_key_positions:                     ; >98d2
       .proc
*      Green
       bl   @ti_rnd
       movb r0,a                       ; LD A,($5C78)      ; zx_frames
       li   hl,green_key_rooms         ; LD HL,$990C       ; 
       .call @get_key_room             ; CALL $9904        ; 
;      movb a,@green_key_init+>0001    ; LD ($603E),A      ; set green key room
       movb a,@green_key+>0001         ; LD ($603E),A      ; set green key room
*      Red
       bl   @ti_rnd
       movb r0,a                       ; LD A,($5C78)      ; zx_frames
       movb a,@c                       ; LD C,A            ; 
       movb @counter_low,a             ; LD A,($5E12)      ; 
       ab   @c,a                       ; ADD A,C           ; 
       li   hl,red_key_rooms           ; LD HL,$9914       ; 
       .call @get_key_room             ; CALL $9904        ; 
;      movb a,@red_key_init+1          ; LD ($6046),A      ; set red key room
       movb a,@red_key+1               ; LD ($6046),A      ; set red key room
;      movb a,@mummy_init+1            ; LD ($640E),A      ; set Mummy room to match
       movb a,@mummy+1                 ; LD ($640E),A      ; set Mummy room to match
*      Cyan
       bl   @ti_rnd
       movb r0,a                       ; LD A,($5C79)      ; zx_frames
       movb a,@c                       ; LD C,A            ; 
       movb @counter_high,a            ; LD A,($5E13)      ; 
       ab   @c,a                       ; ADD A,C           ; 
       li   hl,cyan_key_rooms          ; LD HL,$991C       ; 
       .call @get_key_room             ; CALL $9904        ; 
;      movb a,@cyan_key_init+1         ; LD ($604E),A      ; set cyan key room
       movb a,@cyan_key+1              ; LD ($604E),A      ; set cyan key room
       .endproc                        ; RET               ;

*********************************************************************
*
* Routine at 9904
* 
* Used by the routine at #R$98d2.
get_key_room:                          ; >9904
       andi a,>0700                    ; AND $07           ; 
       movb a,@c                       ; LD C,A            ; 
       sb   b,b                        ; LD B,$00          ; 
       a    bc,hl                      ; ADD HL,BC         ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       .ret                            ; RET               ; OK

*********************************************************************
*
* periodically replenish consumed food
* 
* Used by the routine at #R$7e13.
replenish_food:                        ; >9924
       movb @counter_low,a             ; LD A,($5E12)      ; 
       movb a,@c                       ; LD C,A            ; 
       movb @counter_high,a            ; LD A,($5E13)      ; 
       andi a,>0100                    ; AND $01           ; 
       socb @c,a                       ; OR C              ; 9-bit counter value zero?
       jne  replenish_food_2           ; RET NZ            ; return if not
       mov  @food_ptr,hl               ; LD HL,($5E55)     ;
;      li   de,>0008                   ; LD DE,$0008       ; 8 bytes per item
       ai   hl,>0008                   ; ADD HL,DE         ; next food item
       mov  hl,@food_ptr               ; LD ($5E55),HL     ; 
;      .push hl                        ; PUSH HL           ;
;      .pop ix                         ; POP IX            ;
       mov  hl,ix
       li   de,food_end                ; LD DE,$EDD8       ; end marker
       ; AND A                         ; AND A             ; 
       c    de,hl                      ; SBC HL,DE         ; end of list?
       jle  replenish_food_1           ; JR NC,$995B       ; jump if so
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jne  replenish_food_2           ; RET Z             ; return if so
       movb *ix,a                      ; LD A,(IX+$00)     ;
       ; AND A                         ; AND A             ; does food still exist?
       jne  replenish_food_2           ; RET NZ            ; return if so
       movb @zx_frames,a               ; LD A,($5C78)      ; pseudo random value
       andi a,>0700                    ; AND $07           ; 8 available food items
       ab   @bytes+>50,a               ; ADD A,$50         ; add food base graphic
       movb a,*ix                      ; LD (IX+$00),A     ; set food graphic (replenish)
       jmp  replenish_food_2           ; RET               ;
replenish_food_1:                      ; >995b
       li   hl,food_items              ; LD HL,$EB58       ; 
       mov  hl,@food_ptr               ; LD ($5E55),HL     ; 
replenish_food_2:
       .ret                            ; RET               ; OK

*********************************************************************
*
* draw any items in player inventory
* 
* Used by the routines at #R$9117, #R$92f5 and #R$93e3.
draw_inventory:                        ; >a13b
       .proc
       li   de,>2cc8                   ; LD DE,$2CC8       ; coords of first inventory item
       li   hl,inventory1              ; LD HL,$5E30       ; 
       movb @bytes+>03,b               ; LD B,$03          ; 3 items to draw
loc_a143:                              ; >a143
       .call @draw_inv_item            ; CALL $A14D        ; draw inventory item at position DE
;      movb @e,a                       ; LD A,E            ;
       ab   @bytes+>10,@e              ; ADD A,$10         ; next inventory position
;      movb a,@e                       ; LD E,A            ;
       sb   one,b                      ; DJNZ $A143        ; 
       jne  loc_a143                   ;                   
       .endproc                        ; RET               ;

*********************************************************************
*
* draw inventory item at position DE
* 
* Used by the routine at #R$a13b.
draw_inv_item:                         ; >a14d
       .proc
       .push bc                        ; PUSH BC           ;
       .push de                        ; PUSH DE           ; 
       .push ix                        ; PUSH IX           ; 
       li   ix,entity_to_draw          ; LD IX,$A17D       ; 
       movb *hl+,a                     ; LD A,(HL)         ; entity LSB
;      inc  hl                         ; INC HL            ;
       socb *hl+,a                     ; OR (HL)           ; object in this slot?
;      inc  hl                         ; INC HL            ;
       jne  loc_a15e                   ; JR NZ,$A15E       ; jump if so
       movb @bytes+>31,a               ; LD A,$31          ; blank space
       inc  hl                         ; INC HL            ;
       jmp  !
loc_a15e:                              ; >a15e
       movb *hl+,a                     ; LD A,(HL)         ;
!:
       movb a,*ix                      ; LD (IX+$00),A     ; set graphic
       movb @e,@>03(ix)                ; LD (IX+$03),E     ; set xpos
       movb d,@>04(ix)                 ; LD (IX+$04),D     ; set ypos
       movb *hl+,a                     ; LD A,(HL)         ;
;      inc  hl                         ; INC HL            ;
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; set attr
       .push hl                        ; PUSH HL           ; 
       .call @clear_sprite             ; CALL $A185        ; 
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .call @set_entity_attrs         ; CALL $A00E        ; paint entity with its current attr colour
       .pop hl                         ; POP HL            ; 
       .pop ix                         ; POP IX            ; 
       .pop de                         ; POP DE            ; 
       .pop bc                         ; POP BC            ; 
       .endproc                        ; RET               ;

*********************************************************************
*
* print player score at position HL
* 
* Used by the routine at #R$9641.
print_score:                           ; >a1b7
       .proc
print_score_branch:
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       li   de,score_bcd               ; LD DE,$5E2A       ; 
       movb @bytes+>03,b               ; LD B,$03          ; 3 bytes = 6 digits
* This entry point is used by the routines at #R$9607, #R$9641 and #R$a1c9.
print_bcd_bytes:                       ; >a1bf
       movb *de,a                      ; LD A,(DE)         ; print B BCD bytes at DE
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 
       srl  a,4
       andi a,>0f00                    ; AND $0F           ;
       .call @print_char               ; CALL $A1D3        ; print a single character

*********************************************************************
*
* print a single BCD digit
* 
* Used by the routine at #R$9607.
print_bcd_digit:                       ; >a1c9
       movb *de,a                      ; LD A,(DE)         ; 
       andi a,>0f00                    ; AND $0F           ; 
       .call @print_char               ; CALL $A1D3        ; print a single character
       inc  de                         ; INC DE            ; 
       sb   one,b                      ; DJNZ $A1BF        ; print B BCD bytes at DE
       jne  print_bcd_bytes            ;                   
       .endproc                        ; RET               ;

*********************************************************************
*
* print a single character
* 
* Used by the routines at #R$a1b7, #R$a1c9, #R$a1f3 and #R$a219.
*
* a: character to print
* hl: screen address
*
print_char:                            ; >a1d3
       seto @background_graphics_rom_bank
       .push bc                        ; PUSH BC           ;
       .push de                        ; PUSH DE           ; 
;      .push hl                        ; PUSH HL           ;
       movb a,@e                       ; LD L,A            ;
       sb   d,d                        ; LD H,$00          ;
;      a    hl,hl                      ; ADD HL,HL         ;
;      a    hl,hl                      ; ADD HL,HL         ;
;      a    hl,hl                      ; ADD HL,HL         ;
       sla  de,3
       a    @charset_addr,de           ; LD DE,($5E01)     ;
;      a    de,hl                      ; ADD HL,DE         ;
;      .ex_de_hl                       ; EX DE,HL          ;
;      .pop hl                         ; POP HL            ;
       movb @bytes+>08,b               ; LD B,$08          ; 8 lines in character cell
loc_a1e5:                              ; >a1e5
       movb *de+,*hl                   ; LD A,(DE)         ;
;      movb a,*hl                      ; LD (HL),A         ;
;      inc  de                         ; INC DE            ; next source byte
       ab   one,h                      ; INC H             ; next pixel line
       sb   one,b                      ; DJNZ $A1E5        ; 
       jne  loc_a1e5                   ;                   
       .pop de                         ; POP DE            ; 
       .pop bc                         ; POP BC            ; 
;      movb h,a                        ; LD A,H            ;
       sb   @bytes+>08,h               ; SUB $08           ; back to start address
;      movb a,h                        ; LD H,A            ;
       ab   one,@l                     ; INC L             ; next position to the right
       .ret                            ; RET               ; OK

*********************************************************************
*
* show a line of text, first byte is attr
* 
* Used by the routines at #R$7caf, #R$8c35, #R$9641 and #R$96c9.
*
* hl: y,x coordinates
* de: text to print, prefixed by attribute
*
colour_text:                           ; >a1f3
       .proc
colour_text_jump_target:
       .push hl                        ; PUSH HL           ;
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       movb *de,a                      ; LD A,(DE)         ; text attr colour
       .ex_af_af_                      ; EX AF,AF'         ; 
       inc  de                         ; INC DE            ; 
       .exx                            ; EXX               ; display addr in HL
       .pop hl                         ; POP HL            ; 
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
* This entry point is used by the routine at #R$7d8a.
loc_a1ff:                              ; >a1ff
       .exx                            ; EXX               ; attr addr in HL'
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,r0                       ; BIT 7,A           ; last character?
       andi r0,>8000                   ;                   
       jne  loc_a210                   ; JR NZ,$A210       ; jump if so
       .call @print_char               ; CALL $A1D3        ; print a single character
       inc  de                         ; INC DE            ; 
       .exx                            ; EXX               ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb a,*hl                      ; LD (HL),A         ; set attr
       ab   one,@l                     ; INC L             ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       jmp  loc_a1ff                   ; JR $A1FF          ; 
loc_a210:                              ; >a210
       andi a,>7f00                    ; AND $7F           ; strip end marker b7
       .call @print_char               ; CALL $A1D3        ; print a single character
       .exx                            ; EXX               ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb a,*hl                      ; LD (HL),A         ; set attr
       .endproc                        ; RET               ;

*********************************************************************
*
* draw side panel background scroll
* 
* Used by the routine at #R$7d9a.
draw_side_panel:                       ; >a219
       .proc
       seto @background_graphics_rom_bank
       li   hl,panel_chars             ; LD HL,$B03A       ;
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   hl,>00c0                   ; LD HL,$00C0       ; 
       li   de,panel_data              ; LD DE,$B32A       ; 
       li   bc,>0818                   ; LD BC,$0818       ; 8x24
draw_side_panel_1:                     ; >a228
       .push bc                        ; PUSH BC           ; 
       .push hl                        ; PUSH HL           ; 
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
draw_side_panel_2:                     ; >a22d
       movb *de+,a                     ; LD A,(DE)         ;
;      inc  de                         ; INC DE            ;
       .call @print_char               ; CALL $A1D3        ; print a single character
       sb   one,b                      ; DJNZ $A22D        ; 
       jne  draw_side_panel_2          ;
       .pop hl                         ; POP HL            ; 
       movb h,a                        ; LD A,H            ; 
       ab   @bytes+>08,a               ; ADD A,$08         ; 
       movb a,h                        ; LD H,A            ; 
       .pop bc                         ; POP BC            ; 
       sb   one,@c                     ; DEC C             ; 
       jne  draw_side_panel_1          ; JR NZ,$A228       ;
       b    @add_score_bc_bcd_1        ; JP $A1AE          ;

*********************************************************************
*
* draw side-panel colours, which follow room colour
* 
* Used by the routine at #R$9117.
draw_panel_attrs:                      ; >a240
       .proc
       li   hl,>00c0                   ; LD HL,$00C0       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       li   bc,>0818                   ; LD BC,$0818       ; 8x24
       movb @room_attr,a               ; LD A,($5E1A)      ; 
       inv  a                          ; CPL               ; invert for colour contrast
       andi a,>0700                    ; AND $07           ; 
       cb   a,@bytes+>02               ; CP $02            ; 
       jhe  loc_a255                   ; JR NC,$A255       ; red or brighter?
       movb @bytes+>44,a               ; LD A,$44          ; change blue to bright green
loc_a255:                              ; >a255
       movb a,@e                       ; LD E,A            ; save attr value
       .push de                        ; PUSH DE           ; 
loc_a257:                              ; >a257
       .push bc                        ; PUSH BC           ; 
       .push hl                        ; PUSH HL           ; 
loc_a259:                              ; >a259
       movb @e,*hl                     ; LD (HL),E         ; set panel attr
       ab   one,@l                     ; INC L             ; 
       sb   one,b                      ; DJNZ $A259        ; 
       jne  loc_a259                   ;                   
       .pop hl                         ; POP HL            ; 
       li   bc,>0020                   ; LD BC,$0020       ; line pitch
       a    bc,hl                      ; ADD HL,BC         ; down a row
       .pop bc                         ; POP BC            ; 
       sb   one,@c                     ; DEC C             ; 
       jne  loc_a257                   ; JR NZ,$A257       ;
;      Now set special attributes
       li   hl,>90c8                   ; LD HL,$90C8       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       movb @room_attr,a               ; LD A,($5E1A)      ;
       li   bc,>0303                   ; LD BC,$0303       ; 3x3 (rosette body)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       ab   one,@l                     ; INC L             ; 
       movb a,*hl                      ; LD (HL),A         ; 
       a    de,hl                      ; ADD HL,DE         ; 
       li   bc,>0202                   ; LD BC,$0202       ; 2x2 (rosette tail)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   hl,>98d0                   ; LD HL,$98D0       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       .pop de                         ; POP DE            ; 
       movb @e,*hl                     ; LD (HL),E         ; rosette centre
       li   hl,>7dc8                   ; LD HL,$7DC8       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       li   bc,>0603                   ; LD BC,$0603       ; 6x3
       movb @bytes+>47,a               ; LD A,$47          ; bright white (lives)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   hl,>5fc8                   ; LD HL,$5FC8       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       li   bc,>0604                   ; LD BC,$0604       ; 6x4
       movb @bytes+>46,a               ; LD A,$46          ; bright yellow (chicken)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   hl,>48C8                   ; LD HL,$48C8       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       li   bc,>0601                   ; LD BC,$0601       ; 6x1
       movb @bytes+>45,a               ; LD A,$45          ; bright cyan (score caption)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   bc,>0601                   ; LD BC,$0601       ; 6x1
       movb @bytes+>47,a               ; LD A,$47          ; bright white (score)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   hl,>38c8                   ; LD HL,$38C8       ; 
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       li   bc,>0601                   ; LD BC,$0601       ; 6x1
       movb @bytes+>43,a               ; LD A,$43          ; bright magenta (time caption)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   bc,>0601                   ; LD BC,$0601       ; 
       movb @bytes+>47,a               ; LD A,$47          ; bright white (time)
       .call @fill_bc_hl_a             ; JP $809A          ; fill C rows of B columns of value A at address HL
       .endproc

*********************************************************************
*
* draw lives sprites in side panel
* 
* Used by the routines at #R$7d9a and #R$9443.
draw_lives:                            ; >a2ce
       .proc
draw_lives_branch:
       .push ix                        ; PUSH IX           ;
       li   ix,entity_to_draw          ; LD IX,$A17D       ; 
       movb @menu_selection,a          ; LD A,($5E00)      ; 
       sla  a,1                        ; RLCA              ;
       andi a,>3000                    ; AND $30           ; extract character type from menu
       socb one,a                      ; OR $01            ; offset to first graphic
       movb a,*ix                      ; LD (IX+$00),A     ; character type
       movb @bytes+>47,@>05(ix)        ; LD (IX+$05),$47   ; bright white
       li   hl,>8dc8                   ; LD HL,$8DC8       ; coords of lives in side panel
       movb @l,@>03(ix)                ; LD (IX+$03),L     ; 
       movb h,@>04(ix)                 ; LD (IX+$04),H     ; 
       movb @lives,@c                  ; LD A,($5E21)      ;
;       movb a,@c                      ; LD C,A            ; number of lives to show
       movb @bytes+>03,b               ; LD B,$03          ; up to 3 lives to draw
loc_a2f2:                              ; >a2f2
       .push bc                        ; PUSH BC           ; 
       .call @clear_sprite             ; CALL $A185        ; clear lives location
       movb @c,a                       ; LD A,C            ; 
       ; AND A                         ; AND A             ; life to show?
       jeq  loc_a2fd                   ; JR Z,$A2FD        ; jump if not
       .call @draw_entity              ; CALL $9F4A        ; draw player character
loc_a2fd:                              ; >a2fd
;      movb @>03(ix),a                 ; LD A,(IX+$03)     ;
       ab   @bytes+>10,@>03(ix)        ; ADD A,$10         ; offset to next life position
;      movb a,@>03(ix)                 ; LD (IX+$03),A     ;
       .pop bc                         ; POP BC            ;
       cb   @c,@zero
       jeq  loc_a30c
       sb   one,@c                     ; DEC C             ;
       jgt  loc_a30c                   ; JP P,$A30C        ;
       sb   @c,@c                      ; LD C,$00          ; min lives is zero
loc_a30c:                              ; >a30c
       sb   one,b                      ; DJNZ $A2F2        ; draw remaining slots
       jne  loc_a2f2                   ;                   
       .pop ix                         ; POP IX            ; 
       .endproc                        ; RET               ;
