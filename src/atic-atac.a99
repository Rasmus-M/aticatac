* Atic Atac for Sinclair ZX Spectrum
* (c) 1983 Ashby Computers and Graphics Ltd.
* 
* Disassembled by obo
* 
* Differences from original release:
* 6009: C0->00 - disable protection check on FRAMES sysvar after loading
* 7E91: B0->05 - new LSB of JP (HL) instruction (below)
* 7E92: 5C->D5 - new MSB of JP (HL) instruction
* 971F: D4->D3 - fixed typo in congratulations message
* D505: 00->E9 - JP (HL) instruction moved from printer buffer

* RM: I found that after a byte compare (cp on Z80, cb on the TI) the carry condition on the Z80 correspond to JL on the TI
* or JHE for the inverse condition. If the carry flag is checked after a subtraction instead of a compare this has to be
* turned into a compare followed by a (possible) subtraction on the TI.

* Routine at 6000
start:                                 ; >6000
      limi 0
      lwpi wrksp
      bl   @ti_setup_environment
;       limi 0                          ; DI                ;
;       li   sp,menu_selection          ; LD SP,$5E00       ;
;_6004:                                 ; >6004
;       movb @zx_frames+>0001,a         ; LD A,($5C79)      ;
;       cb   a,@bytes+>25               ; CP $25            ; is frames MSB as expected?
;       jeq  !                          ; RET NZ            ;
;       .ret                            ;
;!
        b    @reset_menu                ; JP $7C19          ;

* Routine at 7c19
* 
* Used by the routine at #R$6000.
reset_menu:                            ; >7c19
       li   hl,menu_selection          ; LD HL,$5E00       ; 
       movb @bytes+>10,b               ; LD B,$10          ; 
clear_menu_data:                       ; >7c1e
       sb   *hl,*hl                    ; LD (HL),$00       ; clear menu data
       inc  hl                         ; INC HL            ; 
       sb   one,b                      ; DJNZ $7C1E        ; 
       jne  clear_menu_data            ;
       li   hl,charset_base            ; LD HL,$BE4C       ;
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
* This entry point is used by the routine at #R$8c35.
main_menu:                             ; >7c29
       .call @clear_screen             ; CALL $80AA        ; clear display, attributes, and set black border
       .call @draw_menu_icons          ; CALL $A311        ; draw menu icons for controls and player acharacters
menu_loop:                             ; >7c2f
       .call @draw_menu_text           ; CALL $7CAF        ; 

       bl   @upload_zx_screen
!      li   r0,KEY_0
       bl   @ti_check_key
       jeq  -!
       b    @start_game

       movb @bytes+>f7,a               ; LD A,$F7          ; xxx54321
       ; OUT ($FD),A                   ; OUT ($FD),A       ; 
       ; IN A,($FE)                    ; IN A,($FE)        ; 
       inv  a                          ; CPL               ; set bits now mean pressed keys
       movb a,@e                       ; LD E,A            ; 
       movb @menu_selection,a          ; LD A,($5E00)      ; 
       movb @e,r0                      ; BIT 0,E           ; 1 pressed?
       andi r0,>0100                   ;                   
       jeq  loc_7c43                   ; JR Z,$7C43        ; jump if not
       andi a,>f900                    ; AND $F9           ; select Keyboard
loc_7c43:                              ; >7c43
       movb @e,r0                      ; BIT 1,E           ; 2 pressed?
       andi r0,>0200                   ;                   
       jeq  loc_7c4b                   ; JR Z,$7C4B        ; jump if not
       andi a,>f900                    ; AND $F9           ; 
       socb @bytes+>02,a               ; OR $02            ; select Kempston joystick
loc_7c4b:                              ; >7c4b
       movb @e,r0                      ; BIT 2,E           ; 3 pressed?
       andi r0,>0400                   ;                   
       jeq  loc_7c53                   ; JR Z,$7C53        ; jump if not
       andi a,>f900                    ; AND $F9           ; 
       socb @bytes+>04,a               ; OR $04            ; select Cursor joystick
loc_7c53:                              ; >7c53
       movb @e,r0                      ; BIT 3,E           ; 4 pressed?
       andi r0,>0800                   ;                   
       jeq  loc_7c59                   ; JR Z,$7C59        ; jump if not
       andi a,>e700                    ; AND $E7           ; select Knight
loc_7c59:                              ; >7c59
       movb @e,r0                      ; BIT 4,E           ; 5 pressed?
       andi r0,>1000                   ;                   
       jeq  loc_7c61                   ; JR Z,$7C61        ; jump if not
       andi a,>e700                    ; AND $E7           ; 
       socb @bytes+>08,a               ; OR $08            ; select Wizard
loc_7c61:                              ; >7c61
       movb a,d                        ; LD D,A            ; 
       movb @bytes+>ef,a               ; LD A,$EF          ; xxx67890
       ; OUT ($FD),A                   ; OUT ($FD),A       ; 
       ; IN A,($FE)                    ; IN A,($FE)        ; 
       inv  a                          ; CPL               ; set bits now mean pressed keys
       movb a,@e                       ; LD E,A            ; 
       movb d,a                        ; LD A,D            ; 
       movb @e,r0                      ; BIT 4,E           ; 6 pressed?
       andi r0,>1000                   ;                   
       jeq  loc_7c73                   ; JR Z,$7C73        ; jump if not
       andi a,>e700                    ; AND $E7           ; 
       socb @bytes+>10,a               ; OR $10            ; select Serf
loc_7c73:                              ; >7c73
       movb a,@menu_selection          ; LD ($5E00),A      ; 
       movb a,@c                       ; LD C,A            ; 
       movb @e,r0                      ; BIT 0,E           ; 0 pressed?
       andi r0,>0100                   ;                   
       jeq  !                          ; JP NZ,$7D9A       ; jump if so
       b    @start_game                ;                   
!
       li   hl,menu_attrs              ; LD HL,$7CEA       ; 
       movb @bytes+>03,b               ; LD B,$03          ; 
       movb @c,a                       ; LD A,C            ; 
       .call @set_menu_attrs           ; CALL $7C90        ; highlight keyboard/kempston/cursor
       movb @bytes+>03,b               ; LD B,$03          ; 
       movb @c,a                       ; LD A,C            ; 
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 
       .call @set_menu_attrs           ; CALL $7C90        ; highlight knight/wizard/serf
       b    @menu_loop                 ; JP $7C2F          ; 

* draw menu icons for controls and player characters
*
* Used by the routine at #R$7c19.
draw_menu_icons:                       ; >a311
       .proc
       seto @sprite_graphics_rom_bank
       li   ix,entity_to_draw          ; LD IX,$A17D       ;
       li   hl,menu_entities           ; LD HL,$A331       ; entities for icons in the menu position
       movb @bytes+>09,b               ; LD B,$09          ; 3*2 icons for controls, 3 player characters
draw_menu_icons_1:                     ; >a31a
       .push bc                        ; PUSH BC           ;
       li   de,entity_to_draw          ; LD DE,$A17D       ;
       li   bc,>0008                   ; LD BC,$0008       ;
       .ldir                           ; LDIR              ;
       .push hl                        ; PUSH HL           ;
       .push de                        ; PUSH DE           ;
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .call @set_entity_attrs         ; CALL $A00E        ; paint entity with its current attr colour
       .pop de                         ; POP DE            ;
       .pop hl                         ; POP HL            ;
       .pop bc                         ; POP BC            ;
       sb   one,b                      ; DJNZ $A31A        ;
       jne  draw_menu_icons_1                   ;
       .endproc                        ; RET               ;

* set menu attrs to reflect current selection
* 
* Used by the routine at #R$7c19.
set_menu_attrs:                        ; >7c90
       ; RRCA                          ; RRCA              ; 
loc_7c91:                              ; >7c91
       andi a,>0300                    ; AND $03           ; 
       jeq  loc_7c9c                   ; JR Z,$7C9C        ; 
       .call @set_flash_off            ; CALL $7CA4        ; 
loc_7c98:                              ; >7c98
       sb   one,a                      ; DEC A             ; 
       sb   one,b                      ; DJNZ $7C91        ; 
       jne  loc_7c91                   ;                   
       .ret                            ; RET               ; 
loc_7c9c:                              ; >7c9c
       .call @set_flash_on             ; CALL $7CAB        ; 
       jmp  loc_7c98                   ; JR $7C98          ; 
       socb @bits+7,*hl                ; SET 7,(HL)        ; flash on
       inc  hl                         ; INC HL            ; 

* Routine at 7ca4
* 
* Used by the routine at #R$7c90.
set_flash_off:                         ; >7ca4
       szcb @bits+7,*hl                ; RES 7,(HL)        ; clear flash attribute
       inc  hl                         ; INC HL            ; 
       .ret                            ; RET               ; 
       szcb @bits+7,*hl                ; RES 7,(HL)        ; clear flash attribute
       inc  hl                         ; INC HL            ; 

* Routine at 7cab
* 
* Used by the routine at #R$7c90.
set_flash_on:                          ; >7cab
       socb @bits+7,*hl                ; SET 7,(HL)        ; set flash attribute
       inc  hl                         ; INC HL            ; 
       .ret                            ; RET               ; 

* Routine at 7caf
* 
* Used by the routine at #R$7c19.
draw_menu_text:                        ; >7caf
       .proc
       li   hl,charset_base            ; LD HL,$BE4C       ;
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   de,menu_attrs              ; LD DE,$7CEA       ; 
       .exx                            ; EXX               ; 
       li   hl,menu_ycoords            ; LD HL,$7CF1       ; 
       li   de,menu_options            ; LD DE,$7CF8       ; "1  KEYBOAR"
       movb @bytes+>07,b               ; LD B,$07          ; 7 lines
loc_7cc1:                              ; >7cc1
       .exx                            ; EXX               ; 
       movb *de+,a                     ; LD A,(DE)         ; text attribute colour
       movb a,@text_attr               ; LD ($5E22),A      ; 
;      inc  de                         ; INC DE            ;
       .exx                            ; EXX               ; 
       .push bc                        ; PUSH BC           ; 
       movb *hl+,a                     ; LD A,(HL)         ; next text character
;      inc  hl                         ; INC HL            ;
       .push hl                        ; PUSH HL           ; 
       movb a,h                        ; LD H,A            ; 
       movb @bytes+>58,@l              ; LD L,$58          ; x coord for text
       .call @print_text               ; CALL $7D8A        ; 
       .exx                            ; EXX               ; 
       .pop hl                         ; POP HL            ; 
       .pop bc                         ; POP BC            ; 
       inc  de                         ; INC DE            ; 
       sb   one,b                      ; DJNZ $7CC1        ; 
       jne  loc_7cc1                   ;                   
       li   hl,>b800                   ; LD HL,$B800       ; copyright at 0,184
       li   de,copyright_msg           ; LD DE,$7D51       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       li   hl,>0020                   ; LD HL,$0020       ; header at 32,0
       li   de,header_msg              ; LD DE,$7D72       ; 
       b    @colour_text_jump_target   ; JP $A1F3          ; show a line of text, first byte is attr

* Routine at 7d8a
* 
* Used by the routine at #R$7caf.
print_text:                            ; >7d8a
       .proc
       .push hl                        ; PUSH HL           ; 
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       movb @text_attr,a               ; LD A,($5E22)      ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       .exx                            ; EXX               ; 
       .pop hl                         ; POP HL            ; 
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       b    @loc_a1ff                  ; JP $A1FF          ; 

*********************************************************************
*
* Routine at 7d9a
* 
* Used by the routine at #R$7c19.
start_game:                            ; >7d9a
       .call @clear_game_data          ; CALL $80CB        ; clear 5E10-5FFF
       movb @bytes+>03,a               ; LD A,$03          ; 3 lives on startup
       movb a,@lives                   ; LD ($5E21),A      ; 
       li   hl,food_items              ; LD HL,$EB58       ; 
       mov  hl,@food_ptr               ; LD ($5E55),HL     ; 
       .call @clear_screen             ; CALL $80AA        ; clear display, attributes, and set black border
       .call @draw_side_panel          ; CALL $A219        ; draw side panel background scroll
       .call @draw_lives               ; CALL $A2CE        ; draw lives sprites in side panel
       .call @place_key_pieces         ; CALL $94B6        ; set locations of ACG key pieces
;      .call @set_key_positions        ; CALL $98D2        ; set positions of red/green/cyan keys, and mummy
       .call @reset_game_state         ; CALL $8D61        ; copy initial game state to working state area
       .call @set_key_positions        ; CALL $98D2        ; set positions of red/green/cyan keys, and mummy
       .call @randomise_doors          ; CALL $94F5        ; randomise which doors can open/close
       .call @prepare_player           ; CALL $9443        ; prepare player to spawn
       b    @enter_room                ; JP $9147          ; Will jump back to main_loop

*********************************************************************
*
* Routine at 7dc3
* 
* Used by the routines at #R$7e13 and #R$9117.
main_loop:                             ; >7dc3
       li   sp,stack                   ; LD SP,$5E00       ;
       ; EI                            ; EI                ; 
       sb   a,a                        ; XOR A             ; 
loc_7dc8:                              ; >7dc8
       movb a,@num_creatures           ; LD ($5E25),A      ; number of creatures processed this frame
       li   ix,acg_key_1               ; LD IX,$EAA8       ; first entity
       movb @game_flags,r0             ; LD A,($5E14)      ; b0 set if room content drawn
;      movb a,r0                       ; BIT 0,A           ; room content drawn?
       andi r0,>0100                   ;                   
       jne  main_loop_1                ; JR NZ,$7DDC       ; jump if so
       li   ix,linked_items            ; LD IX,$EEE0       ; pairs of linked items, including doors
       jmp  draw_room                  ; JR $7E23          ;
main_loop_1:                           ; >7ddc
       movb @zx_frames,a               ; LD A,($5C78)      ;
       movb a,@c                       ; LD C,A            ; 
       movb @last_frames,a             ; LD A,($5E03)      ; 
       cb   a,@c                       ; CP C              ; same frame as last time?
       jeq  !                          ; CALL NZ,$7EB2     ; call if not
       .call @run_player               ;
!
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; entity in player room?
       jne  !                          ; JP Z,$7E7E        ; jump if so
       li   hl,loop_return_1           ; LD HL,$7DF3       ;
       b    @process_action           ;
!
loop_return_1:                         ; >7df3
;      li   de,>0008                   ; LD DE,$0008       ; entity size
       ai    ix,8                       ; ADD IX,DE         ; next entity
;      .push ix                        ; PUSH IX           ;
;      .pop hl                         ; POP HL            ;
;      li   de,creature1               ; LD DE,$EE60       ; end marker
;      ; AND A                         ; AND A             ;
;       c    de,hl                     ; SBC HL,DE         ; end of list?
       ci   ix,creature1
       jl   main_loop_1                ; JR C,$7DDC        ; jump if not
**
* This entry point is used by the routine at #R$7e13.
main_loop_2:                           ; >7e03
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       movb a,@c                       ; LD C,A            ; 
       movb @last_frames,a             ; LD A,($5E03)      ; 
       cb   a,@c                       ; CP C              ; same frame as last time?
       jeq  !                          ; CALL NZ,$7EB2     ; call if not
      .call @run_player               ;
!
       li   hl,loop2_return            ; LD HL,$7E13       ; 
       jmp  process_action             ; JR $7E7E          ;
* Routine at 7e13
loop2_return:                          ; >7e13
;      li   de,>0010                   ; LD DE,$0010       ; 16 bytes per linked entity pair
       ai   ix,16                      ; ADD IX,DE         ; next pair
;      .push ix                        ; PUSH IX           ;
;      .pop hl                         ; POP HL            ;
;      mov  ix,hl
;      li   de,linked_items            ; LD DE,$EEE0       ; pairs of linked items, including doors
;      ; AND A                         ; AND A             ;
       ci   ix,linked_items            ; SBC HL,DE         ;
       jl  main_loop_2                 ; JR C,$7E03         ;
*
draw_room:
       .call @draw_room_decor
       mov  @counter_low,@l            ; LD HL,($5E12)     ;
       movb @counter_high,h
       inc  hl                         ; INC HL            ; advance game loop counter
       mov  @l,@counter_low            ; LD ($5E12),HL     ;
       mov  h,@counter_high
;      li   hl,game_flags              ; LD HL,$5E14       ; b0 set if room content drawn
       movb @game_flags,r0             ; BIT 0,(HL)        ; room drawn yet?
       andi r0,>0100                   ;                   
       jne  loc_7e55                   ; JR NZ,$7E55       ; jump if so
       .call @draw_entities            ; CALL $9291        ; draw all non-monster entities in the current room
loc_7e55:                              ; >7e55
;      li   hl,game_flags              ; LD HL,$5E14       ; b0 set if room content drawn
       socb @bits+0,@game_flags        ; SET 0,(HL)        ; mark room as drawn
*      Update random number
;       mov  @rand8,hl                  ; LD HL,($5E05)     ; another random number source
;       mov  @zx_frames,de              ; LD DE,($5C78)     ;
;       a    de,hl                      ; ADD HL,DE         ; add in frames
;       movb @counter_low,a             ; LD A,($5E12)      ;
;       ab   @l,a                       ; ADD A,L           ; add in counter low
;       movb a,@l                       ; LD L,A            ;
;       mov  hl,@rand8                  ; LD ($5E05),HL     ; only low 8 bits are meaningfully random
       bl   @ti_rnd
       mov  r0,@rand8
       movb r0,@zx_frames
       .call @check_pickup_key         ; CALL $938B        ; check whether pick-up key has been pressed
       .call @check_pause              ; CALL $9489        ; check for pause key, return when not paused
       .call @replenish_food           ; CALL $9924        ; periodically replenish consumed food
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@bytes+>8e               ; CP $8E            ; end room?
       jne  !                          ; JP Z,$96EC        ; congratulate player on completion
       b    @game_complete             ;                   
!
       inc  @frame
       bl   @upload_zx_screen
       b    @main_loop                 ; JP $7DC3          ;

* Routine at 7e7e
* 
* Used by the routine at #R$7dc3.
process_action:                        ; >7e7e
       b    *hl                        ; TODO
       .push hl                        ; PUSH HL           ; push return location
* This entry point is used by the routine at #R$7eb2.
run_handler:                           ; >7e7f
       li   hl,handler_table           ; LD HL,$7EE6       ;
lookup_graphic:                        ; >7e82
       movb *ix,@c                     ; LD C,(IX+$00)     ;
       b    @branch_c_hl

* run player, weapon, and sound handlers
* 
* Used by the routine at #R$7dc3.
run_player:                            ; >7eb2
       rt                              ; TODO
;      limi 0                          ; DI                ;
       .push ix                        ; PUSH IX           ; 
       movb one,a                      ; LD A,$01          ; 
       movb a,@in_handlers             ; LD ($5E04),A      ; flag set but never read
       li   ix,player                  ; LD IX,$EA90       ; 
* This entry point is used by the routine at #R$7ec5.
loc_7ebe:                              ; >7ebe
       li   hl,handler_loop            ; LD HL,$7EC5       ; 
       .push hl                        ; PUSH HL           ; 
       b    @run_handler               ; JP $7E7F          ; 

* Routine at 7ec5
handler_loop:                          ; >7ec5
       li   de,>0008                   ; LD DE,$0008       ; 8 bytes per entry
       a    de,ix                      ; ADD IX,DE         ; next entry
       .push ix                        ; PUSH IX           ; 
       .pop hl                         ; POP HL            ; 
       li   de,acg_key_1               ; LD DE,$EAA8       ; end marker
       ; AND A                         ; AND A             ; 
       s    de,hl                      ; SBC HL,DE         ; end of list?
       joc  loc_7ebe                   ; JR C,$7EBE        ; TODO: check code. jump if not
       .call @clock_tick               ; CALL $95DA        ; advance the clock 1 frame
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       movb a,@last_frames             ; LD ($5E03),A      ; 
       sb   a,a                        ; XOR A             ; 
       movb a,@in_handlers             ; LD ($5E04),A      ; flag set but never read
       .pop ix                         ; POP IX            ; 
       ; EI                            ; EI                ; 
       .ret                            ; RET               ; 

* Data block at 7ee6
handler_table:                         ; >7ee6
       data h_creat_delay,h_knight,h_knight,h_knight                 ; &00
       data h_knight,h_knight,h_knight,h_knight                      ; &04 extra delay for inactive creatures
       data h_knight,h_knight,h_knight,h_knight                      ; &08
       data h_knight,h_knight,h_knight,h_knight                      ; &0c
       data h_knight,h_wizard,h_wizard,h_wizard                      ; &10
       data h_wizard,h_wizard,h_wizard,h_wizard                      ; &14
       data h_wizard,h_wizard,h_wizard,h_wizard                      ; &18
       data h_wizard,h_wizard,h_wizard,h_wizard                      ; &1c
       data h_wizard,h_serf,h_serf,h_serf                            ; &20
       data h_serf,h_serf,h_serf,h_serf                              ; &24
       data h_serf,h_serf,h_serf,h_serf                              ; &28
       data h_serf,h_serf,h_serf,h_serf                              ; &2c
       data h_serf,h_blank,h_creat_delay,h_creat_delay               ; &30
       data h_fireball,h_fireball,h_fireball,h_fireball              ; &34
       data h_sword,h_sword,h_sword,h_sword                          ; &38
       data h_sword,h_sword,h_sword,h_sword                          ; &3c
       data h_axe,h_axe,h_axe,h_axe                                  ; &40
       data h_axe,h_axe,h_axe,h_axe                                  ; &44
       data h_creat_delay,h_creat_delay,h_creat_delay,h_creat_delay  ; &48
       data h_pumpkin_spider,h_pumpkin_spider,h_ghostlet,h_ghostlet  ; &4c
       data h_food,h_food,h_food,h_food                              ; &50
       data h_food,h_food,h_food,h_food                              ; &54
       data h_sparkles,h_sparkles,h_sparkles,h_sparkles              ; &58
       data h_pumpkin_spider,h_pumpkin_spider,h_spikey_ghost,h_spikey_ghost ; &5c
       data h_blob,h_blob,h_ghoul,h_ghoul                            ; &60
       data h_sound_effect,h_sound_effect2,h_player_appear,h_death   ; &64
       data h_spikey_ghost,h_spikey_ghost,h_batlet,h_batlet          ; &68
       data h_pop,h_pop,h_pop,h_pop                                  ; &6c
       data h_mummy,h_mummy,h_mummy,h_mummy                          ; &70
       data h_frankenstein,h_frankenstein,h_frankenstein,h_frankenstein ; &74
       data h_devil,h_devil,h_devil,h_devil                          ; &78
       data h_dracula,h_dracula,h_dracula,h_dracula                  ; &7c
       data h_pickup_item,h_pickup_item,h_pickup_item,h_pickup_item  ; &80
       data h_pickup_item,h_pickup_item,h_pickup_item,h_pickup_item  ; &84
       data h_pickup_item,h_pickup_item,h_pickup_item,h_pickup_item  ; &88
       data h_pickup_item,h_pickup_item,h_pickup_item,h_tombstone    ; &8c
       data h_witch,h_witch,h_witch,h_witch                          ; &90
       data h_monk_bat,h_monk_bat,h_monk_bat,h_monk_bat              ; &94
       data h_monk_bat,h_monk_bat,h_monk_bat,h_monk_bat              ; &98
       data h_hunchback,h_hunchback,h_hunchback,h_hunchback          ; &9c
       data h_food_eaten,h_mushroom                                  ; &a0

* extra delay applied to inactive creatures
h_creat_delay:                         ; >807a
       .push ix                        ; PUSH IX           ; 
       .pop hl                         ; POP HL            ; 
       li   de,creature1               ; LD DE,$EE60       ; end marker
       ; AND A                         ; AND A             ; 
       s    de,hl                      ; SBC HL,DE         ; subtract from entity address
       movb h,a                        ; LD A,H            ; 
       ; AND A                         ; AND A             ; before creature 1?
       jeq  !                          ; RET NZ            ; return if so
       .ret                            ;                   
!
       movb @l,a                       ; LD A,L            ; 
       cb   a,@bytes+>30               ; CP $30            ; after creature3 (16 bytes &0eac)
       jl   !                          ; RET NC            ; return if so
       .ret                            ;                   
!
       li   hl,>00c0                   ; LD HL,$00C0       ; delay to keep game speed stable
delay_loop:                            ; >808d
       dec  hl                         ; DEC HL            ; 
       movb h,a                        ; LD A,H            ; 
       socb @l,a                       ; OR L              ; 
       jne  delay_loop                 ; JR NZ,$808D       ; 
       .ret                            ; RET               ; 

* clear screen and attrs of play area
* 
* Used by the routines at #R$8c35, #R$9117 and #R$9731.
clear_play_area:                       ; >8093
       .proc
       li   hl,zx_screen               ; LD HL,$4000       ;
       li   bc,>18c0                   ; LD BC,$18C0       ; 24x192
       sb   a,a                        ; XOR A             ; 
       jmp  !

* fill C rows of B columns of value A at address HL
* 
* Used by the routines at #R$9bea and #R$a240.
fill_bc_hl_a:                          ; >809a
       .proc
!:
       .push bc                        ; PUSH BC           ;
       .push hl                        ; PUSH HL           ; 
       li   de,>0020                   ; LD DE,$0020       ; line stride is 32 bytes
loc_809f:                              ; >809f
       movb a,*hl+                     ; LD (HL),A         ;
;      inc  hl                         ; INC HL            ;
       sb   one,b                      ; DJNZ $809F        ; 
       jne  loc_809f                   ;                   
       .pop hl                         ; POP HL            ; 
       a    de,hl                      ; ADD HL,DE         ; 
       .pop bc                         ; POP BC            ; 
       sb   one,@c                     ; DEC C             ; 
       jne  -!                         ; JR NZ,$809A       ; fill C rows of B columns of value A at address HL
       .endproc                        ; RET               ;

* clear display, attributes, and set black border
* 
* Used by the routines at #R$7c19 and #R$7d9a.
clear_screen:                          ; >80aa
       .proc
       .call @clear_attrs             ; CALL $80C2         ; clear attribute file
       .call @clear_display           ; CALL $80B4         ; clear display file
       sb   a,a                        ; XOR A             ; 
       bl   @ti_set_border_color
       ; OUT ($FE),A                   ; OUT ($FE),A       ; black border
       .endproc                        ; RET               ;

* clear display file
* 
* Used by the routine at #R$80aa.
clear_display:                         ; >80b4
       .proc
       li   hl,zx_screen               ; LD HL,$4000       ; 
;      movb @bytes+zx_attrs_msb,b      ; LD B,$58          ;
       li   bc,>1800
clear_display_1:
       bl   @clear
       .endproc

;* This entry point is used by the routine at #R$80cb.
;loc_80b9:                              ; >80b9
;       sb   @c,@c                      ; LD C,$00          ;
;* This entry point is used by the routine at #R$80c2.
;loc_80bb:                              ; >80bb
;       movb @c,*hl                     ; LD (HL),C         ;
;       inc  hl                         ; INC HL            ;
;       movb h,a                        ; LD A,H            ;
;       cb   a,b                        ; CP B              ;
;       jne  loc_80bb                   ; JR NZ,$80BB       ;
;       .ret                            ; RET               ;

* clear attribute file
* 
* Used by the routine at #R$80aa.
clear_attrs:                           ; >80c2
       .proc
       li   hl,zx_attrs                ; LD HL,$5800       ; 
;       movb @bytes+zx_attrs_msb+3,b    ; LD B,$5B          ;
;       sb   @c,@c                      ; LD C,$00          ;
;       jmp  loc_80bb                   ; JR $80BB          ;
       li   bc,>300
       jmp  clear_display_1

* clear 5E10-5FFF
* 
* Used by the routine at #R$7d9a.
clear_game_data:                       ; >80cb
       .proc
       li   hl,game_data               ; LD HL,$5E10       ;
;       movb @bytes+>60,b               ; LD B,$60          ; clear up to address 6000
;       jmp  loc_80b9                   ; JR $80B9          ;
       li   bc,game_data_end-game_data
       jmp  clear_display_1

* wizard character handler
h_wizard:                              ; >80d2
       li   bc,>2020                   ; LD BC,$2020       ; walk deceleration
       li   de,>2020                   ; LD DE,$2020       ; walk acceleration
       li   hl,>2020                   ; LD HL,$2020       ; unused
       .call @control_player           ; CALL $8D77        ; read controls and apply player movement
       movb @>06(ix),@e                ; LD E,(IX+$06)     ; x velocity
       movb @>07(ix),d                 ; LD D,(IX+$07)     ; y velocity
       movb d,a                        ; LD A,D            ; 
       socb @e,a                       ; OR E              ; is player moving?
       jeq  loc_811d                   ; JR Z,$811D        ; jump if not
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       andi a,>0300                    ; AND $03           ; 1/4 update rate
       jne  loc_811d                   ; JR NZ,$811D       ; jump if not time
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>0300                    ; AND $03           ; keep animation frame bits
       ab   @bytes+>11,a               ; ADD A,$11         ; add base wizard graphic
       movb a,*ix                      ; LD (IX+$00),A     ; 
       movb d,a                        ; LD A,D            ; 
       ; AND A                         ; AND A             ; moving down?
       ; JP P,$8100                    ; JP P,$8100        ; jump if so
       neg a                           ; NEG               ; abs
loc_8100:                              ; >8100
       movb a,@c                       ; LD C,A            ; 
       movb @e,a                       ; LD A,E            ; 
       ; AND A                         ; AND A             ; moving right?
       ; JP P,$8108                    ; JP P,$8108        ; jump if so
       neg a                           ; NEG               ; abs
loc_8108:                              ; >8108
       cb   a,@c                       ; CP C              ; moving more up/down than left/right?
       jhe  loc_8128                   ; JR NC,$8128       ; jump if so
       movb d,a                        ; LD A,D            ; 
       ; AND A                         ; AND A             ; moving up?
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; JP M,$8115                    ; JP M,$8115        ; jump if so
       ab   @bytes+>04,a               ; ADD A,$04         ; offset to down sprites
loc_8115:                              ; >8115
       ab   @bytes+>08,a               ; ADD A,$08         ; offset to right sprites
loc_8117:                              ; >8117
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
       .call @walk_sound               ; CALL $A3C7        ; play walk clicks if due
loc_811d:                              ; >811d
       .call @read_controls            ; CALL $93BE        ; return controls in A (FUDLR order, negative logic)
       andi a,>1000                    ; AND $10           ; fire pressed?
       jne  !                          ; CALL Z,$814B      ; call if so (fire weapon)
       .call @wizard_fire              ;                   
!
       b    @loc_8e78                  ; JP $8E78          ; 
loc_8128:                              ; >8128
       movb @e,a                       ; LD A,E            ; 
       ; AND A                         ; AND A             ; moving left?
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; JP M,$8117                    ; JP M,$8117        ; jump if so
       ab   @bytes+>04,a               ; ADD A,$04         ; offset to down sprites
       jmp  loc_8117                   ; JR $8117          ; 

* fire knight weapon
* 
* Used by the routine at #R$8e26.
knight_fire:                           ; >8134
       movb @weapon,a                  ; LD A,($EA98)      ; 
       ; AND A                         ; AND A             ; weapon active?
       jeq  !                          ; RET NZ            ; return if so (only one allowed)
       .ret                            ;                   
!
       movb @in_doorway,a              ; LD A,($5E2D)      ; 
       ; AND A                         ; AND A             ; standing in doorway?
       jeq  !                          ; RET NZ            ; return if so (can't fire)
       .ret                            ;                   
!
       .call @axe_sound                ; CALL $A41B        ; play axe throw sound
       .call @throw_weapon             ; CALL $817C        ; throw the current character's weapon
       li   hl,weapon                  ; LD HL,$EA98       ; 
       movb @bytes+>40,*hl             ; LD (HL),$40       ; base axe graphic
       jmp  loc_8160                   ; JR $8160          ; 

* fire wizard weapon
* 
* Used by the routine at #R$80d2.
wizard_fire:                           ; >814b
       movb @weapon,a                  ; LD A,($EA98)      ; 
       ; AND A                         ; AND A             ; weapon active?
       jeq  !                          ; RET NZ            ; return if so
       .ret                            ;                   
!
       movb @in_doorway,a              ; LD A,($5E2D)      ; 
       ; AND A                         ; AND A             ; standing in doorway?
       jeq  !                          ; RET NZ            ; return if so (can't fire)
       .ret                            ;                   
!
       .call @fireball_sound           ; CALL $A438        ; play fireball throw sound
       .call @throw_weapon             ; CALL $817C        ; throw the current character's weapon
       li   hl,weapon                  ; LD HL,$EA98       ; 
       movb @bytes+>34,*hl             ; LD (HL),$34       ; base fireball graphic
* This entry point is used by the routines at #R$8134 and #R$8283.
loc_8160:                              ; >8160
       inc  hl                         ; INC HL            ; 
       movb @>01(ix),a                 ; LD A,(IX+$01)     ; player room
       movb a,*hl                      ; LD (HL),A         ; set weapon room
       inc  hl                         ; INC HL            ; 
       inc  hl                         ; INC HL            ; 
       movb @>03(ix),a                 ; LD A,(IX+$03)     ; player xpos
       movb a,*hl                      ; LD (HL),A         ; set weapon xpos
       inc  hl                         ; INC HL            ; 
       movb @>04(ix),a                 ; LD A,(IX+$04)     ; player ypos
       movb a,*hl                      ; LD (HL),A         ; set weapon ypos
       .push ix                        ; PUSH IX           ; 
       li   ix,weapon                  ; LD IX,$EA98       ; 
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .pop ix                         ; POP IX            ; 
       .ret                            ; RET               ; 

* throw the current character's weapon
* 
* Used by the routines at #R$8134, #R$814b and #R$8283.
throw_weapon:                          ; >817c
       li   hl,weapon+>0006            ; LD HL,$EA9E       ; 
       movb @bytes+>30,a               ; LD A,$30          ; 
       movb a,@sound+>0007             ; LD ($EAA7),A      ; 
       sb   a,a                        ; LD A,$00          ; 
       movb a,@weapon+>0002            ; LD ($EA9A),A      ; 
       movb @>06(ix),a                 ; LD A,(IX+$06)     ; 
       socb @>07(ix),a                 ; OR (IX+$07)       ; 
       jeq  loc_81b3                   ; JR Z,$81B3        ; 
       movb @>06(ix),a                 ; LD A,(IX+$06)     ; 
       ; AND A                         ; AND A             ; 
       jeq  loc_81a0                   ; JR Z,$81A0        ; 
       ; JP M,$819E                    ; JP M,$819E        ; 
       movb @bytes+>04,a               ; LD A,$04          ; 
       jmp  loc_81a0                   ; JR $81A0          ; 
loc_819e:                              ; >819e
       movb @bytes+>fc,a               ; LD A,$FC          ; 
loc_81a0:                              ; >81a0
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; 
       ; AND A                         ; AND A             ; 
       jeq  loc_81b1                   ; JR Z,$81B1        ; 
       ; JP M,$81AF                    ; JP M,$81AF        ; 
       movb @bytes+>04,a               ; LD A,$04          ; 
       jmp  loc_81b1                   ; JR $81B1          ; 
loc_81af:                              ; >81af
       movb @bytes+>fc,a               ; LD A,$FC          ; 
loc_81b1:                              ; >81b1
       movb a,*hl                      ; LD (HL),A         ; 
       .ret                            ; RET               ; 
loc_81b3:                              ; >81b3
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       sb   one,a                      ; DEC A             ; 
       andi a,>0c00                    ; AND $0C           ; 
       jeq  loc_81c9                   ; JR Z,$81C9        ; 
       cb   a,@bytes+>04               ; CP $04            ; 
       jeq  loc_81cf                   ; JR Z,$81CF        ; 
       cb   a,@bytes+>08               ; CP $08            ; 
       jne  loc_81d5                   ; JR NZ,$81D5       ; 
       sb   *hl,*hl                    ; LD (HL),$00       ; x velocity
       inc  hl                         ; INC HL            ; 
       movb @bytes+>fc,*hl             ; LD (HL),$FC       ; y velocity (up)
       .ret                            ; RET               ; 
loc_81c9:                              ; >81c9
       movb @bytes+>fc,*hl             ; LD (HL),$FC       ; x velocity (left)
       inc  hl                         ; INC HL            ; 
       sb   *hl,*hl                    ; LD (HL),$00       ; y velocity
       .ret                            ; RET               ; 
loc_81cf:                              ; >81cf
       movb @bytes+>04,*hl             ; LD (HL),$04       ; set x velocity (right)
       inc  hl                         ; INC HL            ; 
       sb   *hl,*hl                    ; LD (HL),$00       ; set y velocity
       .ret                            ; RET               ; 
loc_81d5:                              ; >81d5
       sb   *hl,*hl                    ; LD (HL),$00       ; set x velocity (none)
       inc  hl                         ; INC HL            ; 
       movb @bytes+>04,*hl             ; LD (HL),$04       ; set y velocity (down)
       .ret                            ; RET               ; 

* axe animation handler
h_axe:                                 ; >81db
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       inv  a                          ; CPL               ; cycle backwards
       srl  a,1                        ; RRA               ; TODO: check code. 1/2 animation rate
       andi a,>0700                    ; AND $07           ; 8 animation frames
       ab   @bytes+>40,a               ; ADD A,$40         ; base axe graphic
       movb a,*ix                      ; LD (IX+$00),A     ; 
       movb @bytes+>42,@>05(ix)        ; LD (IX+$05),$42   ; bright red
       jmp  weapon_handler             ; JR $8209          ; 

* fireball animation handler
h_fireball:                            ; >81f0
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ab   one,a                      ; INC A             ; cycle &0eac processing loop
       andi a,>0300                    ; AND $03           ; 4 animation frames
       ab   @bytes+>34,a               ; ADD A,$34         ; base fireball graphic
       movb a,*ix                      ; LD (IX+$00),A     ; 
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       ; RLA                           ; RLA               ; 
       andi a,>0200                    ; AND $02           ; two possible colours
       ab   @bytes+>45,a               ; ADD A,$45         ; bright cyan or white
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
* This entry point is used by the routines at #R$81db and #R$82f1.
weapon_handler:                        ; >8209
       mov  @room_width,de             ; LD DE,($5E1D)     ; 
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; weapon in player room?
       jne  remove_entity              ; JR NZ,$827E       ; jump if not (remove)
       sb   one,@>0f(ix)               ; DEC (IX+$0F)      ; existed too long?
       jeq  loc_826f                   ; JR Z,$826F        ; jump if so (remove)
       movb @>02(ix),r0                ; BIT 0,(IX+$02)    ; 
       andi r0,>0100                   ;                   
       jne  loc_826f                   ; JR NZ,$826F       ; 
       movb @>03(ix),a                 ; LD A,(IX+$03)     ; weapon xpos
       ab   @>06(ix),a                 ; ADD A,(IX+$06)    ; add x velocity
       movb a,@c                       ; LD C,A            ; 
       sb   @bytes+>58,a               ; SUB $58           ; subtract room x centre
       ; JP P,$822E                    ; JP P,$822E        ; jump if in right half
       neg a                           ; NEG               ; abs
loc_822e:                              ; >822e
       cb   a,@e                       ; CP E              ; hit screen edge?
       jhe  loc_825d                   ; JR NC,$825D       ; jump if so (bounce)
loc_8231:                              ; >8231
       movb @>04(ix),a                 ; LD A,(IX+$04)     ; weapon ypos
       ab   @>07(ix),a                 ; ADD A,(IX+$07)    ; add y velocity
       movb a,b                        ; LD B,A            ; 
       sb   @bytes+>68,a               ; SUB $68           ; subtract room y centre
       ; JP P,$823F                    ; JP P,$823F        ; jump if in bottom half
       neg a                           ; NEG               ; abs
loc_823f:                              ; >823f
       cb   a,d                        ; CP D              ; hit screen edge?
       jhe  loc_824b                   ; JR NC,$824B       ; jump if so (bounce)
loc_8242:                              ; >8242
       movb @c,@>03(ix)                ; LD (IX+$03),C     ; set updated xpos
       movb b,@>04(ix)                 ; LD (IX+$04),B     ; set updated ypos
       b    @loc_8e8e                  ; JP $8E8E          ; 
loc_824b:                              ; >824b
       movb @>04(ix),b                 ; LD B,(IX+$04)     ; weapon ypos
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; y velocity
       neg a                           ; NEG               ; invert (bounce)
       movb a,@>07(ix)                 ; LD (IX+$07),A     ; 
       .push bc                        ; PUSH BC           ; 
       .call @bounce_sound             ; CALL $A4B0        ; weapon bounce sound
       .pop bc                         ; POP BC            ; 
       jmp  loc_8242                   ; JR $8242          ; 
loc_825d:                              ; >825d
       movb @>03(ix),@c                ; LD C,(IX+$03)     ; weapon xpos
       movb @>06(ix),a                 ; LD A,(IX+$06)     ; x velocity
       neg a                           ; NEG               ; invert (bounce)
       movb a,@>06(ix)                 ; LD (IX+$06),A     ; 
       .push bc                        ; PUSH BC           ; 
       .call @bounce_sound             ; CALL $A4B0        ; weapon bounce sound
       .pop bc                         ; POP BC            ; 
       jmp  loc_8231                   ; JR $8231          ; 
* This entry point is used by the routine at #R$8787.
loc_826f:                              ; >826f
       .call @undraw_entity            ; CALL $9F56        ; 
       .call @weapon_pop               ; CALL $A445        ; weapon disappearing sound
       movb @room_attr,a               ; LD A,($5E1A)      ; 
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       .call @set_entity_attrs2        ; CALL $A01A        ; set attrs covering previous and new position
* This entry point is used by the routine at #R$85b2.
remove_entity:                         ; >827e
       sb   *ix,*ix                    ; LD (IX+$00),$00   ; clear entity graphic
       .ret                            ; RET               ; 

* fire serf weapon, if not active
* 
* Used by the routine at #R$8dc4.
serf_fire:                             ; >8283
       movb @weapon,a                  ; LD A,($EA98)      ; 
       ; AND A                         ; AND A             ; weapon active?
       jeq  !                          ; RET NZ            ; return if so
       .ret                            ;                   
!
       movb @in_doorway,a              ; LD A,($5E2D)      ; 
       ; AND A                         ; AND A             ; standing in doorway?
       jeq  !                          ; RET NZ            ; return if so
       .ret                            ;                   
!
       .call @sword_sound              ; CALL $A427        ; play sword throw sound
       .call @throw_weapon             ; CALL $817C        ; throw the current character's weapon
       sb   @c,@c                      ; LD C,$00          ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ; AND A                         ; AND A             ; y velocity zero?
       jeq  loc_82b6                   ; JR Z,$82B6        ; jump if so
       ; JP P,$829E                    ; JP P,$829E        ; jump if down
       movb @bytes+>04,@c              ; LD C,$04          ; offset to up graphic
loc_829e:                              ; >829e
       dec  hl                         ; DEC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ; AND A                         ; AND A             ; x velocity zero?
       jeq  loc_82a7                   ; JR Z,$82A7        ; jump if so
       ; JP P,$82B3                    ; JP P,$82B3        ; jump if right
       sb   one,@c                     ; DEC C             ; up/left or down/left
loc_82a7:                              ; >82a7
       movb @c,a                       ; LD A,C            ; 
       andi a,>0700                    ; AND $07           ; 8 possible directions
       ab   @bytes+>38,a               ; ADD A,$38         ; base sword graphic
       li   hl,weapon                  ; LD HL,$EA98       ; 
       movb a,*hl                      ; LD (HL),A         ; 
       b    @loc_8160                  ; JP $8160          ; 
loc_82b3:                              ; >82b3
       ab   one,@c                     ; INC C             ; 
       jmp  loc_82a7                   ; JR $82A7          ; 
loc_82b6:                              ; >82b6
       dec  hl                         ; DEC HL            ; 
       movb *hl,r0                     ; BIT 7,(HL)        ; 
       andi r0,>8000                   ;                   
       jeq  loc_82bf                   ; JR Z,$82BF        ; 
       movb @bytes+>06,@c              ; LD C,$06          ; 
       jmp  loc_82a7                   ; JR $82A7          ; 
loc_82bf:                              ; >82bf
       movb @bytes+>02,@c              ; LD C,$02          ; 
       jmp  loc_82a7                   ; JR $82A7          ; 

* set sword direction to match player direction
* 
* Used by the routine at #R$82f1.
set_sword_dir:                         ; >82c3
       sb   @c,@c                      ; LD C,$00          ; down
       movb *hl,a                      ; LD A,(HL)         ; 
       ; AND A                         ; AND A             ; 
       jeq  loc_82e4                   ; JR Z,$82E4        ; 
       ; JP P,$82CE                    ; JP P,$82CE        ; 
       movb @bytes+>04,@c              ; LD C,$04          ; up
loc_82ce:                              ; >82ce
       dec  hl                         ; DEC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ; AND A                         ; AND A             ; 
       jeq  loc_82d7                   ; JR Z,$82D7        ; 
       ; JP P,$82E1                    ; JP P,$82E1        ; 
       sb   one,@c                     ; DEC C             ; up-left or down-left
loc_82d7:                              ; >82d7
       movb @c,a                       ; LD A,C            ; 
       andi a,>0700                    ; AND $07           ; 8 positions
       ab   @bytes+>38,a               ; ADD A,$38         ; base sword graphic
       li   hl,weapon                  ; LD HL,$EA98       ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .ret                            ; RET               ; 
loc_82e1:                              ; >82e1
       ab   one,@c                     ; INC C             ; up-right or down-right
       jmp  loc_82d7                   ; JR $82D7          ; 
loc_82e4:                              ; >82e4
       dec  hl                         ; DEC HL            ; 
       movb *hl,r0                     ; BIT 7,(HL)        ; 
       andi r0,>8000                   ;                   
       jeq  loc_82ed                   ; JR Z,$82ED        ; 
       movb @bytes+>06,@c              ; LD C,$06          ; facing left
       jmp  loc_82d7                   ; JR $82D7          ; 
loc_82ed:                              ; >82ed
       movb @bytes+>02,@c              ; LD C,$02          ; facing right
       jmp  loc_82d7                   ; JR $82D7          ; 

* sword animation handler
h_sword:                               ; >82f1
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @bytes+>46,@>05(ix)        ; LD (IX+$05),$46   ; bright yellow
       li   hl,weapon+>0007            ; LD HL,$EA9F       ; 
       .call @set_sword_dir            ; CALL $82C3        ; set sword direction to match player direction
       b    @weapon_handler            ; JP $8209          ; 

* small bat handler
h_batlet:                              ; >8301
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; 
       jeq  !                          ; JP NZ,$85F0       ; 
       b    @delay_remove              ;                   
!
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       li   hl,num_creatures           ; LD HL,$5E25       ; number of creatures processed this frame
       ab   one,*hl                    ; INC (HL)          ; 
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; JP Z,$85EA        ; jump if so
       b    @hurt_and_pop              ;                   
!
       .call @chk_weapon_hit           ; CALL $8566        ; check if weapon has hit entity
       sb   one,@e                     ; DEC E             ; hit by weapon?
       jne  !                          ; JP Z,$875F        ; jump if so
       b    @pop_creature              ;                   
!
       sb   @>0f(ix),@>0f(ix)          ; LD (IX+$0F),$00   ; live for 256 frames in different room
       mov  @room_width,de             ; LD DE,($5E1D)     ; 
       movb @>09(ix),a                 ; LD A,(IX+$09)     ; movement counter
       ab   one,a                      ; INC A             ; 
       andi a,>0f00                    ; AND $0F           ; 16-frames between movement changes
       movb a,@>09(ix)                 ; LD (IX+$09),A     ; 
       jeq  !                          ; JP NZ,$833A       ; jump if no change
       b    @loc_833a                  ;                   
!
       movb r,a                        ; LD A,R            ; 
       andi a,>0700                    ; AND $07           ; 3-bit random behaviour
       movb a,@>08(ix)                 ; LD (IX+$08),A     ; 
loc_833a:                              ; >833a
       .call @get_rnd_velocity         ; CALL $83BA        ; random velocity used for batlet
       movb @bytes+>43,@>05(ix)        ; LD (IX+$05),$43   ; bright magenta
       jne  loc_8344                   ; JR NZ,$8344       ; jump if using first (decreasing) entry
       inc  hl                         ; INC HL            ; advance to second (increasing) entry
loc_8344:                              ; >8344
       movb *hl,a                      ; LD A,(HL)         ; get velocity from table
       movb @>08(ix),r0                ; BIT 1,(IX+$08)    ; random direction down?
       andi r0,>0200                   ;                   
       jne  loc_834d                   ; JR NZ,$834D       ; jump if so
       neg a                           ; NEG               ; invert to go up
loc_834d:                              ; >834d
       ab   @>04(ix),a                 ; ADD A,(IX+$04)    ; add velocity to ypos
       movb a,@c                       ; LD C,A            ; 
       sb   @bytes+>68,a               ; SUB $68           ; subtract room y centre
       joc  loc_835a                   ; JR C,$835A        ; TODO: check code. jump if in top screen half
       cb   a,d                        ; CP D              ; 
       jhe  loc_83a2                   ; JR NC,$83A2       ; 
       jmp  loc_835f                   ; JR $835F          ; 
loc_835a:                              ; >835a
       neg a                           ; NEG               ; abs
       cb   a,d                        ; CP D              ; within screen height?
       jhe  loc_83a8                   ; JR NC,$83A8       ; jump if not
loc_835f:                              ; >835f
       movb @c,@>04(ix)                ; LD (IX+$04),C     ; update ypos
loc_8362:                              ; >8362
       .call @get_rnd_velocity         ; CALL $83BA        ; random velocity used for batlet
       jeq  loc_8368                   ; JR Z,$8368        ; jump if using first (decreasing) entry
       inc  hl                         ; INC HL            ; advance to second (increasing) entry
loc_8368:                              ; >8368
       movb *hl,a                      ; LD A,(HL)         ; get velocity from table
       movb @>08(ix),r0                ; BIT 0,(IX+$08)    ; random direction right?
       andi r0,>0100                   ;                   
       jne  loc_8371                   ; JR NZ,$8371       ; jump if so
       neg a                           ; NEG               ; invert to go left
loc_8371:                              ; >8371
       ab   @>03(ix),a                 ; ADD A,(IX+$03)    ; add velocity to xpos
       movb a,@c                       ; LD C,A            ; 
       sb   @bytes+>58,a               ; SUB $58           ; subtract room x centre
       joc  loc_837e                   ; JR C,$837E        ; TODO: check code. jump if in left half
       cb   a,@e                       ; CP E              ; within room width?
       jhe  loc_83b4                   ; JR NC,$83B4       ; jump if not
       jmp  loc_8383                   ; JR $8383          ; 
loc_837e:                              ; >837e
       neg a                           ; NEG               ; abs
       cb   a,@e                       ; CP E              ; within room width?
       jhe  loc_83ae                   ; JR NC,$83AE       ; jump if not
loc_8383:                              ; >8383
       movb @c,@>03(ix)                ; LD (IX+$03),C     ; update xpos
       movb @>09(ix),a                 ; LD A,(IX+$09)     ; 
       srl  a,1                        ; RRA               ; TODO: check code. 
       srl  a,1                        ; RRA               ; TODO: check code. 1/4 animation rate
       andi a,>0100                    ; AND $01           ; 2 animation frames
       movb a,@c                       ; LD C,A            ; 
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>fe00                    ; AND $FE           ; strip animation bit
       ab   @c,a                       ; ADD A,C           ; 
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
       movb @player,a                  ; LD A,($EA90)      ; 
       cb   a,@bytes+>31               ; CP $31            ; player active?
       jl   !                          ; JP NC,$875F       ; jump if not
       b    @pop_creature              ;                   
!
       b    @loc_8e8e                  ; JP $8E8E          ; 
loc_83a2:                              ; >83a2
       szcb @bits+1,@>08(ix)           ; RES 1,(IX+$08)    ; move left away from room bounds
       jmp  loc_8362                   ; JR $8362          ; 
loc_83a8:                              ; >83a8
       socb @bits+1,@>08(ix)           ; SET 1,(IX+$08)    ; move right away from room bounds
       jmp  loc_8362                   ; JR $8362          ; 
loc_83ae:                              ; >83ae
       socb @bits+0,@>08(ix)           ; SET 0,(IX+$08)    ; move down away from room bounds
       jmp  loc_8383                   ; JR $8383          ; 
loc_83b4:                              ; >83b4
       szcb @bits+0,@>08(ix)           ; RES 0,(IX+$08)    ; move up away from room bounds
       jmp  loc_8383                   ; JR $8383          ; 

* random velocity used for batlet
* 
* Used by the routine at #R$8301.
get_rnd_velocity:                      ; >83ba
       movb @>09(ix),@c                ; LD C,(IX+$09)     ; movement counter
       ; SLA C                         ; SLA C             ; * 2 bytes per entry
       sb   b,b                        ; LD B,$00          ; 
       li   hl,rnd_velocities          ; LD HL,$83CA       ; random velocities (0-3)
       a    bc,hl                      ; ADD HL,BC         ; 
       movb @>08(ix),r0                ; BIT 2,(IX+$08)    ; decide on using first or second entry
       andi r0,>0400                   ;                   
       .ret                            ; RET               ; 

* check whether to add new room creatures
* 
* Used by the routine at #R$8e26.
chk_creatures:                         ; >83ea
       movb @last_creat_room,a         ; LD A,($5E26)      ; last room creature created in
       movb a,@c                       ; LD C,A            ; 
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@c                       ; CP C              ; player in different room?
       jne  loc_844f                   ; JR NZ,$844F       ; jump if so
       li   hl,creature_delay          ; LD HL,$5E27       ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ; AND A                         ; AND A             ; time to appear?
       jeq  loc_8458                   ; JR Z,$8458        ; jump if so
       sb   one,*hl                    ; DEC (HL)          ; reduce delay timer
       jeq  !                          ; RET NZ            ; return if not yet time
       .ret                            ;                   
!
add_creature:                          ; >83fd
       equ  $
       li   hl,creature1               ; LD HL,$EE60       ; first creature slot
       li   de,>0010                   ; LD DE,$0010       ; 16 bytes per creature
       movb @bytes+>03,b               ; LD B,$03          ; 3 room creatures
loc_8405:                              ; >8405
       movb *hl,a                      ; LD A,(HL)         ; 
       ; AND A                         ; AND A             ; free slot?
       jeq  loc_840d                   ; JR Z,$840D        ; jump if so
       a    de,hl                      ; ADD HL,DE         ; 
       sb   one,b                      ; DJNZ $8405        ; 
       jne  loc_8405                   ;                   
       .ret                            ; RET               ; no free slots
loc_840d:                              ; >840d
       .ex_de_hl                       ; EX DE,HL          ; 
       li   hl,creature_default        ; LD HL,$8B6A       ; default entity data for creature
       li   bc,>0010                   ; LD BC,$0010       ; 16 bytes of entity data
       .push de                        ; PUSH DE           ; 
       .ldir                           ; LDIR              ; copy template
       .pop hl                         ; POP HL            ; 
       .push hl                        ; PUSH HL           ; 
       inc  hl                         ; INC HL            ; 
       movb @player_room,a             ; LD A,($EA91)      ; 
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       .push hl                        ; PUSH HL           ; 
       li   hl,creatures               ; LD HL,$8B7A       ; creature table
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       andi a,>0f00                    ; AND $0F           ; 16 creatures entries to choose from
       movb a,@e                       ; LD E,A            ; 
       sb   d,d                        ; LD D,$00          ; 
       a    de,hl                      ; ADD HL,DE         ; 
       movb *hl,a                      ; LD A,(HL)         ; new creature graphic
       .pop hl                         ; POP HL            ; 
       movb a,*hl                      ; LD (HL),A         ; set graphic
       mov  @room_width,de             ; LD DE,($5E1D)     ; 
       movb @e,b                       ; LD B,E            ; 
       .call @rnd_coord                ; CALL $8598        ; random coord less than interior size B
       movb a,*hl                      ; LD (HL),A         ; set x
       movb d,b                        ; LD B,D            ; 
       .call @rnd_coord                ; CALL $8598        ; random coord less than interior size B
       movb a,*hl                      ; LD (HL),A         ; set y
       .pop de                         ; POP DE            ; 
       .push ix                        ; PUSH IX           ; 
       li   ix,>0000                   ; LD IX,$0000       ; 
       a    de,ix                      ; ADD IX,DE         ; 
       .call @rnd_movement             ; CALL $86F2        ; set random movement
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .pop ix                         ; POP IX            ; 
       .ret                            ; RET               ; 
loc_844f:                              ; >844f
       movb a,@last_creat_room         ; LD ($5E26),A      ; 
       movb @bytes+>20,a               ; LD A,$20          ; delay 32 frames before next creature
       movb a,@creature_delay          ; LD ($5E27),A      ; 
       .ret                            ; RET               ; 
loc_8458:                              ; >8458
       movb r,a                        ; LD A,R            ; 
       andi a,>0f00                    ; AND $0F           ; 1/16 chance of appearing
       jeq  !                          ; RET NZ            ; return if not
       .ret                            ;                   
!
       jmp  add_creature               ; JR $83FD          ; add creature

* pumpkin and spider handler
h_pumpkin_spider:                      ; >845f
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  !                          ; JP NZ,$85F0       ; jump if not
       b    @delay_remove              ;                   
!
       li   hl,num_creatures           ; LD HL,$5E25       ; number of creatures processed this frame
       ab   one,*hl                    ; INC (HL)          ; 
       .call @chk_weapon_hit           ; CALL $8566        ; check if weapon has hit entity
       sb   one,@e                     ; DEC E             ; hit by weapon?
       jne  !                          ; JP Z,$875F        ; jump if so
       b    @pop_creature              ;                   
!
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; JP Z,$85EA        ; jump if so
       b    @hurt_and_pop              ;                   
!
       mov  @room_width,de             ; LD DE,($5E1D)     ; 
       sb   @>0f(ix),@>0f(ix)          ; LD (IX+$0F),$00   ; live for 256 frames in different room
       movb @bytes+>46,@>05(ix)        ; LD (IX+$05),$46   ; bright yellow
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; 
       andi a,>0f00                    ; AND $0F           ; 4-bit animation counter 0?
       jne  loc_8497                   ; JR NZ,$8497       ; jump if not
       movb r,a                        ; LD A,R            ; 
       andi a,>0300                    ; AND $03           ; 2-bit random x and y direction
       movb a,@>06(ix)                 ; LD (IX+$06),A     ; set directions
loc_8497:                              ; >8497
       movb @>07(ix),r0                ; BIT 0,(IX+$07)    ; unchanged movement this frame?
       andi r0,>0100                   ;                   
       jne  loc_84bf                   ; JR NZ,$84BF       ; jump if so
       movb @>06(ix),r0                ; BIT 0,(IX+$06)    ; move left?
       andi r0,>0100                   ;                   
       jne  !                          ; JP Z,$854A        ; jump if so
       b    @loc_854a                  ;                   
!
       movb @>08(ix),a                 ; LD A,(IX+$08)     ; 
       cb   a,@bytes+>02               ; CP $02            ; at right speed limit?
       jeq  loc_84ae                   ; JR Z,$84AE        ; jump if so
       ab   one,@>08(ix)               ; INC (IX+$08)      ; faster right
loc_84ae:                              ; >84ae
       movb @>06(ix),r0                ; BIT 1,(IX+$06)    ; move up?
       andi r0,>0200                   ;                   
       jne  !                          ; JP Z,$8558        ; jump if so
       b    @loc_8558                  ;                   
!
       movb @>09(ix),a                 ; LD A,(IX+$09)     ; 
       cb   a,@bytes+>02               ; CP $02            ; at down speed limit?
       jeq  loc_84bf                   ; JR Z,$84BF        ; jump if so
       ab   one,@>09(ix)               ; INC (IX+$09)      ; faster down
loc_84bf:                              ; >84bf
       ab   one,@>07(ix)               ; INC (IX+$07)      ; increase animation counter
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; 
       andi a,>0100                    ; AND $01           ; 2 animation frames
       ; XOR (IX+$00)                  ; XOR (IX+$00)      ; combine, for 1/2 animation rate
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
* This entry point is used by the routines at #R$862e, #R$8672, #R$871a,
* #R$87a6, #R$8988, #R$8a2f, #R$8a80 and #R$8aff.
monster_move:                          ; >84cd
       movb @>03(ix),a                 ; LD A,(IX+$03)     ; xpos
       ab   @>08(ix),a                 ; ADD A,(IX+$08)    ; add x velocity
       movb a,@c                       ; LD C,A            ; save new xpos
       sb   @bytes+>58,a               ; SUB $58           ; subtract room centre x
       joc  loc_84e8                   ; JR C,$84E8        ; TODO: check code. jump if negative (left half)
       cb   a,@e                       ; CP E              ; within room width?
       jl   loc_84f8                   ; JR C,$84F8        ; jump if so
       szcb @bits+0,@>06(ix)           ; RES 0,(IX+$06)    ; set direction to left
       movb @b254,@>08(ix)             ; LD (IX+$08),$FE   ; bounce left away from wall
       movb @>03(ix),@c                ; LD C,(IX+$03)     ; current xpos
       jmp  loc_84f8                   ; JR $84F8          ; 
loc_84e8:                              ; >84e8
       neg a                           ; NEG               ; abs
       cb   a,@e                       ; CP E              ; within room width?
       jl   loc_84f8                   ; JR C,$84F8        ; jump if so
       socb @bits+0,@>06(ix)           ; SET 0,(IX+$06)    ; set direction to right
       movb @>03(ix),@c                ; LD C,(IX+$03)     ; current xpos
       movb @bytes+>02,@>08(ix)        ; LD (IX+$08),$02   ; bounce right away from wall
loc_84f8:                              ; >84f8
       movb @>04(ix),a                 ; LD A,(IX+$04)     ; ypos
       ab   @>09(ix),a                 ; ADD A,(IX+$09)    ; add y velocity
       movb a,b                        ; LD B,A            ; save new ypos
       sb   @bytes+>68,a               ; SUB $68           ; subtract room centre y
       joc  loc_8513                   ; JR C,$8513        ; TODO: check code. jump if negative (top half)
       cb   a,d                        ; CP D              ; within screen height?
       jl   loc_8523                   ; JR C,$8523        ; jump if so
       szcb @bits+1,@>06(ix)           ; RES 1,(IX+$06)    ; set direction to up
       movb @b254,@>09(ix)             ; LD (IX+$09),$FE   ; bounce up away from wall
       movb @>04(ix),b                 ; LD B,(IX+$04)     ; current ypos
       jmp  loc_8523                   ; JR $8523          ; 
loc_8513:                              ; >8513
       neg a                           ; NEG               ; abs
       cb   a,d                        ; CP D              ; within screen height?
       jl   loc_8523                   ; JR C,$8523        ; jump if so
       socb @bits+1,@>06(ix)           ; SET 1,(IX+$06)    ; set direction to down
       movb @>04(ix),b                 ; LD B,(IX+$04)     ; 
       movb @bytes+>02,@>09(ix)        ; LD (IX+$09),$02   ; bounce down away from wall
loc_8523:                              ; >8523
       movb @c,@>03(ix)                ; LD (IX+$03),C     ; set new xpos
       movb b,@>04(ix)                 ; LD (IX+$04),B     ; set new ypos
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  !                          ; RET NZ            ; return if not
       .ret                            ;                   
!
       movb *ix,a                      ; LD A,(IX+$00)     ; entity graphic
       andi a,>fc00                    ; AND $FC           ; strip 2 animation bits
       cb   a,@bytes+>9c               ; CP $9C            ; is it hunchback?
       jeq  keep_special               ; JR Z,$8547        ; jump if so
       andi a,>f000                    ; AND $F0           ; 
       cb   a,@bytes+>70               ; CP $70            ; is it mummy/frankenstein/devil/dracula?
       jeq  keep_special               ; JR Z,$8547        ; jump if so
       movb @player,a                  ; LD A,($EA90)      ; 
       cb   a,@bytes+>31               ; CP $31            ; is player active?
       jl   !                          ; JP NC,$875F       ; jump if not (pop non-special creature types)
       b    @pop_creature              ;                   
!
keep_special:                          ; >8547
       equ  $
       b    @loc_8e8e                  ; JP $8E8E          ; 
loc_854a:                              ; >854a
       movb @>08(ix),a                 ; LD A,(IX+$08)     ; 
       cb   a,@b254                    ; CP $FE            ; at left speed limit?
       jne  !                          ; JP Z,$84AE        ; jump if so
       b    @loc_84ae                  ;                   
!
       sb   one,@>08(ix)               ; DEC (IX+$08)      ; faster left
       b    @loc_84ae                  ; JP $84AE          ; 
loc_8558:                              ; >8558
       movb @>09(ix),a                 ; LD A,(IX+$09)     ; 
       cb   a,@b254                    ; CP $FE            ; at up speed limit?
       jne  !                          ; JP Z,$84BF        ; jump if so
       b    @loc_84bf                  ;                   
!
       sb   one,@>09(ix)               ; DEC (IX+$09)      ; faster up
       b    @loc_84bf                  ; JP $84BF          ; 

* check if weapon has hit entity
* 
* Used by the routines at #R$8301, #R$845f, #R$862e, #R$8672, #R$871a, #R$87a6,
* #R$8a2f and #R$8a80.
chk_weapon_hit:                        ; >8566
       movb @weapon+>0001,a            ; LD A,($EA99)      ; weapon room
       sb   @e,@e                      ; LD E,$00          ; no weapon hit detected
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in entity room?
       jeq  !                          ; RET NZ            ; return if not
       .ret                            ;                   
!
       movb @weapon,a                  ; LD A,($EA98)      ; 
       ; AND A                         ; AND A             ; is weapon active?
       jne  !                          ; RET Z             ; return if not
       .ret                            ;                   
!
       movb @weapon+>0003,a            ; LD A,($EA9B)      ; weapon xpos
       sb   @>03(ix),a                 ; SUB (IX+$03)      ; subtract entity x
       ; JP P,$857F                    ; JP P,$857F        ; jump if postive
       neg a                           ; NEG               ; abs
loc_857f:                              ; >857f
       cb   a,@bytes+>0c               ; CP $0C            ; within weapon x size?
       jl   !                          ; RET NC            ; return if not
       .ret                            ;                   
!
       movb @weapon+>0004,a            ; LD A,($EA9C)      ; weapon ypos
       sb   @>04(ix),a                 ; SUB (IX+$04)      ; subtract entity y
       ; JP P,$858D                    ; JP P,$858D        ; jump if positive
       neg a                           ; NEG               ; abs
loc_858d:                              ; >858d
       cb   a,@bytes+>0c               ; CP $0C            ; within weapon y size?
       jl   !                          ; RET NC            ; return if not
       .ret                            ;                   
!
       movb one,a                      ; LD A,$01          ; 1 frame before removal
       movb a,@weapon+>0002            ; LD ($EA9A),A      ; set weapon frames left
       movb one,@e                     ; LD E,$01          ; weapon hit detected
       .ret                            ; RET               ; 

* random coord less than interior size B
* 
* Used by the routine at #R$83ea.
rnd_coord:                             ; >8598
       movb b,a                        ; LD A,B            ; 
       sb   @bytes+>08,a               ; SUB $08           ; 
       movb a,b                        ; LD B,A            ; 
       movb r,a                        ; LD A,R            ; 
       inc  hl                         ; INC HL            ; 
loc_859f:                              ; >859f
       cb   a,b                        ; CP B              ; 
       jl   loc_85a5                   ; JR C,$85A5        ; 
       sb   b,a                        ; SUB B             ; 
       jmp  loc_859f                   ; JR $859F          ; 
loc_85a5:                              ; >85a5
       movb a,@c                       ; LD C,A            ; 
       movb r,a                        ; LD A,R            ; 
       movb a,r0                       ; BIT 1,A           ; 
       andi r0,>0200                   ;                   
       movb @bytes+>60,a               ; LD A,$60          ; 
       jeq  loc_85b0                   ; JR Z,$85B0        ; 
       ab   @c,a                       ; ADD A,C           ; 
       .ret                            ; RET               ; 
loc_85b0:                              ; >85b0
       sb   @c,a                       ; SUB C             ; 
       .ret                            ; RET               ; 

* check if enemy is touching player (returns E=1)
* 
* Used by the routines at #R$8301, #R$845f, #R$862e, #R$8672, #R$871a, #R$87a6,
* #R$8862, #R$8906, #R$8988, #R$89ed, #R$8a2f, #R$8a80 and #R$8aff.
enemy_touching:                        ; >85b2
       movb @player_room,a             ; LD A,($EA91)      ; 
       sb   @e,@e                      ; LD E,$00          ; is not touching player
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  !                          ; RET NZ            ; return if not
       .ret                            ;                   
!
       movb @player,a                  ; LD A,($EA90)      ; 
       ; AND A                         ; AND A             ; does player exist?
       jne  !                          ; RET Z             ; return if not
       .ret                            ;                   
!
       cb   a,@bytes+>31               ; CP $31            ; active player?
       jl   !                          ; RET NC            ; return if not
       .ret                            ;                   
!
       movb @player_x,a                ; LD A,($EA93)      ; 
       sb   @>03(ix),a                 ; SUB (IX+$03)      ; right of player?
       ; JP P,$85CE                    ; JP P,$85CE        ; jump if not
       neg a                           ; NEG               ; abs
loc_85ce:                              ; >85ce
       cb   a,@bytes+>0c               ; CP $0C            ; too far from player?
       jl   !                          ; RET NC            ; return if so
       .ret                            ;                   
!
       movb @player_y,a                ; LD A,($EA94)      ; 
       sb   @>04(ix),a                 ; SUB (IX+$04)      ; below player?
       ; JP P,$85DC                    ; JP P,$85DC        ; jump if not
       neg a                           ; NEG               ; abs
loc_85dc:                              ; >85dc
       cb   a,@bytes+>0c               ; CP $0C            ; too far from player?
       jl   !                          ; RET NC            ; return if so
       .ret                            ;                   
!
       movb one,a                      ; LD A,$01          ; 
       movb a,@player_contact          ; LD ($EA92),A      ; 
       .call @touching_sound           ; CALL $A3E5        ; play monster touched sound
       movb one,@e                     ; LD E,$01          ; is touching player
       .ret                            ; RET               ; 
* This entry point is used by the routines at #R$8301, #R$845f, #R$862e,
* #R$8672, #R$871a, #R$87a6, #R$8a2f and #R$8a80.
hurt_and_pop:                          ; >85ea
       .call @damage_32                ; CALL $8ED7        ; reduce health by 32
       b    @pop_creature              ; JP $875F          ; 
* This entry point is used by the routines at #R$8301, #R$845f, #R$85f7,
* #R$862e, #R$8672, #R$871a, #R$8787, #R$87a6, #R$8a2f and #R$8a80.
delay_remove:                          ; >85f0
       sb   one,@>0f(ix)               ; DEC (IX+$0F)      ; auto-remove timer for monsters
       jeq  !                          ; RET NZ            ; return if still alive
       .ret                            ;                   
!
       b    @remove_entity             ; JP $827E          ; 

* monster appearance sparkle handler
h_sparkles:                            ; >85f7
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  !                          ; JP NZ,$85F0       ; jump if not
       b    @delay_remove              ;                   
!
       li   hl,num_creatures           ; LD HL,$5E25       ; number of creatures processed this frame
       ab   one,*hl                    ; INC (HL)          ; 
       sb   one,@>0e(ix)               ; DEC (IX+$0E)      ; sparkled long enough?
       jeq  to_creature                ; JR Z,$8625        ; jump if so
       movb @>0e(ix),a                 ; LD A,(IX+$0E)     ; 
       andi a,>0300                    ; AND $03           ; 4 animation frames
       ab   @bytes+>58,a               ; ADD A,$58         ; base sparkle graphic
       movb a,*ix                      ; LD (IX+$00),A     ; 
       movb @bytes+>80,@>0f(ix)        ; LD (IX+$0F),$80   ; live for 128 frames outside player room
       movb @player,a                  ; LD A,($EA90)      ; 
       cb   a,@bytes+>31               ; CP $31            ; player active?
       jl   !                          ; JP NC,$875F       ; jump if not
       b    @pop_creature              ;                   
!
       b    @loc_8e8e                  ; JP $8E8E          ; 
to_creature:                           ; >8625
       movb @>02(ix),a                 ; LD A,(IX+$02)     ; creature graphic
       movb a,*ix                      ; LD (IX+$00),A     ; convert sparkle to creature
       b    @loc_8e8e                  ; JP $8E8E          ; 

* small ghost handler
h_ghostlet:                            ; >862e
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  !                          ; JP NZ,$85F0       ; jump if not
       b    @delay_remove              ;                   
!
       li   hl,num_creatures           ; LD HL,$5E25       ; number of creatures processed this frame
       ab   one,*hl                    ; INC (HL)          ; 
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; JP Z,$85EA        ; jump if so
       b    @hurt_and_pop              ;                   
!
       .call @chk_weapon_hit           ; CALL $8566        ; check if weapon has hit entity
       sb   one,@e                     ; DEC E             ; hit by weapon?
       jne  !                          ; JP Z,$875F        ; jump if so
       b    @pop_creature              ;                   
!
       movb @bytes+>45,@>05(ix)        ; LD (IX+$05),$45   ; bright cyan
       ab   one,@>07(ix)               ; INC (IX+$07)      ; increment movement counter
       jne  !                          ; CALL Z,$86F2      ; change movement every 256 frames
       .call @rnd_movement             ;                   
!
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; 
       srl  a,1                        ; RRA               ; TODO: check code. 
       srl  a,1                        ; RRA               ; TODO: check code. 1/4 animation rate
       andi a,>0100                    ; AND $01           ; 2 animation frames
       movb a,@c                       ; LD C,A            ; 
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>fe00                    ; AND $FE           ; strip animation bit
       ab   @c,a                       ; ADD A,C           ; 
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
       mov  @room_width,de             ; LD DE,($5E1D)     ; 
       sb   @>0f(ix),@>0f(ix)          ; LD (IX+$0F),$00   ; live for 256 frames in different room
       b    @monster_move              ; JP $84CD          ; common monster movement

* spikey ghost handler
h_spikey_ghost:                        ; >8672
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  !                          ; JP NZ,$85F0       ; jump if not
       b    @delay_remove              ;                   
!
       li   hl,num_creatures           ; LD HL,$5E25       ; number of creatures processed this frame
       ab   one,*hl                    ; INC (HL)          ; 
       sb   @>0f(ix),@>0f(ix)          ; LD (IX+$0F),$00   ; live for 256 frames in different room
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; JP Z,$85EA        ; jump if so
       b    @hurt_and_pop              ;                   
!
       .call @chk_weapon_hit           ; CALL $8566        ; check if weapon has hit entity
       sb   one,@e                     ; DEC E             ; hit by weapon?
       jne  !                          ; JP Z,$875F        ; jump if so
       b    @pop_creature              ;                   
!
       movb @>0a(ix),a                 ; LD A,(IX+$0A)     ; vertical velocity
       srl  a,1                        ; RRA               ; TODO: check code. 1/2 animation rate
       andi a,>0100                    ; AND $01           ; 2 animation frames
       movb a,@c                       ; LD C,A            ; 
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>fe00                    ; AND $FE           ; strip animation bit
       ab   @c,a                       ; ADD A,C           ; 
       movb a,*ix                      ; LD (IX+$00),A     ; set graphic
       mov  @room_width,de             ; LD DE,($5E1D)     ; 
       ab   one,@>0a(ix)               ; INC (IX+$0A)      ; bounce speed
       movb @>0a(ix),a                 ; LD A,(IX+$0A)     ; 
       cb   a,@bytes+>07               ; CP $07            ; max bounce speed?
       jne  loc_86b9                   ; JR NZ,$86B9       ; jump if not
       .call @rnd_movement             ; CALL $86F2        ; random vertical offset
       movb @bytes+>f9,@>0a(ix)        ; LD (IX+$0A),$F9   ; bounce back up
loc_86b9:                              ; >86b9
       sra  a,1                        ; SRA A             ; 1/2 bounce speed
       ab   @>04(ix),a                 ; ADD A,(IX+$04)    ; add to y position
       movb a,@c                       ; LD C,A            ; save result
       sb   @bytes+>68,a               ; SUB $68           ; subtract vertical centre
       ; JP P,$86E1                    ; JP P,$86E1        ; jump if positive (lower screen half)
       neg a                           ; NEG               ; abs
       cb   a,d                        ; CP D              ; out of screen top?
       jl   loc_86db                   ; JR C,$86DB        ; jump if not
       movb @bytes+>02,@>09(ix)        ; LD (IX+$09),$02   ; kick down away from wall
       socb @bits+1,@>06(ix)           ; SET 1,(IX+$06)    ; 
       movb @>0a(ix),r0                ; BIT 7,(IX+$0A)    ; 
       andi r0,>8000                   ;                   
       jeq  loc_86db                   ; JR Z,$86DB        ; 
       sb   @>0a(ix),@>0a(ix)          ; LD (IX+$0A),$00   ; 
loc_86db:                              ; >86db
       movb @c,@>04(ix)                ; LD (IX+$04),C     ; set y position
       b    @monster_move              ; JP $84CD          ; common monster movement
loc_86e1:                              ; >86e1
       cb   a,d                        ; CP D              ; out of screen bottom?
       jl   loc_86db                   ; JR C,$86DB        ; jump if not
       szcb @bits+1,@>06(ix)           ; RES 1,(IX+$06)    ; 
       movb @b254,@>09(ix)             ; LD (IX+$09),$FE   ; kick up away from wall
       movb @bytes+>f9,@>0a(ix)        ; LD (IX+$0A),$F9   ; bounce back up at -7 pixels/frame
       jmp  loc_86db                   ; JR $86DB          ; 

* set random movement
* 
* Used by the routines at #R$83ea, #R$862e, #R$8672, #R$871a, #R$8a2f and
* #R$8a80.
rnd_movement:                          ; >86f2
       movb r,a                        ; LD A,R            ; 
       movb a,r0                       ; BIT 0,A           ; use x speed of 1?
       andi r0,>0100                   ;                   
       jeq  rnd_move_y1                ; JR Z,$870E        ; jump if so
       andi a,>0400                    ; AND $04           ; 
       sb   @bytes+>02,a               ; SUB $02           ; y velocity is +/- 2
loc_86fc:                              ; >86fc
       movb a,@>09(ix)                 ; LD (IX+$09),A     ; set y something?
       movb r,a                        ; LD A,R            ; 
       srl  a,1                        ; RRA               ; TODO: check code. 
       movb a,r0                       ; BIT 0,A           ; use y speed of 1?
       andi r0,>0100                   ;                   
       jeq  rnd_move_x1                ; JR Z,$8714        ; jump if so
       andi a,>0400                    ; AND $04           ; 
       sb   @bytes+>02,a               ; SUB $02           ; x velocity is +/- 2
loc_870a:                              ; >870a
       movb a,@>08(ix)                 ; LD (IX+$08),A     ; set x something?
       .ret                            ; RET               ; 
rnd_move_y1:                           ; >870e
       andi a,>0200                    ; AND $02           ; 
       sb   one,a                      ; SUB $01           ; y velocity is +/- 1
       jmp  loc_86fc                   ; JR $86FC          ; 
rnd_move_x1:                           ; >8714
       andi a,>0200                    ; AND $02           ; 
       sb   one,a                      ; SUB $01           ; x velocity is +/- 1
       jmp  loc_870a                   ; JR $870A          ; 

* Routine at 871a
h_blob:                                ; >871a
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; 
       jeq  !                          ; JP NZ,$85F0       ; 
       b    @delay_remove              ;                   
!
       li   hl,num_creatures           ; LD HL,$5E25       ; number of creatures processed this frame
       ab   one,*hl                    ; INC (HL)          ; 
       sb   @>0f(ix),@>0f(ix)          ; LD (IX+$0F),$00   ; live for 256 frames in different room
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; JP Z,$85EA        ; jump if so
       b    @hurt_and_pop              ;                   
!
       .call @chk_weapon_hit           ; CALL $8566        ; check if weapon has hit entity
       sb   one,@e                     ; DEC E             ; hit by weapon?
       jne  !                          ; JP Z,$875F        ; jump if so
       b    @pop_creature              ;                   
!
       mov  @room_width,de             ; LD DE,($5E1D)     ; 
       sb   one,@>0d(ix)               ; DEC (IX+$0D)      ; 
       jne  loc_874c                   ; JR NZ,$874C       ; 
       movb @bytes+>11,@>0d(ix)        ; LD (IX+$0D),$11   ; 
       .call @rnd_movement             ; CALL $86F2        ; set random movement
loc_874c:                              ; >874c
       movb @>0d(ix),a                 ; LD A,(IX+$0D)     ; 
       srl  a,1                        ; RRA               ; TODO: check code. 
       andi a,>0100                    ; AND $01           ; 2 animation frames
       movb a,@c                       ; LD C,A            ; 
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>fe00                    ; AND $FE           ; clear b0
       ab   @c,a                       ; ADD A,C           ; 
       movb a,*ix                      ; LD (IX+$00),A     ; 
       b    @monster_move              ; JP $84CD          ; common monster movement
* This entry point is used by the routines at #R$8301, #R$845f, #R$85b2,
* #R$85f7, #R$862e, #R$8672, #R$87a6, #R$8988, #R$8a2f and #R$8a80.
pop_creature:                          ; >875f
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; save creature attr
       .push af                        ; PUSH AF           ; 
       movb @room_attr,a               ; LD A,($5E1A)      ; 
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; undraw to room attr
       .call @undraw_entity            ; CALL $9F56        ; 
       .call @set_entity_attrs2        ; CALL $A01A        ; set attrs covering previous and new position
       .pop af                         ; POP AF            ; 
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       movb @bytes+>6c,*ix             ; LD (IX+$00),$6C   ; base pop graphic
       movb @bytes+>10,@>0e(ix)        ; LD (IX+$0E),$10   ; 16 animation frames (4 loops of 4)
       li   bc,>0155                   ; LD BC,$0155       ; 
       .call @add_score_bc_bcd         ; CALL $A19C        ; add 155 score
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       b    @set_entity_attrs2         ; JP $A01A          ; set attrs covering previous and new position

* creature death pop animation handler
h_pop:                                 ; >8787
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  !                          ; JP NZ,$85F0       ; jump if not
       b    @delay_remove              ;                   
!
       sb   one,@>0e(ix)               ; DEC (IX+$0E)      ; final animation frame?
       jne  !                          ; JP Z,$826F        ; jump if so
       b    @loc_826f                  ;                   
!
       movb @>0e(ix),a                 ; LD A,(IX+$0E)     ; 
       andi a,>0300                    ; AND $03           ; 4 animation frames
       ab   @bytes+>6c,a               ; ADD A,$6C         ; base pop graphic
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
       b    @loc_8e8e                  ; JP $8E8E          ; 

* Ghoul handler
h_ghoul:                               ; >87a6
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  !                          ; JP NZ,$85F0       ; jump if not
       b    @delay_remove              ;                   
!
       li   hl,num_creatures           ; LD HL,$5E25       ; number of creatures processed this frame
       ab   one,*hl                    ; INC (HL)          ; 
       .call @chk_weapon_hit           ; CALL $8566        ; check if weapon has hit entity
       sb   one,@e                     ; DEC E             ; hit by weapon?
       jne  !                          ; JP Z,$875F        ; jump if so
       b    @pop_creature              ;                   
!
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; JP Z,$85EA        ; jump if so
       b    @hurt_and_pop              ;                   
!
       mov  @room_width,de             ; LD DE,($5E1D)     ; 
       sb   @>0f(ix),@>0f(ix)          ; LD (IX+$0F),$00   ; live for 256 frames in different room
       movb @bytes+>46,@>05(ix)        ; LD (IX+$05),$46   ; bright yellow
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; 
       andi a,>0700                    ; AND $07           ; 3-bit animation counter 0?
       jne  loc_87de                   ; JR NZ,$87DE       ; jump if not
       movb r,a                        ; LD A,R            ; 
       andi a,>0300                    ; AND $03           ; 2-bit random direction
       movb a,@>06(ix)                 ; LD (IX+$06),A     ; set directions
loc_87de:                              ; >87de
       movb @>07(ix),r0                ; BIT 0,(IX+$07)    ; alternating behaviour &0eac frame
       andi r0,>0100                   ;                   
       jne  loc_8804                   ; JR NZ,$8804       ; jump if odd frame (continue movement)
       movb @>06(ix),r0                ; BIT 0,(IX+$06)    ; moving left?
       andi r0,>0100                   ;                   
       jeq  loc_8815                   ; JR Z,$8815        ; jump if so
       movb @>08(ix),a                 ; LD A,(IX+$08)     ; 
       cb   a,@bytes+>02               ; CP $02            ; at right speed limit?
       jeq  loc_87f4                   ; JR Z,$87F4        ; jump if so
       ab   one,@>08(ix)               ; INC (IX+$08)      ; faster right
loc_87f4:                              ; >87f4
       movb @>06(ix),r0                ; BIT 1,(IX+$06)    ; moving up?
       andi r0,>0200                   ;                   
       jeq  loc_8821                   ; JR Z,$8821        ; jump if so
       movb @>09(ix),a                 ; LD A,(IX+$09)     ; 
       cb   a,@bytes+>02               ; CP $02            ; at down speed limit?
       jeq  loc_8804                   ; JR Z,$8804        ; jump if so
       ab   one,@>09(ix)               ; INC (IX+$09)      ; faster down
loc_8804:                              ; >8804
       ab   one,@>07(ix)               ; INC (IX+$07)      ; increase animation counter
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; 
       andi a,>0100                    ; AND $01           ; 2 animation frames
       ; XOR (IX+$00)                  ; XOR (IX+$00)      ; gives 1/2 animation rate
       movb a,*ix                      ; LD (IX+$00),A     ; 
       b    @monster_move              ; JP $84CD          ; common monster movement
loc_8815:                              ; >8815
       movb @>08(ix),a                 ; LD A,(IX+$08)     ; 
       cb   a,@b254                    ; CP $FE            ; at left speed limit?
       jeq  loc_87f4                   ; JR Z,$87F4        ; jump if so
       sb   one,@>08(ix)               ; DEC (IX+$08)      ; faster left
       jmp  loc_87f4                   ; JR $87F4          ; 
loc_8821:                              ; >8821
       movb @>09(ix),a                 ; LD A,(IX+$09)     ; 
       cb   a,@b254                    ; CP $FE            ; at up speed limit?
       jeq  loc_8804                   ; JR Z,$8804        ; jump if so
       sb   one,@>09(ix)               ; DEC (IX+$09)      ; faster up
       jmp  loc_8804                   ; JR $8804          ; 

* set movement towards coords in DE
* 
* Used by the routines at #R$8862, #R$8906, #R$8988, #R$89ed and #R$8aff.
attract_de:                            ; >882d
       sb   @c,@c                      ; LD C,$00          ; 
       movb d,a                        ; LD A,D            ; 
       cb   a,@>04(ix)                 ; CP (IX+$04)       ; ypos match?
       jeq  loc_8848                   ; JR Z,$8848        ; jump if so
       jnc  loc_8850                   ; JR NC,$8850       ; TODO: check code. jump if greater (move down)
       movb @b255,@>09(ix)             ; LD (IX+$09),$FF   ; move up
loc_883b:                              ; >883b
       movb @e,a                       ; LD A,E            ; 
       cb   a,@>03(ix)                 ; CP (IX+$03)       ; same xpos?
       jeq  loc_8856                   ; JR Z,$8856        ; jump if so
       jnc  loc_885d                   ; JR NC,$885D       ; TODO: check code. jump if greater (move right)
       movb @b255,@>08(ix)             ; LD (IX+$08),$FF   ; move left
       .ret                            ; RET               ; 
loc_8848:                              ; >8848
       sb   @>09(ix),@>09(ix)          ; LD (IX+$09),$00   ; no y movement
       socb @bits+0,@c                 ; SET 0,C           ; flag same ypos
       jmp  loc_883b                   ; JR $883B          ; 
loc_8850:                              ; >8850
       movb one,@>09(ix)               ; LD (IX+$09),$01   ; move down
       jmp  loc_883b                   ; JR $883B          ; 
loc_8856:                              ; >8856
       sb   @>08(ix),@>08(ix)          ; LD (IX+$08),$00   ; no x movement
       socb @bits+1,@c                 ; SET 1,C           ; flag same xpos
       .ret                            ; RET               ; 
loc_885d:                              ; >885d
       movb one,@>08(ix)               ; LD (IX+$08),$01   ; move right
       .ret                            ; RET               ; 

* Mummy handler
h_mummy:                               ; >8862
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; CALL Z,$8A1E      ; call if so (reduce health by 8)
       .call @damage_8                 ;                   
!
       li   hl,leaf                    ; LD HL,$EAE0       ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ; AND A                         ; AND A             ; does leaf exist?
       jeq  loc_8881                   ; JR Z,$8881        ; jump if not
       inc  hl                         ; INC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; is leaf in mummy room?
       jne  loc_8881                   ; JR NZ,$8881       ; jump if not
       inc  hl                         ; INC HL            ; 
       inc  hl                         ; INC HL            ; 
       movb *hl,@e                     ; LD E,(HL)         ; leaf x
       inc  hl                         ; INC HL            ; 
       movb *hl,d                      ; LD D,(HL)         ; leaf y
       jmp  loc_88d7                   ; JR $88D7          ; leaf attracts mummy
loc_8881:                              ; >8881
       movb @>06(ix),r0                ; BIT 7,(IX+$06)    ; is mummy angry with player?
       andi r0,>8000                   ;                   
       jne  loc_88fd                   ; JR NZ,$88FD       ; jump if so
       li   hl,red_key                 ; LD HL,$EAC8       ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ; AND A                         ; AND A             ; does red key exist?
       jeq  loc_88f9                   ; JR Z,$88F9        ; jump if not
       inc  hl                         ; INC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; is red key in mummy room?
       jne  loc_88f9                   ; JR NZ,$88F9       ; jump if not
       movb @>0c(ix),d                 ; LD D,(IX+$0C)     ; current target x
       movb @>0b(ix),@e                ; LD E,(IX+$0B)     ; current target y
       .call @attract_de               ; CALL $882D        ; set movement towards coords in DE
       movb @c,a                       ; LD A,C            ; 
       cb   a,@bytes+>03               ; CP $03            ; reached target x+y position?
       jeq  loc_88b5                   ; JR Z,$88B5        ; jump if so
loc_88a3:                              ; >88a3
       movb @counter_low,a             ; LD A,($5E12)      ; 
       srl  a,1                        ; RRA               ; TODO: check code. 
       srl  a,1                        ; RRA               ; TODO: check code. 
       andi a,>0300                    ; AND $03           ; 4 animation frames
       ab   @bytes+>70,a               ; ADD A,$70         ; base mummy graphic
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
       li   de,>3838                   ; LD DE,$3838       ; allowed to roam 56x56 from room centre
       b    @chk_move_away             ; JP $89BB          ; 
loc_88b5:                              ; >88b5
       movb @>06(ix),r0                ; BIT 6,(IX+$06)    ; moving up/left?
       andi r0,>4000                   ;                   
       jeq  loc_88c9                   ; JR Z,$88C9        ; jump if so
       movb @bytes+>8c,@>0b(ix)        ; LD (IX+$0B),$8C   ; new target x
       movb @bytes+>68,@>0c(ix)        ; LD (IX+$0C),$68   ; new target y (below red key)
       szcb @bits+6,@>06(ix)           ; RES 6,(IX+$06)    ; move up-left
       jmp  loc_88a3                   ; JR $88A3          ; 
loc_88c9:                              ; >88c9
       movb @bytes+>68,@>0b(ix)        ; LD (IX+$0B),$68   ; new target x (left of red key)
       movb @bytes+>38,@>0c(ix)        ; LD (IX+$0C),$38   ; new target y
       socb @bits+6,@>06(ix)           ; SET 6,(IX+$06)    ; move down-right
       jmp  loc_88a3                   ; JR $88A3          ; 
loc_88d7:                              ; >88d7
       .call @attract_de               ; CALL $882D        ; set movement towards coords in DE
       movb @c,a                       ; LD A,C            ; 
       cb   a,@bytes+>03               ; CP $03            ; has mummy reached leaf position?
       jne  loc_88a3                   ; JR NZ,$88A3       ; jump if not
       .push ix                        ; PUSH IX           ; 
       li   ix,leaf                    ; LD IX,$EAE0       ; 
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; if leaf in player room?
       jne  loc_88f0                   ; JR NZ,$88F0       ; 
       .call @draw_entity              ; CALL $9F4A        ; undraw leaf
loc_88f0:                              ; >88f0
       .pop ix                         ; POP IX            ; 
       movb @bytes+>6b,a               ; LD A,$6B          ; room 6B
       movb a,@leaf+>0001              ; LD ($EAE1),A      ; move leaf to room 6B
       jmp  loc_88b5                   ; JR $88B5          ; 
loc_88f9:                              ; >88f9
       socb @bits+7,@>06(ix)           ; SET 7,(IX+$06)    ; mummy now angry with player
loc_88fd:                              ; >88fd
       mov  @player_x,de               ; LD DE,($EA93)     ; 
       .call @attract_de               ; CALL $882D        ; set movement towards coords in DE
       jmp  loc_88a3                   ; JR $88A3          ; 

* Dracula handler
h_dracula:                             ; >8906
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; is touching player?
       jne  !                          ; CALL Z,$8A1E      ; call if so (reduce health by 8)
       .call @damage_8                 ;                   
!
       li   de,zx_screen+>068a         ; LD DE,$468A       ; yellow crucafix object
       .call @check_carrying           ; CALL $9273        ; is player carrying crucafix?
       jne  loc_8931                   ; JR NZ,$8931       ; jump if not
       mov  @player_x,de               ; LD DE,($EA93)     ; current player position
       .call @attract_de               ; CALL $882D        ; set movement towards coords in DE
       movb @>08(ix),a                 ; LD A,(IX+$08)     ; x velocity
       neg a                           ; NEG               ; invert (run away!)
       movb a,@>08(ix)                 ; LD (IX+$08),A     ; 
       movb @>09(ix),a                 ; LD A,(IX+$09)     ; y velocity
       neg a                           ; NEG               ; invert (run away!)
       movb a,@>09(ix)                 ; LD (IX+$09),A     ; 
       jmp  loc_8940                   ; JR $8940          ; 
loc_8931:                              ; >8931
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; is Dracula in the player room?
       jne  loc_8952                   ; JR NZ,$8952       ; jump if not
       mov  @player_x,de               ; LD DE,($EA93)     ; 
       .call @attract_de               ; CALL $882D        ; set movement towards coords in DE
loc_8940:                              ; >8940
       movb @counter_low,a             ; LD A,($5E12)      ; 
       srl  a,1                        ; RRA               ; TODO: check code. 
       srl  a,1                        ; RRA               ; TODO: check code. 1/4 animation rate
       andi a,>0300                    ; AND $03           ; 4 animation frames
       ab   @bytes+>7c,a               ; ADD A,$7C         ; base Dracula graphic
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
       li   de,>3434                   ; LD DE,$3434       ; allowed to roam 52x52 from room centre
       b    @chk_move_away             ; JP $89BB          ; 
loc_8952:                              ; >8952
       movb @bytes+>68,@>0b(ix)        ; LD (IX+$0B),$68   ; new target x (centre)
       movb @bytes+>68,@>0c(ix)        ; LD (IX+$0C),$68   ; new target y (centre)
       .call @attract_de               ; CALL $882D        ; set movement towards coords in DE
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       ; AND A                         ; AND A             ; frame 0 of 50?
       jeq  !                          ; JP NZ,$8940       ; jump if not
       b    @loc_8940                  ;                   
!
       movb r,a                        ; LD A,R            ; 
       andi a,>7f00                    ; AND $7F           ; random 7-bit room number
       movb a,@c                       ; LD C,A            ; 
       .call @get_room_style           ; CALL $897D        ; get style of room in A, returns style (0-B)
       cb   a,@bytes+>03               ; CP $03            ; non-square room?
       jl   !                          ; JP NC,$8940       ; jump if so (ignore)
       b    @loc_8940                  ;                   
!
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@c                       ; CP C              ; current player room?
       jne  !                          ; JP Z,$8940        ; jump if so (ignore)
       b    @loc_8940                  ;                   
!
       movb @c,@>01(ix)                ; LD (IX+$01),C     ; move Dracula to new room
       jmp  loc_8940                   ; JR $8940          ; 

* get style of room in A, returns style (0-B)
* 
* Used by the routine at #R$8906.
get_room_style:                        ; >897d
       movb a,@l                       ; LD L,A            ; 
       sb   h,h                        ; LD H,$00          ; 
       li   de,room_attrs              ; LD DE,$A854       ; room attr colour and style (0-B)
       a    hl,hl                      ; ADD HL,HL         ; 
       a    de,hl                      ; ADD HL,DE         ; 
       inc  hl                         ; INC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; first byte is room style (0-C)
       .ret                            ; RET               ; 

* Frankenstein handler
h_frankenstein:                        ; >8988
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  loc_89a5                   ; JR NZ,$89A5       ; jump if not
       li   de,zx_screen+>058b         ; LD DE,$458B       ; cyan spanner
       .call @check_carrying           ; CALL $9273        ; carrying spanner?
       jne  loc_89a2                   ; JR NZ,$89A2       ; jump if not
       li   bc,>1000                   ; LD BC,$1000       ; 
       .call @add_score_bc_bcd         ; CALL $A19C        ; add 1000 points
       b    @pop_creature              ; JP $875F          ; 
loc_89a2:                              ; >89a2
       .call @damage_8                 ; CALL $8A1E        ; reduce health by 8
loc_89a5:                              ; >89a5
       mov  @player_x,de               ; LD DE,($EA93)     ; 
       .call @attract_de               ; CALL $882D        ; set movement towards coords in DE
       movb @counter_low,a             ; LD A,($5E12)      ; 
       srl  a,1                        ; RRA               ; TODO: check code. 
       srl  a,1                        ; RRA               ; TODO: check code. 
       andi a,>0300                    ; AND $03           ; 
       ab   @bytes+>74,a               ; ADD A,$74         ; base frankenstein graphic
       movb a,*ix                      ; LD (IX+$00),A     ; 
       li   de,>3434                   ; LD DE,$3434       ; 52x52 centre prison area if player is dead
* This entry point is used by the routines at #R$8862, #R$8906 and #R$89ed.
chk_move_away:                         ; >89bb
       movb @player,a                  ; LD A,($EA90)      ; 
       cb   a,@bytes+>31               ; CP $31            ; is player active?
       jhe  !                          ; JP C,$84CD        ; jump if so
       b    @monster_move              ;                   
!
       mov  @player_x,de               ; LD DE,($EA93)     ; 
       .call @attract_de               ; CALL $882D        ; set movement towards coords in DE
       movb @>08(ix),a                 ; LD A,(IX+$08)     ; x movement
       neg a                           ; NEG               ; away from player
       movb a,@>08(ix)                 ; LD (IX+$08),A     ; 
       movb a,@c                       ; LD C,A            ; 
       movb @>09(ix),a                 ; LD A,(IX+$09)     ; y movement
       neg a                           ; NEG               ; away from player
       movb a,@>09(ix)                 ; LD (IX+$09),A     ; 
       li   de,>3434                   ; LD DE,$3434       ; allowed to roam 52x52 from room centre
       ; AND C                         ; AND C             ; should be OR C maybe? (either movement)
       jeq  !                          ; JP NZ,$84CD       ; common monster movement
       b    @monster_move              ;                   
!
       movb one,@>08(ix)               ; LD (IX+$08),$01   ; move right
       movb one,@>09(ix)               ; LD (IX+$09),$01   ; move up
       b    @monster_move              ; JP $84CD          ; common monster movement

* Devil handler
h_devil:                               ; >89ed
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; CALL Z,$8A1E      ; call if so (reduce health by 8)
       .call @damage_8                 ;                   
!
       mov  @player_x,de               ; LD DE,($EA93)     ; 
       .call @attract_de               ; CALL $882D        ; set movement towards coords in DE
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>fc00                    ; AND $FC           ; strip animation frame bits
       movb a,@c                       ; LD C,A            ; 
       movb @counter_low,a             ; LD A,($5E12)      ; 
       srl  a,1                        ; RRA               ; TODO: check code. 
       srl  a,1                        ; RRA               ; TODO: check code. 1/4 animation rate
       andi a,>0300                    ; AND $03           ; 4 animation frames
       ab   @c,a                       ; ADD A,C           ; 
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
       li   de,>3434                   ; LD DE,$3434       ; allowed to roam 52x52 from room centre
       b    @chk_move_away             ; JP $89BB          ; 

* reduce health by 16
* 
* Used by the routine at #R$8aff.
damage_16:                             ; >8a15
       movb @player_energy,a           ; LD A,($5E28)      ; 
       sb   @bytes+>10,a               ; SUB $10           ; 
       joc  player_dead_pop            ; JR C,$8A2B        ; TODO: check code. 
       jmp  loc_8a25                   ; JR $8A25          ; 

* reduce health by 8
* 
* Used by the routines at #R$8862, #R$8906, #R$8988 and #R$89ed.
damage_8:                              ; >8a1e
       movb @player_energy,a           ; LD A,($5E28)      ; 
       sb   @bytes+>08,a               ; SUB $08           ; 
       joc  player_dead_pop            ; JR C,$8A2B        ; TODO: check code. 
* This entry point is used by the routine at #R$8a15.
loc_8a25:                              ; >8a25
       movb a,@player_energy           ; LD ($5E28),A      ; 
       b    @draw_chicken_branch       ; JP $8B8A          ; draw chicken energy bar
* This entry point is used by the routine at #R$8a15.
player_dead_pop:                       ; >8a2b
       .pop hl                         ; POP HL            ; don't return to entity handler
       b    @player_dead               ; JP $8EA0          ; 

* witch handler
h_witch:                               ; >8a2f
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  !                          ; JP NZ,$85F0       ; jump if not
       b    @delay_remove              ;                   
!
       li   hl,num_creatures           ; LD HL,$5E25       ; number of creatures processed this frame
       ab   one,*hl                    ; INC (HL)          ; 
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; JP Z,$85EA        ; jump if so
       b    @hurt_and_pop              ;                   
!
       .call @chk_weapon_hit           ; CALL $8566        ; check if weapon has hit entity
       sb   one,@e                     ; DEC E             ; hit by weapon?
       jne  !                          ; JP Z,$875F        ; jump if so
       b    @pop_creature              ;                   
!
       sb   one,@>0d(ix)               ; DEC (IX+$0D)      ; movement timer expired?
       jne  loc_8a5d                   ; JR NZ,$8A5D       ; jump if not
       .call @rnd_movement             ; CALL $86F2        ; set random movement
;       sra  @>09(ix),1                 ; SRA (IX+$09)      ; TODO halve y velocity (to 1 or 0)
       movb @bytes+>10,@>0d(ix)        ; LD (IX+$0D),$10   ; 16 frames before changing movement
loc_8a5d:                              ; >8a5d
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>fc00                    ; AND $FC           ; strip animation bits
       movb @>08(ix),r0                ; BIT 7,(IX+$08)    ; moving left?
       andi r0,>8000                   ;                   
       jne  loc_8a6a                   ; JR NZ,$8A6A       ; jump if so
       ab   @bytes+>02,a               ; ADD A,$02         ; offset to right-facing graphics
loc_8a6a:                              ; >8a6a
       movb a,@c                       ; LD C,A            ; 
       movb @>0d(ix),a                 ; LD A,(IX+$0D)     ; 
       srl  a,1                        ; RRA               ; TODO: check code. 1/2 animation rate
       andi a,>0100                    ; AND $01           ; 2 animation frames
       ab   @c,a                       ; ADD A,C           ; 
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
       mov  @room_width,de             ; LD DE,($5E1D)     ; 
       movb @bytes+>43,@>05(ix)        ; LD (IX+$05),$43   ; bright magenta
       b    @monster_move              ; JP $84CD          ; common monster movement

* monk and large bat handler
h_monk_bat:                            ; >8a80
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  !                          ; JP NZ,$85F0       ; jump if not
       b    @delay_remove              ;                   
!
       li   hl,num_creatures           ; LD HL,$5E25       ; number of creatures processed this frame
       ab   one,*hl                    ; INC (HL)          ; 
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; JP Z,$85EA        ; jump if so
       b    @hurt_and_pop              ;                   
!
       .call @chk_weapon_hit           ; CALL $8566        ; check if weapon has hit entity
       sb   one,@e                     ; DEC E             ; hit by weapon?
       jne  !                          ; JP Z,$875F        ; jump if so (pop)
       b    @pop_creature              ;                   
!
       sb   one,@>0d(ix)               ; DEC (IX+$0D)      ; movement timer expired?
       jne  loc_8ab8                   ; JR NZ,$8AB8       ; jump if not
       .call @rnd_movement             ; CALL $86F2        ; set random movement
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       andi a,>0400                    ; AND $04           ; 
       sb   @bytes+>02,a               ; SUB $02           ; +/- 2
       movb a,@>08(ix)                 ; LD (IX+$08),A     ; set x velocity
;       sra  @>09(ix),1                 ; SRA (IX+$09)      ; TODO halve y velocity (to 1 or 0)
       movb @bytes+>20,@>0d(ix)        ; LD (IX+$0D),$20   ; 32 frames before changing behaviour
loc_8ab8:                              ; >8ab8
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>fc00                    ; AND $FC           ; strip animation bits
       movb @>08(ix),r0                ; BIT 7,(IX+$08)    ; moving left?
       andi r0,>8000                   ;                   
       jne  loc_8ac5                   ; JR NZ,$8AC5       ; jump if so
       ab   @bytes+>02,a               ; ADD A,$02         ; offset to right-facing graphics
loc_8ac5:                              ; >8ac5
       movb a,@c                       ; LD C,A            ; 
       movb @>0d(ix),a                 ; LD A,(IX+$0D)     ; 
       srl  a,1                        ; RRA               ; TODO: check code. 1/2 animation rate
       andi a,>0100                    ; AND $01           ; 2 animation frames
       ab   @c,a                       ; ADD A,C           ; 
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
       mov  @room_width,de             ; LD DE,($5E1D)     ; 
       movb @bytes+>42,@>05(ix)        ; LD (IX+$05),$42   ; bright red
       b    @monster_move              ; JP $84CD          ; common monster movement

* check for hunchback items on the floor (return C=1)
* 
* Used by the routine at #R$8aff.
chk_hunch_loot:                        ; >8adb
       li   hl,wine                    ; LD HL,$EB18       ; first of 8 items hunchback reacts to
       li   de,>0008                   ; LD DE,$0008       ; 8 bytes per entry
       movb @bytes+>08,b               ; LD B,$08          ; 8 entries
loc_8ae3:                              ; >8ae3
       .push hl                        ; PUSH HL           ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ; AND A                         ; AND A             ; unused slot?
       jeq  loc_8af8                   ; JR Z,$8AF8        ; jump if so
       inc  hl                         ; INC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; room number
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in hunchback room?
       jne  loc_8af8                   ; JR NZ,$8AF8       ; jump if not
       .pop de                         ; POP DE            ; 
       inc  hl                         ; INC HL            ; 
       inc  hl                         ; INC HL            ; 
       movb *hl,@e                     ; LD E,(HL)         ; item x
       inc  hl                         ; INC HL            ; 
       movb *hl,d                      ; LD D,(HL)         ; item y
       movb one,@c                     ; LD C,$01          ; entry found
       .ret                            ; RET               ; 
loc_8af8:                              ; >8af8
       .pop hl                         ; POP HL            ; 
       a    de,hl                      ; ADD HL,DE         ; advance to next entry
       sb   one,b                      ; DJNZ $8AE3        ; 
       jne  loc_8ae3                   ;                   
       sb   @c,@c                      ; LD C,$00          ; not found
       .ret                            ; RET               ; 

* Hunchback handler
h_hunchback:                           ; >8aff
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       .call @enemy_touching           ; CALL $85B2        ; check if enemy is touching player (returns E=1)
       sb   one,@e                     ; DEC E             ; touching player?
       jne  !                          ; CALL Z,$8A15      ; call if so (reduce health by 16)
       .call @damage_16                ;                   
!
       sb   a,a                        ; XOR A             ; 
       movb a,@>09(ix)                 ; LD (IX+$09),A     ; no x movement
       movb a,@>08(ix)                 ; LD (IX+$08),A     ; no y movement
       .call @chk_hunch_loot           ; CALL $8ADB        ; check for hunchback items on the floor (return C=1)
       sb   one,@c                     ; DEC C             ; hunchback item in room?
       jeq  !                          ; JP NZ,$8B59       ; jump if not
       b    @loc_8b59                  ;                   
!
       .call @attract_de               ; CALL $882D        ; hunchback attracted to item
       movb @c,a                       ; LD A,C            ; 
       cb   a,@bytes+>03               ; CP $03            ; hunchback reached item?
       jne  loc_8b45                   ; JR NZ,$8B45       ; jump if not
       .call @chk_hunch_loot           ; CALL $8ADB        ; check for hunchback items on the floor (return C=1)
       li   de,>0004                   ; LD DE,$0004       ; HL is 4 bytes into entity
       ; AND A                         ; AND A             ; 
       s    de,hl                      ; SBC HL,DE         ; start of item entity
       .push ix                        ; PUSH IX           ; 
       li   ix,>0000                   ; LD IX,$0000       ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       a    de,ix                      ; ADD IX,DE         ; item entity now in IX
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jne  loc_8b3c                   ; JR NZ,$8B3C       ; jump if not
       .call @draw_entity              ; CALL $9F4A        ; undraw item
loc_8b3c:                              ; >8b3c
       sb   *ix,*ix                    ; LD (IX+$00),$00   ; remove item
       .pop ix                         ; POP IX            ; 
       b    @loc_8b59                  ; JP $8B59          ; 
loc_8b45:                              ; >8b45
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>fc00                    ; AND $FC           ; strip animation bits
       movb a,@c                       ; LD C,A            ; 
       movb @counter_low,a             ; LD A,($5E12)      ; 
       srl  a,1                        ; RRA               ; TODO: check code. 
       srl  a,1                        ; RRA               ; TODO: check code. 1/4 animation rate
       andi a,>0300                    ; AND $03           ; 4 animation frames
       ab   @c,a                       ; ADD A,C           ; 
       movb a,*ix                      ; LD (IX+$00),A     ; set animation graphic
       li   de,>3c3c                   ; LD DE,$3C3C       ; 
loc_8b59:                              ; >8b59
       movb @player,a                  ; LD A,($EA90)      ; 
       cb   a,@bytes+>31               ; CP $31            ; player active?
       jhe  !                          ; JP C,$84CD        ; jump if so
       b    @monster_move              ;                   
!
       li   de,>3a58                   ; LD DE,$3A58       ; coords below top door
       .call @attract_de               ; CALL $882D        ; move towards door
       b    @monster_move              ; JP $84CD          ; common monster movement

* draw chicken energy bar
* 
* Used by the routines at #R$8a1e, #R$8c63, #R$8e26, #R$8ed7, #R$9443 and
* #R$988b.
draw_chicken:                          ; >8b8a
       .proc
draw_chicken_branch:
       seto @background_graphics_rom_bank
       movb @player_energy,a           ; LD A,($5E28)      ;
;      srl  a,1                        ; SRL A             ;
;      srl  a,1                        ; SRL A             ;
;      srl  a,1                        ; SRL A             ;
       srl  a,3
       movb a,@c                       ; LD C,A            ; desired height
       movb @chicken_level,a           ; LD A,($5E29)      ; last drawn chicken level
;      srl  a,1                        ; SRL A             ;
;      srl  a,1                        ; SRL A             ;
;      srl  a,1                        ; SRL A             ;
       srl  a,3
       movb a,b                        ; LD B,A            ; Last drawn height
       cb   a,@c                       ; CP C              ; if desired height = last drawn then return
       jeq  draw_chicken_end           ; RET Z             ;
       movb @g_chicken_full+1,@e       ; LD A,($C543)      ; e = full chicken height
;      movb a,@e                       ; LD E,A            ;
       movb @g_chicken_empty+1,d       ; LD A,($C48D)      ; d = empty chicken height
;      movb a,d                        ; LD D,A            ;
       .push ix                        ; PUSH IX           ; 
       li   ix,chicken_entity          ; LD IX,$8C2D       ; Entity to draw
       .push de                        ; PUSH DE           ; Save original heights
       cb   a,@c                                           ; Compare last drawn to desired height again
       jle   loc_8c12                   ; JR C,$8C12       ; Jump if last drawn height was lower or equal
       movb @g_chicken_empty,@e        ; LD A,($C48C)      ; e = width
;      movb a,@e                       ; LD E,A            ;
       sb   d,d                        ; LD D,$00          ; de = width
       movb @c,a                       ; LD A,C            ; a = desired height
;      .push bc                        ; PUSH BC           ;
       .call @mpy_de_a                ; CALL $9AAD        ; HL = DE * A = width * desired height
;      .pop bc                         ; POP BC            ;
       mov  @chicken_empty_addr,de     ; LD DE,($A626)     ; de = address of empty chicken graphics
       .push de                        ; PUSH DE           ; Save address
       a    de,hl                      ; ADD HL,DE         ; Add offset
       mov  hl,@chicken_empty_addr_ram ; LD ($A626),HL     ; Update the address in the graphics table.
       movb @chicken_empty_size,@e     ; LD E,(HL)         ; Get the graphics data at the offset
;      inc  hl                         ; INC HL            ;
       movb @chicken_empty_size+1,d    ; LD D,(HL)         ; Get the graphics data at the offset
       movb @g_chicken_empty+1,a       ; LD A,($C48D)      ; Original height
       sb   @c,a                       ; SUB C             ; Minus desired height
       jeq  loc_8bfc                   ; JR Z,$8BFC        ; Return if they are the same
       .push de                        ; PUSH DE           ; Save the graphics data at the offset
       movb a,@chicken_empty_size+1    ; LD (HL),A         ; Update graphics height at offset with modified value.
       movb @g_chicken_empty,a         ; LD A,($C48C)      ; Original width
;      dec  hl                         ; DEC HL            ; Point hl to width
       movb a,@chicken_empty_size      ; LD (HL),A         ; Update graphics width at offset with modified value.
;      .push hl                        ; PUSH HL           ; Save the address at the offset
;      movb @bytes+>14,a               ; LD A,$14          ; empty chicken graphic
       movb @bytes+>14,*ix             ; LD (IX+$00),A     ; Set entity to draw
       li   hl,>77C8                   ; LD HL,$77C8       ; chicken draw coords
;      movb h,a                        ; LD A,H            ;
       sb   @c,h                       ; SUB C             ; Subtract desired height from y
;      movb a,h                        ; LD H,A            ;
;      mov  hl,@chicken_entity+>0003   ; LD ($8C30),HL     ; coords
       movb @l,@chicken_entity+entity_x                    ; Write x
       movb h,@chicken_entity+entity_y                     ; Write y
       .call @draw_bgrnd_graphics             ; CALL $9213        ;
;      mov  @chicken_entity+>0003,hl   ; LD HL,($8C30)     ;
       movb @chicken_entity+entity_x,@l                    ; Get coordinates back
       movb @chicken_entity+entity_y,h
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       movb @g_chicken_empty,a         ; LD A,($C48C)      ; a = Width
       movb a,b                        ; LD B,A            ; b = width
loc_8bf2:                              ; >8bf2
       sb   *hl,*hl                    ; LD (HL),$00       ; Clear screen byte
       ab   one,@l                     ; INC L             ; Next byte
       sb   one,b                      ; DJNZ $8BF2        ; Clear width bytes
       jne  loc_8bf2                   ;                   
;      .pop hl                         ; POP HL            ; Restore address at the offset
       .pop de                         ; POP DE            ; Restore data at offset
       movb @e,@chicken_empty_size     ; LD (HL),E         ; Restore first byte
;      inc  hl                         ; INC HL            ;
       movb d,@chicken_empty_size+1    ; LD (HL),D         ; Restore second byte
loc_8bfc:                              ; >8bfc
       .pop hl                         ; POP HL            ; Restore original address of empty chicken
       mov  hl,@chicken_empty_addr_ram ; LD ($A626),HL     ; Write it to the graphics table.
loc_8c00:                              ; >8c00
       .pop de                         ; POP DE            ; Restore original heights
;      movb @e,a                       ; LD A,E            ;
       movb @e,@chicken_full_size+1   ; LD ($C543),A       ; Restore height.
;      movb d,a                        ; LD A,D            ;
       movb d,@chicken_empty_size+1   ; LD ($C48D),A       ; Restore height.
       .pop ix                         ; POP IX            ; 
       movb @player_energy,@chicken_level ; LD A,($5E28)   ; Save new level
;      movb a,@chicken_level           ; LD ($5E29),A      ; last drawn chicken height
draw_chicken_end:
       .endproc                        ; RET               ;
loc_8c12:                              ; >8c12
       movb @c,a                       ; LD A,C            ; Desired height
       movb a,@chicken_full_size+1     ; LD ($C543),A      ; Set height of graphics. TODO: In ROM
       movb @bytes+>13,*ix             ; LD A,$13          ; full chicken graphic
;      movb a,*ix                      ; LD (IX+$00),A     ;
       li   hl,>77c8                   ; LD HL,$77C8       ; Coordinates
;      mov  hl,@chicken_entity+>0003   ; LD ($8C30),HL     ; coords
       movb @l,@chicken_entity+entity_x
       movb h,@chicken_entity+entity_y
       .call @draw_bgrnd_graphics             ; CALL $9213        ;
       movb @bytes+>06,b               ; LD B,$06          ; Width
loc_8c26:                              ; >8c26
       sb   *hl,*hl                    ; LD (HL),$00       ; Clear screen byte
       ab   one,@l                     ; INC L             ; Next byte
       sb   one,b                      ; DJNZ $8C26        ; Clear width bytes
       jne  loc_8c26                   ;                   
       jmp  loc_8c00                   ; JR $8C00          ; Jump to return
*// draw_chicken

* Data block at 8c2d
chicken_entity:                        ; >8c2d
       byte >13,>00,>00,>c8,>77,>00,>00,>00
chicken_empty_addr_ram:
       data chicken_empty_addr
chicken_empty_size:
       byte >06,>1E
chicken_full_addr_ram:
       data chicken_full_addr
chicken_full_size:
       byte >06,>1E

* Routine at 8c35
* 
* Used by the routine at #R$8e26.
game_over:                             ; >8c35
       .call @clear_play_area          ; CALL $8093        ; clear screen and attrs of play area
       li   hl,charset_base                   ; LD HL,$BE4C       ;
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   hl,>3040                   ; LD HL,$3040       ; game over at 64,48
       li   de,gameover_msg            ; LD DE,$8C59       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       .call @game_stats               ; CALL $9641        ; show game statistics
* This entry point is used by the routine at #R$96c9.
loc_8c4a:                              ; >8c4a
       movb @bytes+>14,b               ; LD B,$14          ; 20 loops of 65536 delay
       li   hl,>0000                   ; LD HL,$0000       ; 
gameover_delay:                        ; >8c4f
       dec  hl                         ; DEC HL            ; 
       movb h,a                        ; LD A,H            ; 
       socb @l,a                       ; OR L              ; 
       jne  gameover_delay             ; JR NZ,$8C4F       ; 
       sb   one,b                      ; DJNZ $8C4F        ; 
       jne  gameover_delay             ;                   
       b    @main_menu                 ; JP $7C29          ; 

* food item handler
h_food:                                ; >8c63
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       .call @check_touching           ; CALL $90FB        ; touching food?
       joc  loc_8c6e                   ; JR C,$8C6E        ; TODO: check code. jump if so
       b    @draw_16x16                ; JP $92E0          ; draw 16x16 entity
loc_8c6e:                              ; >8c6e
       .call @undraw_entity            ; CALL $9F56        ; 
       sb   *ix,*ix                    ; LD (IX+$00),$00   ; remove food item
       .call @eat_sound                ; CALL $A485        ; 
       movb @bytes+>40,@c              ; LD C,$40          ; food adds 64 health
       movb @player_energy,a           ; LD A,($5E28)      ; 
       ab   @c,a                       ; ADD A,C           ; add food value
       joc  loc_8c84                   ; JR C,$8C84        ; TODO: check code. 
       cb   a,@bytes+>f0               ; CP $F0            ; exceeded maximum?
       jl   loc_8c86                   ; JR C,$8C86        ; jump if not
loc_8c84:                              ; >8c84
       movb @bytes+>f0,a               ; LD A,$F0          ; cap energy at maximum
loc_8c86:                              ; >8c86
       movb a,@player_energy           ; LD ($5E28),A      ; 
       b    @draw_chicken_branch ; JP $8B8A          ; draw chicken energy bar

* flash score on game start
* 
* Used by the routine at #R$8cb7.
flash_score:                           ; >8c8c
       sb   one,a                      ; DEC A             ; timer expired?
       movb a,@flash_timer             ; LD ($5E3C),A      ; score flash timer
       jeq  loc_8ca7                   ; JR Z,$8CA7        ; jump if so (stop flash)
       andi a,>0f00                    ; AND $0F           ; 16th frame?
       jne  !                          ; CALL Z,$A3E0      ; call if so (beep)
       .call @start_beep               ;                   
!
       li   hl,zx_screen+>10c8         ; LD HL,$50C8       ; 
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       movb @bytes+>06,b               ; LD B,$06          ; 
loc_8c9f:                              ; >8c9f
       movb *hl,a                      ; LD A,(HL)         ; 
       socb @bytes+>80,a               ; OR $80            ; enable flash attribute
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       sb   one,b                      ; DJNZ $8C9F        ; 
       jne  loc_8c9f                   ;                   
       .ret                            ; RET               ; 
loc_8ca7:                              ; >8ca7
       li   hl,zx_screen+>10c8         ; LD HL,$50C8       ; 
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       movb @bytes+>06,b               ; LD B,$06          ; 
loc_8caf:                              ; >8caf
       movb *hl,a                      ; LD A,(HL)         ; 
       andi a,>7f00                    ; AND $7F           ; disable flash attribute
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       sb   one,b                      ; DJNZ $8CAF        ; 
       jne  loc_8caf                   ;                   
       .ret                            ; RET               ; 

* player appear handler for game start
h_player_appear:                       ; >8cb7
       movb @flash_timer,a             ; LD A,($5E3C)      ; score flash timer
       ; AND A                         ; AND A             ; score flash timer active?
       jne  flash_score                ; JR NZ,$8C8C       ; jump if so
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       andi a,>0300                    ; AND $03           ; 0 in range 0-3?
       jeq  !                          ; JP NZ,$8D12       ; jump if not
       b    @loc_8d12                  ;                   
!
       ab   one,@>06(ix)               ; INC (IX+$06)      ; increase drawn height
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; player spawn sprite
       .call @get_sprite_addr          ; CALL $9E89        ; return address of sprite A in DE
       movb *de,a                      ; LD A,(DE)         ; normal player sprite height
       cb   a,@>06(ix)                 ; CP (IX+$06)       ; reached full reveal height?
       jeq  loc_8d32                   ; JR Z,$8D32        ; jump if so
* This entry point is used by the routine at #R$8d45.
loc_8cd4:                              ; >8cd4
       .push de                        ; PUSH DE           ; 
       .push hl                        ; PUSH HL           ; 
       movb h,b                        ; LD B,H            ; 
       movb @l,@c                      ; LD C,L            ; 
       movb @>04(ix),a                 ; LD A,(IX+$04)     ; 
       movb a,@>02(ix)                 ; LD (IX+$02),A     ; 
       sb   @>06(ix),a                 ; SUB (IX+$06)      ; 
       movb a,@>04(ix)                 ; LD (IX+$04),A     ; 
       movb @>06(ix),@l                ; LD L,(IX+$06)     ; 
       sb   h,h                        ; LD H,$00          ; 
       a    hl,hl                      ; ADD HL,HL         ; 
       a    de,hl                      ; ADD HL,DE         ; 
       movb h,a                        ; LD A,H            ; 
       movb a,*bc                      ; LD (BC),A         ; 
       dec  bc                         ; DEC BC            ; 
       movb @l,a                       ; LD A,L            ; 
       movb a,*bc                      ; LD (BC),A         ; 
       .push hl                        ; PUSH HL           ; 
       movb *hl,@c                     ; LD C,(HL)         ; 
       movb *ix,b                      ; LD B,(IX+$00)     ; 
       .push bc                        ; PUSH BC           ; 
       movb one,*hl                    ; LD (HL),$01       ; 
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; player spawn sprite
       movb a,*ix                      ; LD (IX+$00),A     ; set player graphic
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .pop bc                         ; POP BC            ; 
       .pop hl                         ; POP HL            ; 
       movb @c,*hl                     ; LD (HL),C         ; 
       movb b,*ix                      ; LD (IX+$00),B     ; 
       movb @>02(ix),a                 ; LD A,(IX+$02)     ; 
       movb a,@>04(ix)                 ; LD (IX+$04),A     ; 
       .pop hl                         ; POP HL            ; 
       .pop de                         ; POP DE            ; 
       movb d,*hl                      ; LD (HL),D         ; 
       dec  hl                         ; DEC HL            ; 
       movb @e,*hl                     ; LD (HL),E         ; 
* This entry point is used by the routine at #R$8d45.
loc_8d12:                              ; >8d12
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; 
       .push af                        ; PUSH AF           ; 
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 1/4 colour change rate
       andi a,>0700                    ; AND $07           ; ink 0-7
       jne  loc_8d20                   ; JR NZ,$8D20       ; jump if not black
       ab   one,a                      ; INC A             ; convert black to blue
loc_8d20:                              ; >8d20
       socb @bytes+>40,a               ; OR $40            ; add bright bit
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; set player attr
       movb @>06(ix),a                 ; LD A,(IX+$06)     ; 
       .call @set_appear_w_h           ; CALL $92E2        ; set spawn appearance width/height
       .pop af                         ; POP AF            ; 
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       b    @appear_sound              ; JP $A45F          ; player appearance sound
loc_8d32:                              ; >8d32
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; player spawn sprite
       movb a,*ix                      ; LD (IX+$00),A     ; set player graphic
       sb   @>06(ix),@>06(ix)          ; LD (IX+$06),$00   ; no x movement
       sb   @>07(ix),@>07(ix)          ; LD (IX+$07),$00   ; no y movement
       sb   @>02(ix),@>02(ix)          ; LD (IX+$02),$00   ; no auto-steps
       .ret                            ; RET               ; 

* player death animation handler
h_death:                               ; >8d45
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       andi a,>0300                    ; AND $03           ; 3/4 animation rate for death
       jeq  loc_8d12                   ; JR Z,$8D12        ; jump if colouring this frame instead
       sb   one,@>06(ix)               ; DEC (IX+$06)      ; reduce player visible height
       ; JP M,$8D5B                    ; JP M,$8D5B        ; jump if after zero
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; player spawn sprite
       .call @get_sprite_addr          ; CALL $9E89        ; return address of sprite A in DE
       b    @loc_8cd4                  ; JP $8CD4          ; 
loc_8d5b:                              ; >8d5b
       .call @place_tombstone          ; CALL $95A9        ; place a tombstone at the player position
       b    @prepare_player            ; JP $9443          ; prepare player to spawn

* copy initial game state to working state area
* 
* Used by the routine at #R$7d9a.
reset_game_state:                      ; >8d61
       seto @sprite_graphics_rom_bank
       li   hl,player_init             ; LD HL,$600D       ; initial game state
       li   de,player                  ; LD DE,$EA90       ; working game state
       li   bc,player_init_size        ; LD BC,$1570       ; 0x10000-player, rather than real init data size!
       .ldir                           ; LDIR              ;
       seto @room_data_rom_bank
       li   hl,door_07_00
       li   de,linked_items
       li   bc,linked_items_size
       .ldir
       .ret                            ; RET               ;

* reduce auto-walk counter
* 
* Used by the routine at #R$8d77.
auto_walk_step:                        ; >8d6d
       movb @>02(ix),a                 ; LD A,(IX+$02)     ; 
       andi a,>0f00                    ; AND $0F           ; auto-walk active?
       jne  !                          ; RET Z             ; return if not
       .ret                            ;                   
!
       sb   one,@>02(ix)               ; DEC (IX+$02)      ; take a step
       .ret                            ; RET               ; 

* read controls and apply player movement
* 
* Used by the routines at #R$80d2, #R$8dc4 and #R$8e26.
control_player:                        ; >8d77
       movb @player_room,a             ; LD A,($EA91)      ; 
       movb a,@some_room+>0001         ; LD ($EE59),A      ; blank entity?
       .push bc                        ; PUSH BC           ; 
       .push de                        ; PUSH DE           ; 
       .push hl                        ; PUSH HL           ; 
       .call @auto_walk_step           ; CALL $8D6D        ; reduce auto-walk counter
       movb @>02(ix),a                 ; LD A,(IX+$02)     ; 
       socb @bytes+>30,a               ; OR $30            ; can move left/right or up/down
       movb a,@>02(ix)                 ; LD (IX+$02),A     ; 
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       .call @read_controls            ; CALL $93BE        ; return controls in A (FUDLR order, negative logic)
       movb a,@c                       ; LD C,A            ; FUDLR
       .pop hl                         ; POP HL            ; 
       li   de,>0000                   ; LD DE,$0000       ; no movement yet
       movb @c,r0                      ; BIT 1,C           ; left pressed?
       andi r0,>0200                   ;                   
       jne  loc_8d9e                   ; JR NZ,$8D9E       ; jump if not
       movb b,a                        ; LD A,B            ; 
       neg a                           ; NEG               ; negate for left
       movb a,@e                       ; LD E,A            ; 
loc_8d9e:                              ; >8d9e
       movb @c,r0                      ; BIT 0,C           ; right pressed?
       andi r0,>0100                   ;                   
       jne  loc_8da3                   ; JR NZ,$8DA3       ; jump if not
       movb b,@e                       ; LD E,B            ; 
loc_8da3:                              ; >8da3
       movb @c,r0                      ; BIT 2,C           ; down pressed?
       andi r0,>0400                   ;                   
       jne  loc_8da8                   ; JR NZ,$8DA8       ; jump if not
       movb b,d                        ; LD D,B            ; 
loc_8da8:                              ; >8da8
       movb @c,r0                      ; BIT 3,C           ; up pressed?
       andi r0,>0800                   ;                   
       jne  loc_8db0                   ; JR NZ,$8DB0       ; jump if not
       movb b,a                        ; LD A,B            ; 
       neg a                           ; NEG               ; negate for up
       movb a,d                        ; LD D,A            ; 
loc_8db0:                              ; >8db0
       .pop hl                         ; POP HL            ; DE value from function entry
       .call @slow_player              ; CALL $8F96        ; decelerate player movement
       .pop hl                         ; POP HL            ; BC value from function entry
       .call @move_player              ; CALL $8EEF        ; apply player movement, including auto-walk
       .call @chk_wall_move            ; CALL $8FCA        ; check if walls are blocking movement in DE
       .call @check_doorway            ; CALL $957D        ; check if player is standing in a doorway
       .call @chk_decor_move           ; CALL $900A        ; check if decor is blocking movement in DE
       b    @apply_move                ; JP $8F66          ; apply movement in DE

* serf character handler
h_serf:                                ; >8dc4
       li   bc,>2020                   ; LD BC,$2020       ; walk deceleration
       li   de,>0101                   ; LD DE,$0101       ; walk acceleration
       li   hl,>0707                   ; LD HL,$0707       ; unused
       .call @control_player           ; CALL $8D77        ; read controls and apply player movement
       movb @>06(ix),@e                ; LD E,(IX+$06)     ; x velocity
       movb @>07(ix),d                 ; LD D,(IX+$07)     ; y velocity
       movb d,a                        ; LD A,D            ; 
       socb @e,a                       ; OR E              ; is player moving?
       jeq  loc_8e0f                   ; JR Z,$8E0F        ; jump if not
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       andi a,>0300                    ; AND $03           ; 1/4 update rate
       jne  loc_8e0f                   ; JR NZ,$8E0F       ; jump if not time
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>0300                    ; AND $03           ; keep animation frame bits
       ab   @bytes+>21,a               ; ADD A,$21         ; add base serf graphic
       movb a,*ix                      ; LD (IX+$00),A     ; 
       movb d,a                        ; LD A,D            ; 
       ; AND A                         ; AND A             ; moving down?
       ; JP P,$8DF2                    ; JP P,$8DF2        ; jump if so
       neg a                           ; NEG               ; abs
loc_8df2:                              ; >8df2
       movb a,@c                       ; LD C,A            ; 
       movb @e,a                       ; LD A,E            ; 
       ; AND A                         ; AND A             ; moving right?
       ; JP P,$8DFA                    ; JP P,$8DFA        ; jump if so
       neg a                           ; NEG               ; abs
loc_8dfa:                              ; >8dfa
       cb   a,@c                       ; CP C              ; moving more up/down than left/right?
       jhe  loc_8e1a                   ; JR NC,$8E1A       ; jump if so
       movb d,a                        ; LD A,D            ; 
       ; AND A                         ; AND A             ; moving up?
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; JP M,$8E07                    ; JP M,$8E07        ; jump if so
       ab   @bytes+>04,a               ; ADD A,$04         ; offset to down sprites
loc_8e07:                              ; >8e07
       ab   @bytes+>08,a               ; ADD A,$08         ; offset to right sprites
loc_8e09:                              ; >8e09
       movb a,*ix                      ; LD (IX+$00),A     ; 
       .call @walk_sound               ; CALL $A3C7        ; play walk clicks if due
loc_8e0f:                              ; >8e0f
       .call @read_controls            ; CALL $93BE        ; return controls in A (FUDLR order, negative logic)
       andi a,>1000                    ; AND $10           ; fire pressed?
       jne  !                          ; CALL Z,$8283      ; call if so (fire weapon)
       .call @serf_fire                ;                   
!
       b    @loc_8e78                  ; JP $8E78          ; 
loc_8e1a:                              ; >8e1a
       movb @e,a                       ; LD A,E            ; 
       ; AND A                         ; AND A             ; moving left?
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; JP M,$8E09                    ; JP M,$8E09        ; jump if so
       ab   @bytes+>04,a               ; ADD A,$04         ; offset to right sprites
       jmp  loc_8e09                   ; JR $8E09          ; 

* knight character handler
h_knight:                              ; >8e26
       li   bc,>2020                   ; LD BC,$2020       ; walk deceleration
       li   de,>0303                   ; LD DE,$0303       ; walk acceleration
       li   hl,>0707                   ; LD HL,$0707       ; unused
       .call @control_player           ; CALL $8D77        ; read controls and apply player movement
       movb @>06(ix),@e                ; LD E,(IX+$06)     ; current x velocity
       movb @>07(ix),d                 ; LD D,(IX+$07)     ; current y velocity
       movb d,a                        ; LD A,D            ; 
       socb @e,a                       ; OR E              ; player moving?
       jeq  loc_8e70                   ; JR Z,$8E70        ; jump if not
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       andi a,>0300                    ; AND $03           ; 1/4 update rate
       jne  loc_8e70                   ; JR NZ,$8E70       ; jump if not time
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>0300                    ; AND $03           ; keep animation frame bits
       ab   one,a                      ; INC A             ; add base knight graphic
       movb a,*ix                      ; LD (IX+$00),A     ; 
       movb d,a                        ; LD A,D            ; 
       ; AND A                         ; AND A             ; moving down?
       ; JP P,$8E53                    ; JP P,$8E53        ; jump if so
       neg a                           ; NEG               ; abs
loc_8e53:                              ; >8e53
       movb a,@c                       ; LD C,A            ; 
       movb @e,a                       ; LD A,E            ; 
       ; AND A                         ; AND A             ; moving right?
       ; JP P,$8E5B                    ; JP P,$8E5B        ; jump if so
       neg a                           ; NEG               ; abs
loc_8e5b:                              ; >8e5b
       cb   a,@c                       ; CP C              ; moving more up/down than left/right?
       jhe  loc_8e94                   ; JR NC,$8E94       ; jump if so
       movb d,a                        ; LD A,D            ; 
       ; AND A                         ; AND A             ; moving up?
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; JP M,$8E68                    ; JP M,$8E68        ; jump if so
       ab   @bytes+>04,a               ; ADD A,$04         ; offset to down sprites
loc_8e68:                              ; >8e68
       ab   @bytes+>08,a               ; ADD A,$08         ; offset to right sprites
loc_8e6a:                              ; >8e6a
       movb a,*ix                      ; LD (IX+$00),A     ; 
       .call @walk_sound               ; CALL $A3C7        ; play walk clicks if due
loc_8e70:                              ; >8e70
       .call @read_controls            ; CALL $93BE        ; return controls in A (FUDLR order, negative logic)
       andi a,>1000                    ; AND $10           ; fire pressed?
       jne  !                          ; CALL Z,$8134      ; call if so (fire weapon)
       .call @knight_fire              ;                   
!
* This entry point is used by the routines at #R$80d2 and #R$8dc4.
loc_8e78:                              ; >8e78
       equ  $
       .call @chk_creatures            ; CALL $83EA        ; check whether to add new room creatures
       movb @counter_low,a             ; LD A,($5E12)      ; 
       andi a,>0f00                    ; AND $0F           ; 16th game loop?
       jne  loc_8e8e                   ; JR NZ,$8E8E       ; jump if not
       movb @player_energy,a           ; LD A,($5E28)      ; 
       sb   one,a                      ; DEC A             ; reduce health by 1
       jeq  player_dead                ; JR Z,$8EA0        ; 
       movb a,@player_energy           ; LD ($5E28),A      ; 
       .call @draw_chicken             ; CALL $8B8A        ; draw chicken energy bar
* This entry point is used by the routines at #R$81f0, #R$8301, #R$845f,
* #R$85f7 and #R$8787.
loc_8e8e:                              ; >8e8e
       .call @draw_entity_disp         ; CALL $9FCA        ; draw entity to display (no attrs)
       b    @set_entity_attrs2         ; JP $A01A          ; set attrs covering previous and new position
loc_8e94:                              ; >8e94
       movb @e,a                       ; LD A,E            ; 
       ; AND A                         ; AND A             ; moving left?
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; JP M,$8E6A                    ; JP M,$8E6A        ; jump if so (use left sprites)
       ab   @bytes+>04,a               ; ADD A,$04         ; offset to down sprites
       jmp  loc_8e6a                   ; JR $8E6A          ; 
* This entry point is used by the routines at #R$8a1e, #R$8ed7 and #R$98c8.
player_dead:                           ; >8ea0
       movb @lives,a                   ; LD A,($5E21)      ; 
       ; AND A                         ; AND A             ; no lives left?
       jne  !                          ; JP Z,$8C35        ; jump if so
       b    @game_over                 ;                   
!
       sb   one,a                      ; DEC A             ; lose a life
       movb a,@lives                   ; LD ($5E21),A      ; 
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       sb   one,a                      ; DEC A             ; 
       cb   a,@bytes+>30               ; CP $30            ; is player active?
       jl   loc_8ec6                   ; JR C,$8EC6        ; jump if so
       movb @player,a                  ; LD A,($EA90)      ; 
loc_8eb6:                              ; >8eb6
       movb a,@player_steps_y          ; LD ($EA97),A      ; 
       .call @get_sprite_addr          ; CALL $9E89        ; return address of sprite A in DE
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,@player_steps_x          ; LD ($EA96),A      ; 
       movb @bytes+>67,a               ; LD A,$67          ; blank graphic, death handler
       movb a,@player                  ; LD ($EA90),A      ; 
       .ret                            ; RET               ; 
loc_8ec6:                              ; >8ec6
       movb @saved_x,a                 ; LD A,($5E16)      ; 
       movb a,@player_x                ; LD ($EA93),A      ; 
       movb @saved_y,a                 ; LD A,($5E17)      ; 
       movb a,@player_y                ; LD ($EA94),A      ; 
       movb @saved_graphic,a           ; LD A,($5E15)      ; 
       jmp  loc_8eb6                   ; JR $8EB6          ; 

* reduce health by 32
* 
* Used by the routine at #R$85b2.
damage_32:                             ; >8ed7
       movb @player_energy,a           ; LD A,($5E28)      ; 
       sb   @bytes+>20,a               ; SUB $20           ; lose 32 health
       jeq  loc_8ee1                   ; JR Z,$8EE1        ; 
       jnc  loc_8ee9                   ; JR NC,$8EE9       ; TODO: check code. jump if positive
       sb   a,a                        ; XOR A             ; 
loc_8ee1:                              ; >8ee1
       movb a,@player_energy           ; LD ($5E28),A      ; 
       .call @draw_chicken             ; CALL $8B8A        ; draw chicken energy bar
       jmp  player_dead                ; JR $8EA0          ; 
loc_8ee9:                              ; >8ee9
       movb a,@player_energy           ; LD ($5E28),A      ; 
       b    @draw_chicken_branch ; JP $8B8A          ; draw chicken energy bar

* apply player movement, including auto-walk
* 
* Used by the routine at #R$8d77.
move_player:                           ; >8eef
       movb @>02(ix),a                 ; LD A,(IX+$02)     ; 
       andi a,>0f00                    ; AND $0F           ; auto-walk active?
       jne  auto_walk                  ; JR NZ,$8F35       ; jump if so
       movb @e,a                       ; LD A,E            ; x acceleration
       ab   @>06(ix),a                 ; ADD A,(IX+$06)    ; add x velocity
       ; JP M,$8F21                    ; JP M,$8F21        ; jump if moving left
       cb   a,@l                       ; CP L              ; max x velocity?
       jl   loc_8f01                   ; JR C,$8F01        ; jump if not
       movb @l,a                       ; LD A,L            ; limit velocity to max
loc_8f01:                              ; >8f01
       movb a,@>06(ix)                 ; LD (IX+$06),A     ; update x velocity
       movb d,a                        ; LD A,D            ; y acceleration
       ab   @>07(ix),a                 ; ADD A,(IX+$07)    ; add y velocity
       ; JP M,$8F2B                    ; JP M,$8F2B        ; jump if moving up
       cb   a,h                        ; CP H              ; max y velocity?
       jl   loc_8f0f                   ; JR C,$8F0F        ; jump if not
       movb h,a                        ; LD A,H            ; limit velocity to max
loc_8f0f:                              ; >8f0f
       movb a,@>07(ix)                 ; LD (IX+$07),A     ; update y velocity
       movb @>06(ix),a                 ; LD A,(IX+$06)     ; 
       .call @get_signed_b7_4          ; CALL $8F80        ; return signed top nibble
       movb a,@e                       ; LD E,A            ; x offset
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; 
       .call @get_signed_b7_4          ; CALL $8F80        ; return signed top nibble
       movb a,d                        ; LD D,A            ; y move offset
       .ret                            ; RET               ; 
loc_8f21:                              ; >8f21
       neg a                           ; NEG               ; abs
       cb   a,@l                       ; CP L              ; max x velocity?
       jl   loc_8f27                   ; JR C,$8F27        ; jump if not
       movb @l,a                       ; LD A,L            ; limit velocity to max
loc_8f27:                              ; >8f27
       neg a                           ; NEG               ; re-negate
       jmp  loc_8f01                   ; JR $8F01          ; 
loc_8f2b:                              ; >8f2b
       neg a                           ; NEG               ; abs
       cb   a,h                        ; CP H              ; max y velocity?
       jl   loc_8f31                   ; JR C,$8F31        ; jump if not
       movb h,a                        ; LD A,H            ; limit velocity to max
loc_8f31:                              ; >8f31
       neg a                           ; NEG               ; re-negate
       jmp  loc_8f0f                   ; JR $8F0F          ; 
auto_walk:                             ; >8f35
       movb @>06(ix),a                 ; LD A,(IX+$06)     ; x velocity
       ; AND A                         ; AND A             ; x movement?
       ; JP M,$8F52                    ; JP M,$8F52        ; jump if left
       andi a,>f000                    ; AND $F0           ; any non-fractional movement?
       jeq  loc_8f42                   ; JR Z,$8F42        ; jump if not
       movb @bytes+>02,a               ; LD A,$02          ; walk right 2 pixels
loc_8f42:                              ; >8f42
       movb a,@e                       ; LD E,A            ; x walk in e
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; 
       ; AND A                         ; AND A             ; auto-walk up/down?
       ; JP M,$8F5C                    ; JP M,$8F5C        ; jump if up
       andi a,>f000                    ; AND $F0           ; any non-fractional movement?
       jeq  loc_8f50                   ; JR Z,$8F50        ; jump if not
       movb @bytes+>02,a               ; LD A,$02          ; walk down 2 pixels
loc_8f50:                              ; >8f50
       movb a,d                        ; LD D,A            ; y walk in d
       .ret                            ; RET               ; 
loc_8f52:                              ; >8f52
       neg a                           ; NEG               ; negate for left
       andi a,>f000                    ; AND $F0           ; any non-fractional movement?
       jeq  loc_8f42                   ; JR Z,$8F42        ; jump if not
       movb @b254,a                    ; LD A,$FE          ; walk left 2 pixels
       jmp  loc_8f42                   ; JR $8F42          ; 
loc_8f5c:                              ; >8f5c
       neg a                           ; NEG               ; negate for up
       andi a,>f000                    ; AND $F0           ; any non-fractional movement?
       jeq  loc_8f50                   ; JR Z,$8F50        ; jump if not
       movb @b254,a                    ; LD A,$FE          ; walk up 2 pixels
       jmp  loc_8f50                   ; JR $8F50          ; 
* This entry point is used by the routine at #R$8d77.
apply_move:                            ; >8f66
       movb @>02(ix),r0                ; BIT 4,(IX+$02)    ; x movement allowed?
       andi r0,>1000                   ;                   
       jne  loc_8f73                   ; JR NZ,$8F73       ; jump if not
       movb @e,a                       ; LD A,E            ; delta x
       ab   @>03(ix),a                 ; ADD A,(IX+$03)    ; apply x movement
       movb a,@>03(ix)                 ; LD (IX+$03),A     ; 
loc_8f73:                              ; >8f73
       movb @>02(ix),r0                ; BIT 5,(IX+$02)    ; y movement allowed?
       andi r0,>2000                   ;                   
       jeq  !                          ; RET NZ            ; return if not
       .ret                            ;                   
!
       movb d,a                        ; LD A,D            ; delta y
       ab   @>04(ix),a                 ; ADD A,(IX+$04)    ; apply y movement
       movb a,@>04(ix)                 ; LD (IX+$04),A     ; 
       .ret                            ; RET               ; 

* decelerate player movement
* 
* Used by the routine at #R$8d77.
slow_player:                           ; >8f96
       movb @>02(ix),a                 ; LD A,(IX+$02)     ; 
       andi a,>0f00                    ; AND $0F           ; is auto-walk active?
       jeq  !                          ; RET NZ            ; return if so
       .ret                            ;                   
!
       movb @>06(ix),a                 ; LD A,(IX+$06)     ; 
       ; AND A                         ; AND A             ; x movement?
       jeq  loc_8fad                   ; JR Z,$8FAD        ; jump if not
       ; JP M,$8FBE                    ; JP M,$8FBE        ; jump if left
       sb   @l,a                       ; SUB L             ; decelerate
       ; JP P,$8FAA                    ; JP P,$8FAA        ; jump if still positive
stop_x:                                ; >8fa9
       sb   a,a                        ; XOR A             ; stopped on x axis
loc_8faa:                              ; >8faa
       movb a,@>06(ix)                 ; LD (IX+$06),A     ; update x velocity
loc_8fad:                              ; >8fad
       movb @>07(ix),a                 ; LD A,(IX+$07)     ; 
       ; AND A                         ; AND A             ; y movement?
       jne  !                          ; RET Z             ; return if not
       .ret                            ;                   
!
       ; JP M,$8FC4                    ; JP M,$8FC4        ; jump if moving up
       sb   h,a                        ; SUB H             ; decelerate
       ; JP P,$8FBA                    ; JP P,$8FBA        ; jump if still positive
stop_y:                                ; >8fb9
       sb   a,a                        ; XOR A             ; clear auto-walk up/down
loc_8fba:                              ; >8fba
       movb a,@>07(ix)                 ; LD (IX+$07),A     ; update y velocity
       .ret                            ; RET               ; 
loc_8fbe:                              ; >8fbe
       ab   @l,a                       ; ADD A,L           ; decelerate
       ; JP M,$8FAA                    ; JP M,$8FAA        ; jump if still negative
       jmp  stop_x                     ; JR $8FA9          ; stopped on x axis
loc_8fc4:                              ; >8fc4
       ab   h,a                        ; ADD A,H           ; decelerate
       ; JP M,$8FBA                    ; JP M,$8FBA        ; jump if negative
       jmp  stop_y                     ; JR $8FB9          ; stopped on y axis

* check if walls are blocking movement in DE
* 
* Used by the routine at #R$8d77.
chk_wall_move:                         ; >8fca
       .push de                        ; PUSH DE           ; 
       movb @e,a                       ; LD A,E            ; 
       ab   @>03(ix),a                 ; ADD A,(IX+$03)    ; apply x movement
       movb a,@e                       ; LD E,A            ; 
       movb @>04(ix),d                 ; LD D,(IX+$04)     ; apply y movement
       movb @bytes+>10,b               ; LD B,$10          ; x bit mask
       .call @chk_walls                ; CALL $8FE9        ; check if position is within room interior
       .pop de                         ; POP DE            ; 
       .push de                        ; PUSH DE           ; 
       movb @>03(ix),@e                ; LD E,(IX+$03)     ; 
       movb d,a                        ; LD A,D            ; 
       ab   @>04(ix),a                 ; ADD A,(IX+$04)    ; 
       movb a,d                        ; LD D,A            ; 
       movb @bytes+>20,b               ; LD B,$20          ; 
       .call @chk_walls                ; CALL $8FE9        ; check if position is within room interior
       .pop de                         ; POP DE            ; 
       .ret                            ; RET               ; 

* check if position is within room interior
* 
* Used by the routine at #R$8fca.
chk_walls:                             ; >8fe9
       li   hl,room_width              ; LD HL,$5E1D       ; 
       movb @e,a                       ; LD A,E            ; player x
       sb   @bytes+>58,a               ; SUB $58           ; subtract room centre x
       ; JP P,$8FF4                    ; JP P,$8FF4        ; 
       neg a                           ; NEG               ; abs
loc_8ff4:                              ; >8ff4
       cb   a,*hl                      ; CP (HL)           ; within room width?
       jl   !                          ; RET NC            ; return if so
       .ret                            ;                   
!
       inc  hl                         ; INC HL            ; 
       movb d,a                        ; LD A,D            ; player y
       sb   @bytes+>68,a               ; SUB $68           ; subtract room centre y
       ; JP P,$8FFF                    ; JP P,$8FFF        ; 
       neg a                           ; NEG               ; abs
loc_8fff:                              ; >8fff
       cb   a,*hl                      ; CP (HL)           ; within room height?
       jl   !                          ; RET NC            ; return if so
       .ret                            ;                   
!
       movb b,a                        ; LD A,B            ; 
       inv  a                          ; CPL               ; 
       ; AND (IX+$02)                  ; AND (IX+$02)      ; clear bit in B
       movb a,@>02(ix)                 ; LD (IX+$02),A     ; 
       .ret                            ; RET               ; 

* check if decor is blocking movement in DE
* 
* Used by the routine at #R$8d77.
chk_decor_move:                        ; >900a
       .push de                        ; PUSH DE           ; 
       movb @e,a                       ; LD A,E            ; 
       ab   @>03(ix),a                 ; ADD A,(IX+$03)    ; 
       movb a,@e                       ; LD E,A            ; 
       movb @>04(ix),d                 ; LD D,(IX+$04)     ; 
       movb @bytes+>10,a               ; LD A,$10          ; bit for x movement allowed
       .ex_af_af_                      ; EX AF,AF'         ; 
       .call @chk_decor                ; CALL $902B        ; check if room decor is blocking movement
       .pop de                         ; POP DE            ; 
       .push de                        ; PUSH DE           ; 
       movb @>03(ix),@e                ; LD E,(IX+$03)     ; 
       movb d,a                        ; LD A,D            ; 
       ab   @>04(ix),a                 ; ADD A,(IX+$04)    ; 
       movb a,d                        ; LD D,A            ; 
       movb @bytes+>20,a               ; LD A,$20          ; bit for y movement allowed
       .ex_af_af_                      ; EX AF,AF'         ; 
       .call @chk_decor                ; CALL $902B        ; check if room decor is blocking movement
       .pop de                         ; POP DE            ; 
       .ret                            ; RET               ; 

* check if room decor is blocking movement
* 
* Used by the routine at #R$900a.
chk_decor:                             ; >902b
       movb @>01(ix),@c                ; LD C,(IX+$01)     ; 
       sb   b,b                        ; LD B,$00          ; 
       li   hl,room_table              ; LD HL,$757D       ; 
       ; SLA C                         ; SLA C             ; 
       sla  b,1                        ; RL B              ; TODO: check code. * 2 (bytes per entry)
       a    bc,hl                      ; ADD HL,BC         ; 
       movb *hl,@c                     ; LD C,(HL)         ; 
       inc  hl                         ; INC HL            ; 
       movb *hl,b                      ; LD B,(HL)         ; 
loc_903b:                              ; >903b
       movb *bc,a                      ; LD A,(BC)         ; room item LSB
       inc  bc                         ; INC BC            ; 
       movb a,@l                       ; LD L,A            ; 
       movb *bc,a                      ; LD A,(BC)         ; room item MSB
       inc  bc                         ; INC BC            ; 
       movb a,h                        ; LD H,A            ; 
       socb @l,a                       ; OR L              ; 
       jne  !                          ; RET Z             ; 
       .ret                            ;                   
!
       .push bc                        ; PUSH BC           ; 
       li   bc,room_table              ; LD BC,$757D       ; 
       ; AND A                         ; AND A             ; 
       s    bc,hl                      ; SBC HL,BC         ; 
       inc  hl                         ; INC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jeq  loc_9055                   ; JR Z,$9055        ; jump if so
       li   bc,>0008                   ; LD BC,$0008       ; 8 bytes per entry
       a    bc,hl                      ; ADD HL,BC         ; next (linked) entry
loc_9055:                              ; >9055
       inc  hl                         ; INC HL            ; 
       inc  hl                         ; INC HL            ; 
       movb *hl,@c                     ; LD C,(HL)         ; x
       inc  hl                         ; INC HL            ; 
       movb *hl,b                      ; LD B,(HL)         ; y
       inc  hl                         ; INC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; flags
       inc  hl                         ; INC HL            ; 
       movb a,r0                       ; BIT 2,A           ; 
       andi r0,>0400                   ;                   
       jne  loc_909b                   ; JR NZ,$909B       ; 
       movb a,r0                       ; BIT 3,A           ; 
       andi r0,>0800                   ;                   
       jne  loc_9098                   ; JR NZ,$9098       ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       sra  a,1                        ; SRA A             ; 
       sra  a,1                        ; SRA A             ; 
       andi a,>fc00                    ; AND $FC           ; 
       ab   @c,a                       ; ADD A,C           ; 
       sb   @e,a                       ; SUB E             ; 
       neg a                           ; NEG               ; 
       movb a,@c                       ; LD C,A            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       andi a,>3c00                    ; AND $3C           ; 
       inc  hl                         ; INC HL            ; 
       cb   a,@c                       ; CP C              ; 
       jl   loc_9098                   ; JR C,$9098        ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       sra  a,1                        ; SRA A             ; 
       sra  a,1                        ; SRA A             ; 
       andi a,>fc00                    ; AND $FC           ; 
       ab   b,a                        ; ADD A,B           ; 
       sb   d,a                        ; SUB D             ; 
       movb a,b                        ; LD B,A            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       inc  hl                         ; INC HL            ; 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       andi a,>3c00                    ; AND $3C           ; 
       cb   a,b                        ; CP B              ; 
       jl   loc_9098                   ; JR C,$9098        ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb a,@c                       ; LD C,A            ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb @c,a                       ; LD A,C            ; 
       inv  a                          ; CPL               ; 
       ; AND (IX+$02)                  ; AND (IX+$02)      ; disallow movement bit
loc_9095:                              ; >9095
       movb a,@>02(ix)                 ; LD (IX+$02),A     ; 
loc_9098:                              ; >9098
       .pop bc                         ; POP BC            ; 
       jmp  loc_903b                   ; JR $903B          ; 
loc_909b:                              ; >909b
       movb *hl,a                      ; LD A,(HL)         ; 
       sra  a,1                        ; SRA A             ; 
       sra  a,1                        ; SRA A             ; 
       andi a,>fc00                    ; AND $FC           ; 
       ab   @c,a                       ; ADD A,C           ; 
       sb   @e,a                       ; SUB E             ; 
       neg a                           ; NEG               ; 
       movb a,@c                       ; LD C,A            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       andi a,>3c00                    ; AND $3C           ; 
       inc  hl                         ; INC HL            ; 
       cb   a,@c                       ; CP C              ; 
       jl   loc_9098                   ; JR C,$9098        ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       sra  a,1                        ; SRA A             ; 
       sra  a,1                        ; SRA A             ; 
       andi a,>fc00                    ; AND $FC           ; 
       ab   b,a                        ; ADD A,B           ; 
       sb   d,a                        ; SUB D             ; 
       movb a,b                        ; LD B,A            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       inc  hl                         ; INC HL            ; 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       andi a,>3c00                    ; AND $3C           ; 
       cb   a,b                        ; CP B              ; 
       jl   loc_9098                   ; JR C,$9098        ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb a,@c                       ; LD C,A            ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb @c,a                       ; LD A,C            ; 
       socb @>02(ix),a                 ; OR (IX+$02)       ; allow movement bit
       jmp  loc_9095                   ; JR $9095          ; 

* check if player has left through a door
* 
* Used by the routines at #R$91f2, #R$9222 and #R$9731.
check_exit:                            ; >90cc
       movb @player_contact,a          ; LD A,($EA92)      ; 
       andi a,>0f00                    ; AND $0F           ; touching enemy?
       jeq  !                          ; RET NZ            ; return if so [check]
       .ret                            ;                   
!
       movb @player,a                  ; LD A,($EA90)      ; 
       sb   one,a                      ; DEC A             ; 
       cb   a,@bytes+>30               ; CP $30            ; player active?
       jl   !                          ; RET NC            ; return if not
       .ret                            ;                   
!
       movb @>05(ix),r0                ; BIT 6,(IX+$05)    ; top/bottom door?
       andi r0,>4000                   ;                   
       jeq  loc_90e1                   ; JR Z,$90E1        ; jump if so
       ; SRL C                         ; SRL C             ; halve vertical distance
loc_90e1:                              ; >90e1
       movb @player_x,a                ; LD A,($EA93)      ; 
       sb   @>03(ix),a                 ; SUB (IX+$03)      ; x distance
       cb   a,@c                       ; CP C              ; within range?
       jl   !                          ; RET NC            ; return if not
       .ret                            ;                   
!
       movb @>05(ix),r0                ; BIT 6,(IX+$05)    ; left/right door?
       andi r0,>4000                   ;                   
       jne  loc_90f1                   ; JR NZ,$90F1       ; jump if so
       srl  b,1                        ; SRL B             ; halve horiztonal distance
loc_90f1:                              ; >90f1
       movb @player_y,a                ; LD A,($EA94)      ; 
       sb   @>04(ix),a                 ; SUB (IX+$04)      ; y distance to exit
       neg a                           ; NEG               ; 
       cb   a,b                        ; CP B              ; within range?
       .ret                            ; RET               ; return no-carry if not

* check if player is touching entity
* 
* Used by the routines at #R$8c63, #R$92f5 and #R$988b.
check_touching:                        ; >90fb
       movb @player_x,a                ; LD A,($EA93)      ; 
       sb   @>03(ix),a                 ; SUB (IX+$03)      ; x distance
       ; JP P,$9106                    ; JP P,$9106        ; 
       neg a                           ; NEG               ; abs
loc_9106:                              ; >9106
       cb   a,@bytes+>0c               ; CP $0C            ; within range?
       jl   !                          ; RET NC            ; return if not
       .ret                            ;                   
!
       movb @player_y,a                ; LD A,($EA94)      ; 
       sb   @>04(ix),a                 ; SUB (IX+$04)      ; y distance
       ; JP P,$9114                    ; JP P,$9114        ; 
       neg a                           ; NEG               ; abs
loc_9114:                              ; >9114
       cb   a,@bytes+>0c               ; CP $0C            ; within range?
       .ret                            ; RET               ; return no-carry if not

*********************************************************************
*
* move player to room linked to entity (usually door)
* 
* Used by the routines at #R$91f2, #R$9244 and #R$9731.
change_room:                           ; >9117
       .call @get_linked_door          ; CALL $9286        ; get connected door exit
       movb @>01(ix),a                 ; LD A,(IX+$01)     ; 
       movb a,@player_room             ; LD ($EA91),A      ; move player to connected room
       movb @>02(ix),a                 ; LD A,(IX+$02)     ; bits 3-0 used for x offset
       sla  a,1                        ; RLCA              ; TODO: check code. * 2
       andi a,>1e00                    ; AND $1E           ; 
       ab   @>03(ix),a                 ; ADD A,(IX+$03)    ; add x
       movb a,@player_x                ; LD ($EA93),A      ; set player x to exit
       movb @>02(ix),a                 ; LD A,(IX+$02)     ; bits 7-4 used for y offset
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; * 2 (effectively)
       srl  a,3
       andi a,>1e00                    ; AND $1E           ; 
       neg  a                          ; NEG               ; invert
       ab   @>04(ix),a                 ; ADD A,(IX+$04)    ; add y
       movb a,@player_y                ; LD ($EA94),A      ; set player y to exit
       .call @set_entry_walk           ; CALL $986A        ; auto-walk into the room
       movb @player_contact,a          ; LD A,($EA92)      ; 
       socb @bytes+>0f,a               ; OR $0F            ; 
       movb a,@player_contact          ; LD ($EA92),A      ; 
       jmp  enter_room

*********************************************************************
*
* This entry point is used by the routine at #R$7d9a.
*
enter_room:                            ; >9147
       movb @player_room,a             ; LD A,($EA91)      ;
       .call @visit_room               ; CALL $96AF        ; mark room A as visited
room_loop:
       .call @clear_play_area          ; CALL $8093        ; clear screen and attrs of play area
       .call @draw_room_frame          ; CALL $9BEA        ; draw lines that make up outer room frame
       .call @draw_panel_attrs         ; CALL $A240        ; draw side-panel colours, which follow room colour
       .call @draw_inventory           ; CALL $A13B        ; draw any items in player inventory
;      .call @entry_sound              ; CALL $A403        ; room entry sound effect
       b    @main_loop                 ; JP $7DC3          ; 

* open door handler
h_door_open:                           ; >915f
       movb @counter_low,a             ; LD A,($5E12)      ; 
       andi a,>0100                    ; AND $01           ; 2 alternating tasks
       jeq  !                          ; JP NZ,$91F2       ; jump if we're checking exits this time
       b    @h_door_exit               ;                   
!
       movb @door_timer,a              ; LD A,($5E2E)      ; 
       ; AND A                         ; AND A             ; door timer expired?
       jeq  loc_9174                   ; JR Z,$9174        ; jump if so
       sb   one,a                      ; DEC A             ; reduce timer
       movb a,@door_timer              ; LD ($5E2E),A      ; 
       b    @h_door_exit               ; JP $91F2          ; jump to check exits
loc_9174:                              ; >9174
       movb @in_doorway,a              ; LD A,($5E2D)      ; 
       ; AND A                         ; AND A             ; player standing in doorway?
       jeq  !                          ; JP NZ,$91F2       ; jump if so (run exit logic only)
       b    @h_door_exit               ;                   
!
       jmp  loc_9193                   ; JR $9193          ; 
h_door_closed:                         ; >917d
       movb @counter_low,a             ; LD A,($5E12)      ; closed door handler
       andi a,>0100                    ; AND $01           ; 2 alternating tasks
       jeq  !                          ; JP NZ,$91FE       ; jump if we're drawing this time
       b    @draw_room_item            ;
!
       movb @door_timer,a              ; LD A,($5E2E)      ; 
       ; AND A                         ; AND A             ; door timer expired?
       jne  !                          ; JP Z,$9193        ; jump if so
       b    @loc_9193                  ;                   
!
       sb   one,a                      ; DEC A             ; 
       movb a,@door_timer              ; LD ($5E2E),A      ; 
       b    @draw_room_item            ; JP $91FE          ; draw room item
loc_9193:                              ; >9193
       movb @bytes+>5e,a               ; LD A,$5E          ; 0x5E * 2 / 50 = 3.76 seconds, due to halved timer
                                                           ; processing
       movb a,@door_timer              ; LD ($5E2E),A      ; 
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; save door attr
       .push af                        ; PUSH AF           ; 
       socb @bytes+>03,a               ; OR $03            ; 
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       .call @draw_bgrnd_graphics             ; CALL $9213        ; undraw door
       movb *ix,a                      ; LD A,(IX+$00)     ; entity type
       xor  one,a                      ; XOR $01           ; toggle open/close state
       .call @set_door_type            ; CALL $9260        ; set door type for both linked entities
       .call @draw_bgrnd_graphics             ; CALL $9213        ; redraw door
       .pop af                         ; POP AF            ; 
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; restore door attr
       .call @update_door              ; CALL $9546        ; update solid/passable door state
       .call @draw_room_item_call      ; CALL $91FE        ; draw room item
       b    @door_sound                ; JP $A46E          ; door sound (short burst of white noise)

* closed trapdoor handler
h_trap_closed:                         ; >91bc
       movb @counter_low,a             ; LD A,($5E12)      ; 
       ; AND A                         ; AND A             ; 
       jeq  !                          ; JP NZ,$91FE       ; draw room item
       b    @draw_room_item            ;
!
       jmp  trap_common                ; JR $91CC          ; 
h_trap_open:                           ; >91c5
       movb @rand8,a                   ; LD A,($5E05)      ; open trapdoor handler
       ; AND A                         ; AND A             ; zero?
       jeq  !                          ; JP NZ,$9731       ; jump if not
       b    @chk_trap_exit             ;                   
!
trap_common:                           ; >91cc
       equ  $
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; 
       .push af                        ; PUSH AF           ; 
       socb @bytes+>03,a               ; OR $03            ; 
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       .call @draw_bgrnd_graphics             ; CALL $9213        ;
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       xor  one,a                      ; XOR $01           ; toggle open/closed state
       movb a,*ix                      ; LD (IX+$00),A     ; 
       .call @draw_bgrnd_graphics             ; CALL $9213        ;
       .pop af                         ; POP AF            ;
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       .call @draw_room_item_call              ; CALL $91FE        ; draw room item
       b    @door_sound                ; JP $A46E          ; door sound (short burst of white noise)

* big door exit handler
h_big_door_exit:                       ; >91ed
       li   bc,>2020                   ; LD BC,$2020       ; 32x32 size
       jmp  loc_91f5                   ; JR $91F5          ; 

* door exit handler
* 
* Used by the routines at #R$915f and #R$9421.
h_door_exit:                           ; >91f2
       li   bc,>1111                   ; LD BC,$1111       ; 17x17 exit size
* This entry point is used by the routines at #R$91ed and #R$961b.
loc_91f5:                              ; >91f5
       .call @check_exit               ; CALL $90CC        ; check if player has left through a door
       ; CALL C,$9117                  ; CALL C,$9117      ; move player to room linked to entity (usually door)
       b    @draw_room_item            ; JP $91FE          ; draw room item

* return if player has required key (C if opened, NC if locked)
* 
* Used by the routines at #R$9244 and #R$9252.
check_key_colour:                      ; >9222
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>0300                    ; AND $03           ; locked door colour index
       li   hl,key_attrs               ; LD HL,$925C       ; 
       .call @add_hl_a                 ; CALL $926C        ; HL = HL + A
       movb *hl,d                      ; LD D,(HL)         ; key colour attr
       movb @bytes+>81,@e              ; LD E,$81          ; key graphic
       .call @check_carrying           ; CALL $9273        ; is player carrying the required key colour?
       jeq  !                          ; JP NZ,$923F       ; jump if not
       b    @loc_923f                  ;                   
!
       .call @enter_door               ; CALL $954D        ; enter linked object (door etc.)
       li   bc,>1111                   ; LD BC,$1111       ; 17x17 size
       b    @check_exit                ; JP $90CC          ; check if player has left through a door
loc_923f:                              ; >923f
       .call @loc_9565                 ; CALL $9565        ; 
       ; AND A                         ; AND A             ; door locked
       .ret                            ; RET               ; 

* coloured locked door handler
h_door_locked:                         ; >9244
       .call @check_key_colour         ; CALL $9222        ; does player have the required key colour?
       joc  !                          ; JP NC,$91FE       ; TODO: check code. jump if not
       b    @draw_room_item            ;
!
       movb @bytes+>02,a               ; LD A,$02          ; open door graphic
* This entry point is used by the routine at #R$9252.
loc_924c:                              ; >924c
       .call @set_door_type            ; CALL $9260        ; set door type for both linked entities
       b    @change_room               ; JP $9117          ; move player to room linked to entity (usually door)

* coloured cave locked door handler
h_cave_locked:                         ; >9252
       .call @check_key_colour         ; CALL $9222        ; return if player has required key (C if opened, NC if
                                                           ; locked)
       joc  !                          ; JP NC,$91FE       ; TODO: check code. draw room item
       b    @draw_room_item            ;
!
       movb one,a                      ; LD A,$01          ; open cave graphic
       jmp  loc_924c                   ; JR $924C          ; 

* set door type for both linked entities
* 
* Used by the routines at #R$915f and #R$9244.
set_door_type:                         ; >9260
       .push ix                        ; PUSH IX           ; 
       .pop hl                         ; POP HL            ; 
       movb a,*hl                      ; LD (HL),A         ; set door graphic
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb @l,a                       ; LD A,L            ; 
       li   r0,8*256                   ; XOR $08           ; linked entry
       xor  r0,a                       ;                   
       movb a,@l                       ; LD L,A            ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb a,*hl                      ; LD (HL),A         ; set linked door graphic
       .ret                            ; RET               ; 

* check if player is carrying object E with colour D
* 
* Used by the routines at #R$8906, #R$8988 and #R$9222.
check_carrying:                        ; >9273
       movb @bytes+>03,b               ; LD B,$03          ; 3 inventory slots to search
       li   hl,inventory1+>0002        ; LD HL,$5E32       ; 
loc_9278:                              ; >9278
       movb *hl,a                      ; LD A,(HL)         ; item colour
       cb   a,@e                       ; CP E              ; match?
       inc  hl                         ; INC HL            ; 
       jne  loc_9280                   ; JR NZ,$9280       ; jump if not
       movb *hl,a                      ; LD A,(HL)         ; item graphic
       cb   a,d                        ; CP D              ; match?
       jne  !                          ; RET Z             ; return if so
       .ret                            ;                   
!
loc_9280:                              ; >9280
       equ  $
       inc  hl                         ; INC HL            ; 
       inc  hl                         ; INC HL            ; 
       inc  hl                         ; INC HL            ; next inventory slot
       sb   one,b                      ; DJNZ $9278        ; 
       jne  loc_9278                   ;                   
       .ret                            ; RET               ; 

* get connected door exit
* 
* Used by the routines at #R$9117 and #R$9546.
get_linked_door:                       ; >9286
       .push ix                        ; PUSH IX           ; 
       .pop hl                         ; POP HL            ; 
       movb @l,a                       ; LD A,L            ; 
       li   r0,8*256                   ; XOR $08           ; swap 8-byte entry
       xor  r0,a                       ;                   
       movb a,@l                       ; LD L,A            ; 
       .push hl                        ; PUSH HL           ; 
       .pop ix                         ; POP IX            ; 
       .ret                            ; RET               ; 

* draw all non-monster entities in the current room
* 
* Used by the routine at #R$7e13.
draw_entities:                         ; >9291
       .proc
       seto @sprite_graphics_rom_bank
       li   ix,player                  ; LD IX,$EA90       ;
draw_entities_1:                       ; >9295
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; AND A                         ; AND A             ; slot used?
       jeq  draw_entities_2            ; JR Z,$92A6        ; jump if not
;      movb @player_room,a             ; LD A,($EA91)      ;
       cb   @player_room,@>01(ix)      ; CP (IX+$01)       ; in player room?
       jne  draw_entities_2            ; JR NZ,$92A6       ; jump if not
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
draw_entities_2:                       ; >92a6
;      li   de,>0008                   ; LD DE,$0008       ; 8 bytes per entry
       ai   ix,8                       ; ADD IX,DE         ;
;      .push ix                        ; PUSH IX           ;
;      .pop hl                         ; POP HL            ;
;      li   de,creature1               ; LD DE,$EE60       ; end marker
       ; AND A                         ; AND A             ; 
;      s    de,hl                      ; SBC HL,DE         ; more 8-byte entries to process?
       ci   ix,creature1
       jl  draw_entities_1             ; JR C,$9295        ; jump back if so
draw_entities_3:                       ; >92b6
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; AND A                         ; AND A             ; slot used?
       jeq  draw_entities_4            ; JR Z,$92C7        ; jump if not
;      movb @player_room,a             ; LD A,($EA91)      ;
       cb   @player_room,@>01(ix)      ; CP (IX+$01)       ; in player room?
       jne  draw_entities_4            ; JR NZ,$92C7       ; jump if not
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
draw_entities_4:                       ; >92c7
;      li   de,>0010                   ; LD DE,$0010       ; 16 bytes per entry
       ai   ix,16                      ; ADD IX,DE         ;
;      .push ix                        ; PUSH IX           ;
;      .pop hl                         ; POP HL            ;
;      li   de,linked_items            ; LD DE,$EEE0       ; end of 16-byte entities
       ; AND A                         ; AND A             ; 
;      s    de,hl                      ; SBC HL,DE         ; more 16-byte entries to draw?
       ci   ix,linked_items
       jl   draw_entities_3            ; JR C,$92B6        ; jump back if so
       .endproc                        ; RET               ;

* clear pickup key flag
* 
* Used by the routine at #R$92f5.
pickup_released:                       ; >92d8
       movb @pickup_flags,a            ; LD A,($5E1F)      ; 
       andi a,>fd00                    ; AND $FD           ; clear b1 (pickup key not pressed)
       movb a,@pickup_flags            ; LD ($5E1F),A      ; 
* This entry point is used by the routines at #R$8c63, #R$92f5, #R$95d7 and
* #R$988b.
draw_16x16:                            ; >92e0
       movb @bytes+>10,a               ; LD A,$10          ; 16 lines high by default

* set spawn appearance width/height
* 
* Used by the routine at #R$8cb7.
set_appear_w_h:                        ; >92e2
       movb a,@height_lines            ; LD ($5E11),A      ; 
       movb @>03(ix),a                 ; LD A,(IX+$03)     ; 
       andi a,>0700                    ; AND $07           ; x aligned on cell boundary?
       movb @bytes+>02,a               ; LD A,$02          ; 2 bytes wide
       jeq  loc_92ef                   ; JR Z,$92EF        ; 
       ab   one,a                      ; INC A             ; extra byte needed
loc_92ef:                              ; >92ef
       movb a,@width_bytes             ; LD ($5E10),A      ; 
       b    @set_entity_attrs2         ; JP $A01A          ; set attrs covering previous and new position

* pickup item handler
h_pickup_item:                         ; >92f5
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       movb @pickup_pressed,a          ; LD A,($5E20)      ; 
       ; AND A                         ; AND A             ; if pick-up key pressed?
       jeq  pickup_released            ; JR Z,$92D8        ; jump if not
       movb @pickup_flags,a            ; LD A,($5E1F)      ; 
       andi a,>0300                    ; AND $03           ; is pick-up allowed?
       jne  draw_16x16                 ; JR NZ,$92E0       ; jump if not
       movb @player,a                  ; LD A,($EA90)      ; 
       sb   one,a                      ; DEC A             ; 
       cb   a,@bytes+>30               ; CP $30            ; is player active?
       jhe  draw_16x16                 ; JR NC,$92E0       ; jump if not
       .call @check_touching           ; CALL $90FB        ; is player touching item?
       jnc  draw_16x16                 ; JR NC,$92E0       ; TODO: check code. jump if not
       movb @pickup_flags,a            ; LD A,($5E1F)      ; 
       socb @bytes+>03,a               ; OR $03            ; disallow further pickups
       movb a,@pickup_flags            ; LD ($5E1F),A      ; 
       .call @drop_item                ; CALL $9358        ; drop last item in inventory
       .call @shift_inventory          ; CALL $934C        ; move items 1+2 to slots 2+3
       .call @add_inventory            ; CALL $9326        ; add item to inventory slot 1
       b    @draw_inventory            ; JP $A13B          ; draw any items in player inventory

* add item to inventory slot 1
* 
* Used by the routine at #R$92f5.
add_inventory:                         ; >9326
       li   hl,inventory1              ; LD HL,$5E30       ; 
       .push ix                        ; PUSH IX           ; 
       .pop de                         ; POP DE            ; 
       movb @e,*hl                     ; LD (HL),E         ; entity LSB
       inc  hl                         ; INC HL            ; 
       movb d,*hl                      ; LD (HL),D         ; entity MSB
       inc  hl                         ; INC HL            ; 
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       movb a,*hl                      ; LD (HL),A         ; graphic
       inc  hl                         ; INC HL            ; 
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .call @undraw_entity            ; CALL $9F56        ; 
       movb @room_attr,a               ; LD A,($5E1A)      ; 
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       .call @set_entity_attrs2        ; CALL $A01A        ; set attrs covering previous and new position
       sb   *ix,*ix                    ; LD (IX+$00),$00   ; 
       b    @inventory_sound           ; JP $A3BD          ; 

* move items 1+2 to slots 2+3
* 
* Used by the routines at #R$92f5 and #R$93e3.
shift_inventory:                       ; >934c
       li   hl,inventory2+>0003        ; LD HL,$5E37       ; 
       li   de,inventory3+>0003        ; LD DE,$5E3B       ; 
       li   bc,>0008                   ; LD BC,$0008       ; 2 items * 4 bytes
       .lddr                           ; LDDR              ; shift up items
       .ret                            ; RET               ; 

* drop last item in inventory
* 
* Used by the routines at #R$92f5 and #R$93e3.
drop_item:                             ; >9358
       li   hl,inventory3              ; LD HL,$5E38       ; 
       movb *hl,@e                     ; LD E,(HL)         ; 
       inc  hl                         ; INC HL            ; 
       movb *hl,d                      ; LD D,(HL)         ; 
       inc  hl                         ; INC HL            ; 
       movb d,a                        ; LD A,D            ; 
       socb @e,a                       ; OR E              ; 
       jne  !                          ; RET Z             ; return if no item to drop
       .ret                            ;                   
!
       .push de                        ; PUSH DE           ; 
       movb *hl,a                      ; LD A,(HL)         ; graphic idx
       inc  hl                         ; INC HL            ; 
       movb a,*de                      ; LD (DE),A         ; 
       inc  de                         ; INC DE            ; 
       movb @player_room,a             ; LD A,($EA91)      ; 
       movb a,*de                      ; LD (DE),A         ; set item room
       inc  de                         ; INC DE            ; 
       movb @bytes+>80,a               ; LD A,$80          ; 
       movb a,*de                      ; LD (DE),A         ; 
       inc  de                         ; INC DE            ; 
       movb @player_x,a                ; LD A,($EA93)      ; 
       movb a,*de                      ; LD (DE),A         ; set item xpos
       inc  de                         ; INC DE            ; 
       movb @player_y,a                ; LD A,($EA94)      ; 
       movb a,*de                      ; LD (DE),A         ; set item ypos
       inc  de                         ; INC DE            ; 
       movb *hl,a                      ; LD A,(HL)         ; inventory colour
       movb a,*de                      ; LD (DE),A         ; set item attr
       .pop de                         ; POP DE            ; 
       .call @drop_sound               ; CALL $A3C2        ; 
       .push ix                        ; PUSH IX           ; 
       .push de                        ; PUSH DE           ; 
       .pop ix                         ; POP IX            ; 
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .pop ix                         ; POP IX            ; 
       .ret                            ; RET               ; 

* check whether pick-up key has been pressed
* 
* Used by the routine at #R$7e13.
check_pickup_key:                      ; >938b             ;
       .proc
;      movb @bytes+>7e,a               ; LD A,$7E          ; read V/C/X/Z/Shift and B/N/M/Sym/Space rows
;      ; OUT ($FD),A                   ; OUT ($FD),A       ;
;      ; IN A,($FE)                    ; IN A,($FE)        ;
;      inv  a                          ; CPL               ;
;      andi a,>0200                    ; AND $02           ; non-zero if Symbol Shift or Z pressed
       li   r0,KEY_G
       bl   @ti_check_key
       jeq  check_pickup_key_1
       movb @bytes+2,@pickup_pressed   ; LD ($5E20),A      ;
check_pickup_key_1:
       .endproc                        ; RET               ;

* This entry point is used by the routine at #R$93be.
read_cursor:                           ; >9398
       movb @bytes+>ef,a               ; LD A,$EF          ; 
       ; OUT ($FD),A                   ; OUT ($FD),A       ; 
       ; IN A,($FE)                    ; IN A,($FE)        ; xxx67890
       movb a,@c                       ; LD C,A            ; 
       andi a,>0800                    ; AND $08           ; 7 key
       movb a,@e                       ; LD E,A            ; 
       movb @c,a                       ; LD A,C            ; 
       ; RRCA                          ; RRCA              ; 0xxx6789
       ; RRCA                          ; RRCA              ; 90xxx678
       andi a,>4500                    ; AND $45           ; ?+6+8 keys
       socb @e,a                       ; OR E              ; 
       movb a,@e                       ; LD E,A            ; 
       ; RRCA                          ; RRCA              ; 890xxx67
       ; RRCA                          ; RRCA              ; 7890xxx6
       andi a,>1000                    ; AND $10           ; 0 key
       socb @e,a                       ; OR E              ; 
       andi a,>1f00                    ; AND $1F           ; 
       movb a,@e                       ; LD E,A            ; 
       movb @bytes+>f7,a               ; LD A,$F7          ; xxx54321
       ; OUT ($FD),A                   ; OUT ($FD),A       ; 
       ; IN A,($FE)                    ; IN A,($FE)        ; 
       srl  a,1                        ; RRA               ; TODO: check code. 1xxx5432
       srl  a,1                        ; RRA               ; TODO: check code. 21xxx543
       srl  a,1                        ; RRA               ; TODO: check code. 321xxx54
       andi a,>0200                    ; AND $02           ; 5 key
       socb @e,a                       ; OR E              ; 
       .ret                            ; RET               ; 

* return controls in A (FUDLR order, negative logic)
* 
* Used by the routines at #R$80d2, #R$8d77, #R$8dc4 and #R$8e26.
read_controls:                         ; >93be
       movb @menu_selection,a          ; LD A,($5E00)      ; 
       andi a,>0600                    ; AND $06           ; 
       jeq  read_keyboard              ; JR Z,$93CD        ; 
       cb   a,@bytes+>04               ; CP $04            ; 
       jeq  read_cursor                ; JR Z,$9398        ; 
       ; IN A,($1F)                    ; IN A,($1F)        ; read Kempston joystick
       inv  a                          ; CPL               ; 
       .ret                            ; RET               ; 
read_keyboard:                         ; >93cd
       movb @bytes+>fb,a               ; LD A,$FB          ; 
       ; OUT ($FD),A                   ; OUT ($FD),A       ; 
       ; IN A,($FE)                    ; IN A,($FE)        ; xxxTREWQ
       movb a,@c                       ; LD C,A            ; 
       srl  a,1                        ; RRA               ; TODO: check code. 
       andi a,>0100                    ; AND $01           ; W key
       movb a,@e                       ; LD E,A            ; 
       movb @c,a                       ; LD A,C            ; 
       ; RLA                           ; RLA               ; 
       andi a,>0200                    ; AND $02           ; Q key
       socb @e,a                       ; OR E              ; 
       movb a,@e                       ; LD E,A            ; 
       movb @c,a                       ; LD A,C            ; 
       andi a,>1c00                    ; AND $1C           ; ___TRE__
       socb @e,a                       ; OR E              ; ___TREQW
       .ret                            ; RET               ; 

* Routine at 93e3
h_blank:                               ; >93e3
       movb @player,a                  ; LD A,($EA90)      ; 
       sb   one,a                      ; DEC A             ; 
       cb   a,@bytes+>30               ; CP $30            ; is player active?
       jl   !                          ; RET NC            ; return if not
       .ret                            ;                   
!
       movb @pickup_pressed,a          ; LD A,($5E20)      ; 
       ; AND A                         ; AND A             ; pick-up key down?
       jeq  loc_9417                   ; JR Z,$9417        ; jump if not
       movb @pickup_flags,a            ; LD A,($5E1F)      ; 
       andi a,>0300                    ; AND $03           ; pick-up allowed?
       jne  loc_940e                   ; JR NZ,$940E       ; jump if not
       socb @bytes+>02,a               ; OR $02            ; pickup key pressed
       movb a,@pickup_flags            ; LD ($5E1F),A      ; 
       .call @drop_item                ; CALL $9358        ; drop last item in inventory
       .call @shift_inventory          ; CALL $934C        ; move items 1+2 to slots 2+3
       li   hl,>0000                   ; LD HL,$0000       ; 
       mov  hl,@inventory1             ; LD ($5E30),HL     ; 
       mov  hl,@inventory1+>0002       ; LD ($5E32),HL     ; 
       .call @draw_inventory           ; CALL $A13B        ; draw any items in player inventory
loc_940e:                              ; >940e
       movb @pickup_flags,a            ; LD A,($5E1F)      ; 
       andi a,>fe00                    ; AND $FE           ; pickup key not processed
       movb a,@pickup_flags            ; LD ($5E1F),A      ; 
       .ret                            ; RET               ; 
loc_9417:                              ; >9417
       movb @pickup_flags,a            ; LD A,($5E1F)      ; 
       andi a,>fd00                    ; AND $FD           ; pickup key released
       movb a,@pickup_flags            ; LD ($5E1F),A      ; 
       jmp  loc_940e                   ; JR $940E          ; 

* Routine at 9421
h_barrel:                              ; >9421
       movb @player,a                  ; LD A,($EA90)      ; 
       sb   @bytes+>21,a               ; SUB $21           ; subtract serf base graphic
       jmp  loc_9433                   ; JR $9433          ; 
h_bookcase:                            ; >9428
       movb @player,a                  ; LD A,($EA90)      ; 
       sb   @bytes+>11,a               ; SUB $11           ; subtract wizard base graphic
       jmp  loc_9433                   ; JR $9433          ; 
h_clock:                               ; >942f
       movb @player,a                  ; LD A,($EA90)      ; 
       sb   one,a                      ; DEC A             ; subtract knight base graphic
loc_9433:                              ; >9433
       cb   a,@bytes+>10               ; CP $10            ; required player type to pass through?
       jhe  loc_943d                   ; JR NC,$943D       ; jump if not
       .call @enter_door               ; CALL $954D        ; enter linked object (door etc.)
       b    @h_door_exit               ; JP $91F2          ; door exit handler
loc_943d:                              ; >943d
       .call @loc_9565                 ; CALL $9565        ; 
       b    @draw_room_item            ; JP $91FE          ; draw room item

* prepare player to spawn
* 
* Used by the routines at #R$7d9a and #R$8d45.
prepare_player:                        ; >9443
       .proc
       movb @menu_selection,a          ; LD A,($5E00)      ; 
       sla  a,1                        ; RLCA              ; TODO: check code. 
       andi a,>3000                    ; AND $30           ; base character graphic
       ab   @bytes+>08,a               ; ADD A,$08         ; offset to desired facing direction
       movb a,@player_template+>0007   ; LD ($9488),A      ; set spawn graphic
       movb @player_room,a             ; LD A,($EA91)      ; current player room
       movb a,@player_template+>0001   ; LD ($9482),A      ; respawn in same room
       li   hl,player_template         ; LD HL,$9481       ; 
       li   de,player                  ; LD DE,$EA90       ; 
       li   bc,>0008                   ; LD BC,$0008       ; player entity size
       .ldir                           ; LDIR              ; copy to live player
       movb @bytes+>68,@flash_timer    ; LD A,$68          ; flash score for 104 frames
;      movb a,@flash_timer             ; LD ($5E3C),A      ; score flash timer
       movb @lives,a                   ; LD A,($5E21)      ; 
       cb   a,@bytes+>03               ; CP $03            ; first game spawn? (full lives)
       jeq  loc_9476                   ; JR Z,$9476        ; jump if so (skip drawing player)
       .push ix                        ; PUSH IX           ; 
       li   ix,player                  ; LD IX,$EA90       ; 
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .pop ix                         ; POP IX            ; 
loc_9476:                              ; >9476
       movb @bytes+>f0,@player_energy  ; LD A,$F0          ; starting energy
;      movb a,@player_energy           ; LD ($5E28),A      ;
       .call @draw_chicken             ; CALL $8B8A        ; draw chicken energy bar
       b    @draw_lives_branch  ; JP $A2CE          ; draw lives sprites in side panel


* check for pause key, return when not paused
* 
* Used by the routine at #R$7e13.
check_pause:                           ; >9489             ;
       .proc
;      limi 0                          ; DI                ; disable interrupts to suspend FRAMES counter advance
;       movb @bytes+>7e,a               ; LD A,$7E          ;
;       ; OUT ($FD),A                   ; OUT ($FD),A       ;
;       ; IN A,($FE)                    ; IN A,($FE)        ;
;       movb a,r0                       ; BIT 0,A           ; pause (space/shift) pressed?
;       andi r0,>0100                   ;
;       jeq  !                          ; RET NZ            ; return if not
;       .ret                            ;
;!
;       inv  a                          ; CPL               ;
;       andi a,>1e00                    ; AND $1E           ; any other key on the same row pressed?
;       jeq  !                          ; RET NZ            ; return if so
;       .ret                            ;
;!
       li   r0,KEY_P
       bl   @ti_check_key
       jeq  check_pause_3
;loc_9497:                              ; >9497
;       equ  $
;       movb @bytes+>7e,a               ; LD A,$7E          ;
;       ; OUT ($FD),A                   ; OUT ($FD),A       ;
;       ; IN A,($FE)                    ; IN A,($FE)        ;
;       movb a,r0                       ; BIT 0,A           ; space/shift pressed?
;       andi r0,>0100                   ;
;       jeq  loc_9497                   ; JR Z,$9497        ; jump if so (wait until released)
;loc_94a1:                              ; >94a1
;       movb @bytes+>7e,a               ; LD A,$7E          ;
;       ; OUT ($FD),A                   ; OUT ($FD),A       ;
;       ; IN A,($FE)                    ; IN A,($FE)        ;
;       movb a,r0                       ; BIT 0,A           ; space/shift pressed?
;       andi r0,>0100                   ;
;       jne  loc_94a1                   ; JR NZ,$94A1       ; jump if not (main pause loop)
;loc_94ab:                              ; >94ab
;       movb @bytes+>7e,a               ; LD A,$7E          ;
;       ; OUT ($FD),A                   ; OUT ($FD),A       ;
;       ; IN A,($FE)                    ; IN A,($FE)        ;
;       movb a,r0                       ; BIT 0,A           ; space/shift pressed?
;       andi r0,>0100                   ;
;       jeq  loc_94ab                   ; JR Z,$94AB        ; jump if so (wait until pause key released)
check_pause_1:
       li   r0,KEY_P
       bl   @ti_check_key
       jne  check_pause_1
check_pause_2:
       li   r0,KEY_P
       bl   @ti_check_key
       jeq  check_pause_2
check_pause_3:
       .endproc                        ; RET               ;

* set locations of ACG key pieces
* 
* Used by the routine at #R$7d9a.
place_key_pieces:                      ; >94b6
       .proc
       bl   @ti_rnd
       movb r0,a                       ; LD A,($5C78)      ; zx_frames
       movb a,@c                       ; LD C,A            ; 
       movb @counter_low,a             ; LD A,($5E12)      ; 
       ab   @c,a                       ; ADD A,C           ; 
       andi a,>0700                    ; AND $07           ; 
       movb a,@c                       ; LD C,A            ; 
       ab   a,a                        ; ADD A,A           ; * 2
       ab   @c,a                       ; ADD A,C           ; * 3 (3 key pieces per entry)
       movb a,@l                       ; LD L,A            ; 
       sb   h,h                        ; LD H,$00          ; 
       li   bc,acg_key_rooms           ; LD BC,$94DD       ; 
       a    bc,hl                      ; ADD HL,BC         ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       li   hl,acg_key_init+>0001      ; LD HL,$6026       ; first key piece room
       li   bc,>0008                   ; LD BC,$0008       ; 8 bytes per entity
       movb @bytes+>03,a               ; LD A,$03          ; 3 key pieces
loc_94d3:                              ; >94d3
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       a    bc,hl                      ; ADD HL,BC         ; 
       inc  de                         ; INC DE            ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       sb   one,a                      ; DEC A             ; 
       jne  loc_94d3                   ; JR NZ,$94D3       ; 
       .endproc                        ; RET               ;

* randomise which doors can open/close
* 
* Used by the routine at #R$7d9a.
randomise_doors:                       ; >94f5
       .proc
       movb @counter_low,a             ; LD A,($5E12)      ;
       movb a,@l                       ; LD L,A            ; set ROM addr LSB
       bl   @ti_rnd
       movb r0,a                       ; LD A,($5C78)      ; 0-49
       andi a,>0f00                    ; AND $0F           ; limit to 4K (0000-0FFF)
       socb @bytes+>10,a               ; OR $10            ; add 4K (1000-1FFF)
       movb a,h                        ; LD H,A            ; set ROM addr MSB
       .exx                            ; EXX               ; 
       li   hl,linked_items            ; LD HL,$EEE0       ; pairs of linked items, including doors
       li   de,second_linked_item                   ; LD DE,$EEE8       ; pairs of linked items, including doors
       li   bc,>0010                   ; LD BC,$0010       ; 16 bytes per entry
loc_950b:                              ; >950b
       .exx                            ; EXX               ; 
       movb *hl,a                      ; LD A,(HL)         ; read ROM byte
       inc  hl                         ; INC HL            ; 
       .exx                            ; EXX               ; 
       cb   a,@bytes+>70               ; CP $70            ; ROM value >= 0x70 (~56% chance)
       jhe  loc_951f                   ; JR NC,$951F       ; jump if so (door always open)
       movb *de,a                      ; LD A,(DE)         ; 
       cb   a,*hl                      ; CP (HL)           ; same value?
       jne  loc_951f                   ; JR NZ,$951F       ; jump if not (no change)
       cb   a,one                      ; CP $01            ; cave doorway?
       jeq  loc_9526                   ; JR Z,$9526        ; jump if so
       cb   a,@bytes+>02               ; CP $02            ; normal doorway?
       jeq  loc_9542                   ; JR Z,$9542        ; jump if so
loc_951f:                              ; >951f
       a    bc,hl                      ; ADD HL,BC         ; next entry
       .ex_de_hl                       ; EX DE,HL          ; 
       a    bc,hl                      ; ADD HL,BC         ; next entry
       jnc  !                          ; RET C             ; TODO: check code. return if hit end of RAM
       .endproc                            ;
!
       .ex_de_hl                       ; EX DE,HL          ; 
       jmp  loc_950b                   ; JR $950B          ; 
loc_9526:                              ; >9526
       movb @bytes+>22,a               ; LD A,$22          ; mode?
loc_9528:                              ; >9528
       movb a,*de                      ; LD (DE),A         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .push de                        ; PUSH DE           ; 
;      inc  de                         ; INC DE            ;
;      inc  de                         ; INC DE            ;
;      inc  de                         ; INC DE            ;
;      inc  de                         ; INC DE            ;
;      inc  de                         ; INC DE            ; + 5
       ai   de,5
       movb *de,a                      ; LD A,(DE)         ;
       socb @bytes+>08,a               ; OR $08            ; 
       movb a,*de                      ; LD (DE),A         ; 
       .pop de                         ; POP DE            ; 
       .push hl                        ; PUSH HL           ; 
;      inc  hl                         ; INC HL            ;
;      inc  hl                         ; INC HL            ;
;      inc  hl                         ; INC HL            ;
;      inc  hl                         ; INC HL            ;
;      inc  hl                         ; INC HL            ;
       ai   hl,5
       movb *hl,a                      ; LD A,(HL)         ;
       socb @bytes+>08,a               ; OR $08            ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .pop hl                         ; POP HL            ; 
       jmp  loc_951f                   ; JR $951F          ; 
loc_9542:                              ; >9542
       movb @bytes+>20,a               ; LD A,$20          ; mode?
       jmp  loc_9528                   ; JR $9528          ; 

* update solid/passable door state
* 
* Used by the routine at #R$915f.
update_door:                           ; >9546
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       andi a,>0100                    ; AND $01           ; is door open?
       jeq  loc_9565                   ; JR Z,$9565        ; jump if so
* This entry point is used by the routines at #R$9222, #R$9421 and #R$961b.
enter_door:                            ; >954d
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; enter linked object (door etc.)
       andi a,>f700                    ; AND $F7           ; object is solid
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       .push ix                        ; PUSH IX           ; 
       .call @get_linked_door          ; CALL $9286        ; get connected door exit
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; 
       andi a,>f700                    ; AND $F7           ; linked object is solid
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       .pop ix                         ; POP IX            ; 
       .ret                            ; RET               ; 
* This entry point is used by the routines at #R$9222, #R$9421 and #R$961b.
loc_9565:                              ; >9565
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; 
       socb @bytes+>08,a               ; OR $08            ; object can be passed through
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       .push ix                        ; PUSH IX           ; 
       .call @get_linked_door          ; CALL $9286        ; get connected door exit
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; 
       socb @bytes+>08,a               ; OR $08            ; linked object can be passed through
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; 
       .pop ix                         ; POP IX            ; 
       .ret                            ; RET               ; 

* check if player is standing in a doorway
* 
* Used by the routine at #R$8d77.
check_doorway:                         ; >957d
       .push de                        ; PUSH DE           ; 
       sb   b,b                        ; LD B,$00          ; 
       mov  @room_width,hl             ; LD HL,($5E1D)     ; 
       ab   one,@l                     ; INC L             ; increase interior width
       ab   one,h                      ; INC H             ; increase interior height
       movb @>03(ix),@e                ; LD E,(IX+$03)     ; player x
       movb @>04(ix),d                 ; LD D,(IX+$04)     ; player y
       movb @e,a                       ; LD A,E            ; 
       sb   @bytes+>58,a               ; SUB $58           ; subtract room centre x
       ; JP P,$9593                    ; JP P,$9593        ; 
       neg a                           ; NEG               ; abs
loc_9593:                              ; >9593
       cb   a,@l                       ; CP L              ; within interior width?
       jl   loc_9597                   ; JR C,$9597        ; jump if so
       ab   one,b                      ; INC B             ; mark as in left/right doorway
loc_9597:                              ; >9597
       movb d,a                        ; LD A,D            ; 
       sb   @bytes+>68,a               ; SUB $68           ; subtract room centre y
       ; JP P,$959F                    ; JP P,$959F        ; 
       neg a                           ; NEG               ; abs
loc_959f:                              ; >959f
       cb   a,h                        ; CP H              ; within interior height?
       jl   loc_95a3                   ; JR C,$95A3        ; jump if so
       ab   one,b                      ; INC B             ; mark as in top/bottom doorway
loc_95a3:                              ; >95a3
       movb b,a                        ; LD A,B            ; 
       movb a,@in_doorway              ; LD ($5E2D),A      ; non-zero if in a doorway
       .pop de                         ; POP DE            ; 
       .ret                            ; RET               ; 

* place a tombstone at the player position
* 
* Used by the routine at #R$8d45.
place_tombstone:                       ; >95a9
       li   hl,tombstone1              ; LD HL,$EAE8       ; tombstone entities
       li   de,>0008                   ; LD DE,$0008       ; 8 bytes per entity
       movb @bytes+>04,b               ; LD B,$04          ; 4 tombstone slots
loc_95b1:                              ; >95b1
       movb *hl,a                      ; LD A,(HL)         ; 
       ; AND A                         ; AND A             ; free slot?
       jeq  loc_95b9                   ; JR Z,$95B9        ; jump if so
       a    de,hl                      ; ADD HL,DE         ; next slot
       sb   one,b                      ; DJNZ $95B1        ; 
       jne  loc_95b1                   ;                   
       .ret                            ; RET               ; 
loc_95b9:                              ; >95b9
       movb @bytes+>45,a               ; LD A,$45          ; bright cyan
       movb a,@player_attr             ; LD ($EA95),A      ; 
       .push hl                        ; PUSH HL           ; 
       movb @bytes+>8f,*hl             ; LD (HL),$8F       ; tombstone graphic
       .ex_de_hl                       ; EX DE,HL          ; 
       inc  de                         ; INC DE            ; 
       li   hl,player_room             ; LD HL,$EA91       ; copy remaining details from player entity
       li   bc,>0007                   ; LD BC,$0007       ; 8 bytes minus the graphic we've written
       .ldir                           ; LDIR              ; 
       .pop hl                         ; POP HL            ; jump return address

* draw entity in HL
* 
* Used by the routine at #R$96c9.
draw_entity_hl:                        ; >95cc
       .push ix                        ; PUSH IX           ; 
       .push hl                        ; PUSH HL           ; 
       .pop ix                         ; POP IX            ; 
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .pop ix                         ; POP IX            ; 
       .ret                            ; RET               ; 

* Attributes: thunk
h_tombstone:                           ; >95d7
       b    @draw_16x16                ; JP $92E0          ; draw 16x16 entity

* advance the clock 1 frame
* 
* Used by the routine at #R$7ec5.
clock_tick:                            ; >95da
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       cb   a,@bytes+>32               ; CP $32            ; 1 second elapsed?
       jhe  !                          ; RET C             ; return if not
       .ret                            ;                   
!
       sb   @bytes+>32,a               ; SUB $32           ; subtract 1 second
       movb a,@zx_frames               ; LD ($5C78),A      ; store back [this keeps LSB in 0-49 range!]
       li   hl,clock_seconds           ; LD HL,$5E3F       ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   one,a                      ; INC A             ; add a second
       .daa                            ; DAA               ; 
       movb a,*hl                      ; LD (HL),A         ; 
       cb   a,@bytes+>60               ; CP $60            ; 60 seconds?
       jne  loc_9604                   ; JR NZ,$9604       ; jump if not
       sb   *hl,*hl                    ; LD (HL),$00       ; reset seconds
       dec  hl                         ; DEC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   one,a                      ; INC A             ; add a minute
       .daa                            ; DAA               ; 
       movb a,*hl                      ; LD (HL),A         ; 
       cb   a,@bytes+>60               ; CP $60            ; 60 minutes?
       jne  loc_9604                   ; JR NZ,$9604       ; jump if not
       sb   *hl,*hl                    ; LD (HL),$00       ; reset minutes
       dec  hl                         ; DEC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   one,a                      ; INC A             ; add an hour
       .daa                            ; DAA               ; 
       andi a,>0f00                    ; AND $0F           ; clip hours to 0-15
       movb a,*hl                      ; LD (HL),A         ; 
loc_9604:                              ; >9604
       li   hl,zx_screen+>00c8         ; LD HL,$40C8       ; time coords

* print clock time at position HL
* 
* Used by the routine at #R$9641.
print_clock:                           ; >9607
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       li   de,clock_hours             ; LD DE,$5E3D       ; 
       movb @bytes+>02,b               ; LD B,$02          ; 
       .call @print_bcd_digit          ; CALL $A1C9        ; print a single BCD digit
       li   de,clock_seconds           ; LD DE,$5E3F       ; 
       inc  hl                         ; INC HL            ; 
       movb one,b                      ; LD B,$01          ; 
       b    @print_bcd_bytes           ; JP $A1BF          ; print B BCD bytes at DE

* ACG exit door handler
h_acg_exit:                            ; >961b
       li   hl,inventory1+>0002        ; LD HL,$5E32       ; graphic idx
       li   de,>0004                   ; LD DE,$0004       ; 4 bytes per inventory slot
       movb *hl,a                      ; LD A,(HL)         ; 
       cb   a,@bytes+>8c               ; CP $8C            ; ACG key part 1?
       jne  loc_963b                   ; JR NZ,$963B       ; jump if not
       a    de,hl                      ; ADD HL,DE         ; next slot
       movb *hl,a                      ; LD A,(HL)         ; 
       cb   a,@bytes+>8d               ; CP $8D            ; ACG key part 2?
       jne  loc_963b                   ; JR NZ,$963B       ; jump if not
       a    de,hl                      ; ADD HL,DE         ; next slot
       movb *hl,a                      ; LD A,(HL)         ; 
       cb   a,@bytes+>8e               ; CP $8E            ; ACG key part 3?
       jne  loc_963b                   ; JR NZ,$963B       ; jump if not
       .call @enter_door               ; CALL $954D        ; enter linked object (door etc.)
       li   bc,>3020                   ; LD BC,$3020       ; 48x32
       b    @loc_91f5                  ; JP $91F5          ; 
loc_963b:                              ; >963b
       .call @loc_9565                 ; CALL $9565        ; 
       b    @draw_room_item            ; JP $91FE          ; draw room item

* show game statistics
* 
* Used by the routines at #R$8c35 and #R$96c9.
game_stats:                            ; >9641
       .call @calc_visited             ; CALL $96C9        ; calculate percentage of rooms visited
       li   hl,zx_screen+>0040         ; LD HL,$4040       ; time header at 64,64
       li   de,time_msg                ; LD DE,$967F       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       li   hl,zx_screen+>1040         ; LD HL,$5040       ; score header at 64,80
       li   de,score_msg               ; LD DE,$968F       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       li   hl,green_key_init+>0003    ; LD HL,$6040       ; percent header at 64,96
       li   de,percent_msg             ; LD DE,$969F       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       li   hl,digit_charset           ; LD HL,$BFCC       ; 
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   hl,zx_screen+>0080         ; LD HL,$4080       ; clock at 128,64
       .call @print_clock              ; CALL $9607        ; print clock time at position HL
       li   hl,zx_screen+>1080         ; LD HL,$5080       ; score at 128,80
       .call @print_score              ; CALL $A1B7        ; print player score at position HL
       li   hl,cyan_key_init+>0033     ; LD HL,$6080       ; percent at 128,96
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       li   de,visited_percent         ; LD DE,$5E54       ; 
       movb one,b                      ; LD B,$01          ; 
       b    @print_bcd_bytes           ; JP $A1BF          ; print B BCD bytes at DE

* mark room A as visited
* 
* Used by the routine at #R$9117.
visit_room:                            ; >96af
       movb a,@c                       ; LD C,A            ; room A
       ; SRL C                         ; SRL C             ; 
       ; SRL C                         ; SRL C             ; 
       ; SRL C                         ; SRL C             ; 
       sb   b,b                        ; LD B,$00          ;
       srl  bc,3
       li   hl,visited_rooms           ; LD HL,$5E40       ; visit rooms bit array
       a    bc,hl                      ; ADD HL,BC         ; 
;       sla  a,1                        ; RLCA              ; TODO: check code.
;       sla  a,1                        ; RLCA              ; TODO: check code.
;       sla  a,1                        ; RLCA              ; TODO: check code.
;       andi a,>3800                    ; AND $38           ;
;       socb @bytes+>c6,a               ; OR $C6            ;
;       movb a,@loc_96c6+>0001          ; LD ($96C7),A      ; self-modify bit in SET below
       movb a,r0
       swpb r0
       andi r0,7
       ai   r0,bits
       mov  r0,@loc_96c6+2
loc_96c6:                              ; >96c6
       socb @bits+0,*hl                ; SET 0,(HL)        ; mark room as visited
       .ret                            ; RET               ; 

* calculate percentage of rooms visited
* 
* Used by the routine at #R$9641.
calc_visited:                          ; >96c9
       li   hl,visited_rooms           ; LD HL,$5E40       ; visit rooms bit array
       li   bc,>0813                   ; LD BC,$0813       ; 8*19 bits covers all rooms
       movb @bytes+>03,d               ; LD D,$03          ; D decremented for every visited room
       sb   a,a                        ; XOR A             ; 
loc_96d2:                              ; >96d2
       .push bc                        ; PUSH BC           ; 
       movb *hl,@e                     ; LD E,(HL)         ; 8 visited bits
       inc  hl                         ; INC HL            ; 
loc_96d5:                              ; >96d5
       ; RR E                          ; RR E              ; 
       jnc  loc_96e1                   ; JR NC,$96E1       ; TODO: check code. 
       sb   one,d                      ; DEC D             ; counter zero?
       jne  loc_96e1                   ; JR NZ,$96E1       ; jump if not
       movb @bytes+>03,d               ; LD D,$03          ; reset counter
       ab   @bytes+>02,a               ; ADD A,$02         ; add 2% for every 3 visited rooms
       .daa                            ; DAA               ; 
loc_96e1:                              ; >96e1
       sb   one,b                      ; DJNZ $96D5        ; 
       jne  loc_96d5                   ;                   
       .pop bc                         ; POP BC            ; 
       sb   one,@c                     ; DEC C             ; 
       jne  loc_96d2                   ; JR NZ,$96D2       ; 
       ab   one,a                      ; INC A             ; add 1% to total
       movb a,@visited_percent         ; LD ($5E54),A      ; 
       .ret                            ; RET               ; 
* This entry point is used by the routine at #R$7e13.
game_complete:                         ; >96ec
       li   hl,player                  ; LD HL,$EA90       ; congratulate player on completion
       .call @draw_entity_hl           ; CALL $95CC        ; undraw player
       li   hl,charset_base                   ; LD HL,$BE4C       ;
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   hl,>2040                   ; LD HL,$2040       ; congratulations at 64,32
       li   de,congrat_msg             ; LD DE,$9710       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       li   hl,>3040                   ; LD HL,$3040       ; escaped message at 64,48
       li   de,escape_msg              ; LD DE,$9720       ; 
       .call @colour_text              ; CALL $A1F3        ; show a line of text, first byte is attr
       .call @game_stats               ; CALL $9641        ; show game statistics
       b    @loc_8c4a                  ; JP $8C4A          ; 

* Routine at 9731
* 
* Used by the routine at #R$91bc.
chk_trap_exit:                         ; >9731
       li   bc,>1818                   ; LD BC,$1818       ; 24x24
       .call @check_exit               ; CALL $90CC        ; fallen into trap door?
       joc  !                          ; JP NC,$91FE       ; TODO: check code. jump if not
       b    @draw_room_item            ;
!
       .call @clear_play_area          ; CALL $8093        ; clear screen and attrs of play area
       movb @bytes+>96,a               ; LD A,$96          ; room 150 is trap door tunnel
       .push ix                        ; PUSH IX           ; 
       .call @draw_room_a              ; CALL $9BF1        ; draw trap door lines
       .pop ix                         ; POP IX            ; 
       movb @bytes+>80,b               ; LD B,$80          ; 128 frames of tunnel animation
loc_9748:                              ; >9748
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       movb a,@c                       ; LD C,A            ; 
loc_974c:                              ; >974c
       .push bc                        ; PUSH BC           ; 
       movb b,a                        ; LD A,B            ; 
       inv  a                          ; CPL               ; ~frame counter is effect frequency
       movb a,b                        ; LD B,A            ; 
       .call @click                    ; CALL $A3A8        ; short beep
       .pop bc                         ; POP BC            ; 
       movb @zx_frames,a               ; LD A,($5C78)      ; 
       cb   a,@c                       ; CP C              ; same frame?
       jeq  loc_974c                   ; JR Z,$974C        ; loop back to continue sound effect
       andi a,>0700                    ; AND $07           ; frame 1-7?
       sb   a,a                        ; LD A,$00          ; black
       jne  loc_9762                   ; JR NZ,$9762       ; jump if so (use black)
       movb @bytes+>47,a               ; LD A,$47          ; bright white
loc_9762:                              ; >9762
       movb a,@l                       ; LD L,A            ; 
       movb a,h                        ; LD H,A            ; 
       mov  hl,@zx_attrs+>016b         ; LD ($596B),HL     ; 
       mov  hl,@zx_attrs+>018b         ; LD ($598B),HL     ; 
       .push bc                        ; PUSH BC           ; 
       .call @draw_tunnel_attrs        ; CALL $9774        ; 
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $9748        ; loop until end of effect
       jne  loc_9748                   ;                   
       b    @change_room               ; JP $9117          ; move player to room linked to entity (usually door)

* Routine at 9774
* 
* Used by the routine at #R$9731.
draw_tunnel_attrs:                     ; >9774
       li   bc,>170b                   ; LD BC,$170B       ; 23x11 (for 24x24 final area)
       li   hl,zx_attrs+>02e0          ; LD HL,$5AE0       ; 
       li   de,>0020                   ; LD DE,$0020       ; line pitch is 32 bytes
loc_977d:                              ; >977d
       .push hl                        ; PUSH HL           ; 
       ; AND A                         ; AND A             ; 
       s    de,hl                      ; SBC HL,DE         ; 
       ab   one,@l                     ; INC L             ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       .pop hl                         ; POP HL            ; 
       .push bc                        ; PUSH BC           ; 
loc_9785:                              ; >9785
       movb a,*hl                      ; LD (HL),A         ; draw horizontal bar
       ab   one,@l                     ; INC L             ; forwards
       sb   one,b                      ; DJNZ $9785        ; 
       jne  loc_9785                   ;                   
       .pop bc                         ; POP BC            ; 
       .push bc                        ; PUSH BC           ; 
loc_978b:                              ; >978b
       movb a,*hl                      ; LD (HL),A         ; draw vertical bar
       ; AND A                         ; AND A             ; backwards
       s    de,hl                      ; SBC HL,DE         ; 
       sb   one,b                      ; DJNZ $978B        ; 
       jne  loc_978b                   ;                   
       .pop bc                         ; POP BC            ; 
       .push bc                        ; PUSH BC           ; 
loc_9793:                              ; >9793
       movb a,*hl                      ; LD (HL),A         ; draw horizontal bar
       sb   one,@l                     ; DEC L             ; backwards
       sb   one,b                      ; DJNZ $9793        ; 
       jne  loc_9793                   ;                   
       .pop bc                         ; POP BC            ; 
       .push bc                        ; PUSH BC           ; 
loc_9799:                              ; >9799
       movb a,*hl                      ; LD (HL),A         ; draw vertical bar
       a    de,hl                      ; ADD HL,DE         ; forwards
       sb   one,b                      ; DJNZ $9799        ; 
       jne  loc_9799                   ;                   
       movb a,*hl                      ; LD (HL),A         ; 
       ; AND A                         ; AND A             ; 
       s    de,hl                      ; SBC HL,DE         ; 
       ab   one,@l                     ; INC L             ; 
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DEC B             ; 
       sb   one,b                      ; DEC B             ; 
       sb   one,@c                     ; DEC C             ; 
       jne  loc_977d                   ; JR NZ,$977D       ; 
       .ret                            ; RET               ; 

* auto-walk into the room
* 
* Used by the routine at #R$9117.
set_entry_walk:                        ; >986a
       movb @>05(ix),a                 ; LD A,(IX+$05)     ; b7-6 is door facing direction (00=down, 01=left, 10=up,
                                                           ; 11=right)
       sla  a,1                        ; RLCA              ; TODO: check code. 
       sla  a,1                        ; RLCA              ; TODO: check code. move to b1-0
       sla  a,1                        ; RLCA              ; TODO: check code. * 2
       andi a,>0600                    ; AND $06           ; mask to look-up offset
       movb a,@c                       ; LD C,A            ; 
       sb   b,b                        ; LD B,$00          ; 
       li   hl,walk_dir                ; LD HL,$9883       ; 
       a    bc,hl                      ; ADD HL,BC         ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       inc  hl                         ; INC HL            ; 
       movb a,@player_steps_x          ; LD ($EA96),A      ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       movb a,@player_steps_y          ; LD ($EA97),A      ; 
       .ret                            ; RET               ; 

* mushroom handler
h_mushroom:                            ; >988b
       .call @save_entity              ; CALL $9FFB        ; save entity position for undraw
       .call @check_touching           ; CALL $90FB        ; check if player is touching entity
       joc  loc_98b1                   ; JR C,$98B1        ; TODO: check code. 
loc_9893:                              ; >9893
       movb @counter_low,a             ; LD A,($5E12)      ; 
       inv  a                          ; CPL               ; 
       andi a,>0300                    ; AND $03           ; time to change colour? (every 4 frames)
       jne  loc_989e                   ; JR NZ,$989E       ; jump if not
       ab   one,@>06(ix)               ; INC (IX+$06)      ; cycle colour
loc_989e:                              ; >989e
       movb @>06(ix),a                 ; LD A,(IX+$06)     ; 
       andi a,>0300                    ; AND $03           ; 4 possible colours
       movb a,@c                       ; LD C,A            ; 
       sb   b,b                        ; LD B,$00          ; 
       li   hl,mushroom_attrs          ; LD HL,$98C4       ; 
       a    bc,hl                      ; ADD HL,BC         ; 
       movb *hl,a                      ; LD A,(HL)         ; new mushroom attr
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; set colour
       b    @draw_16x16                ; JP $92E0          ; draw 16x16 entity
loc_98b1:                              ; >98b1
       movb @player_energy,a           ; LD A,($5E28)      ; 
       sb   one,a                      ; DEC A             ; 
       movb a,@player_energy           ; LD ($5E28),A      ; 
       jne  !                          ; JP Z,$98C8        ; 
       b    @mushroom_death            ;                   
!
       .call @draw_chicken             ; CALL $8B8A        ; draw chicken energy bar
       .call @touching_sound           ; CALL $A3E5        ; play monster touched sound
       b    @loc_9893                  ; JP $9893          ; 

* Routine at 98c8
* 
* Used by the routine at #R$988b.
mushroom_death:                        ; >98c8
       .call @undraw_entity            ; CALL $9F56        ; 
       sb   *ix,*ix                    ; LD (IX+$00),$00   ; remove mushroom
       b    @player_dead               ; JP $8EA0          ; 

* set positions of red/green/cyan keys, and mummy
* 
* Used by the routine at #R$7d9a.
set_key_positions:                     ; >98d2
       .proc
*      Green
       bl   @ti_rnd
       movb r0,a                       ; LD A,($5C78)      ; zx_frames
       li   hl,green_key_rooms         ; LD HL,$990C       ; 
       .call @get_key_room             ; CALL $9904        ; 
;      movb a,@green_key_init+>0001    ; LD ($603E),A      ; set green key room
       movb a,@green_key+>0001         ; LD ($603E),A      ; set green key room
*      Red
       bl   @ti_rnd
       movb r0,a                       ; LD A,($5C78)      ; zx_frames
       movb a,@c                       ; LD C,A            ; 
       movb @counter_low,a             ; LD A,($5E12)      ; 
       ab   @c,a                       ; ADD A,C           ; 
       li   hl,red_key_rooms           ; LD HL,$9914       ; 
       .call @get_key_room             ; CALL $9904        ; 
;      movb a,@red_key_init+1          ; LD ($6046),A      ; set red key room
       movb a,@red_key+1               ; LD ($6046),A      ; set red key room
;      movb a,@mummy_init+1            ; LD ($640E),A      ; set Mummy room to match
       movb a,@mummy+1                 ; LD ($640E),A      ; set Mummy room to match
*      Cyan
       bl   @ti_rnd
       movb r0,a                       ; LD A,($5C79)      ; zx_frames
       movb a,@c                       ; LD C,A            ; 
       movb @counter_high,a            ; LD A,($5E13)      ; 
       ab   @c,a                       ; ADD A,C           ; 
       li   hl,cyan_key_rooms          ; LD HL,$991C       ; 
       .call @get_key_room             ; CALL $9904        ; 
;      movb a,@cyan_key_init+1         ; LD ($604E),A      ; set cyan key room
       movb a,@cyan_key+1              ; LD ($604E),A      ; set cyan key room
       .endproc                        ; RET               ;

* Routine at 9904
* 
* Used by the routine at #R$98d2.
get_key_room:                          ; >9904
       andi a,>0700                    ; AND $07           ; 
       movb a,@c                       ; LD C,A            ; 
       sb   b,b                        ; LD B,$00          ; 
       a    bc,hl                      ; ADD HL,BC         ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       .ret                            ; RET               ; 

* periodically replenish consumed food
* 
* Used by the routine at #R$7e13.
replenish_food:                        ; >9924
       movb @counter_low,a             ; LD A,($5E12)      ; 
       movb a,@c                       ; LD C,A            ; 
       movb @counter_high,a            ; LD A,($5E13)      ; 
       andi a,>0100                    ; AND $01           ; 
       socb @c,a                       ; OR C              ; 9-bit counter value zero?
       jne  replenish_food_2           ; RET NZ            ; return if not
       mov  @food_ptr,hl               ; LD HL,($5E55)     ;
;      li   de,>0008                   ; LD DE,$0008       ; 8 bytes per item
       ai   hl,>0008                      ; ADD HL,DE         ; next food item
       mov  hl,@food_ptr               ; LD ($5E55),HL     ; 
;      .push hl                        ; PUSH HL           ;
;      .pop ix                         ; POP IX            ;
       mov  hl,ix
       li   de,food_end                ; LD DE,$EDD8       ; end marker
       ; AND A                         ; AND A             ; 
       c    de,hl                      ; SBC HL,DE         ; end of list?
       jle  replenish_food_1                   ; JR NC,$995B       ; jump if so
       movb @player_room,a             ; LD A,($EA91)      ; 
       cb   a,@>01(ix)                 ; CP (IX+$01)       ; in player room?
       jne  replenish_food_2           ; RET Z             ; return if so
       movb *ix,a                      ; LD A,(IX+$00)     ;
       ; AND A                         ; AND A             ; does food still exist?
       jne  replenish_food_2           ; RET NZ            ; return if so
       movb @zx_frames,a               ; LD A,($5C78)      ; pseudo random value
       andi a,>0700                    ; AND $07           ; 8 available food items
       ab   @bytes+>50,a               ; ADD A,$50         ; add food base graphic
       movb a,*ix                      ; LD (IX+$00),A     ; set food graphic (replenish)
       jmp  replenish_food_2           ; RET               ;
replenish_food_1:                      ; >995b
       li   hl,food_items              ; LD HL,$EB58       ; 
       mov  hl,@food_ptr               ; LD ($5E55),HL     ; 
replenish_food_2:
       .ret                            ; RET               ;

* draw any items in player inventory
* 
* Used by the routines at #R$9117, #R$92f5 and #R$93e3.
draw_inventory:                        ; >a13b
       seto @sprite_graphics_rom_bank
       .proc
       li   de,>2cc8                   ; LD DE,$2CC8       ; coords of first inventory item
       li   hl,inventory1              ; LD HL,$5E30       ; 
       movb @bytes+>03,b               ; LD B,$03          ; 3 items to draw
loc_a143:                              ; >a143
       .call @draw_inv_item            ; CALL $A14D        ; draw inventory item at position DE
;      movb @e,a                       ; LD A,E            ;
       ab   @bytes+>10,@e              ; ADD A,$10         ; next inventory position
;      movb a,@e                       ; LD E,A            ;
       sb   one,b                      ; DJNZ $A143        ; 
       jne  loc_a143                   ;                   
       .endproc                        ; RET               ;

* draw inventory item at position DE
* 
* Used by the routine at #R$a13b.
draw_inv_item:                         ; >a14d
       .proc
       .push bc                        ; PUSH BC           ;
       .push de                        ; PUSH DE           ; 
       .push ix                        ; PUSH IX           ; 
       li   ix,entity_to_draw          ; LD IX,$A17D       ; 
       movb *hl+,a                     ; LD A,(HL)         ; entity LSB
;      inc  hl                         ; INC HL            ;
       socb *hl+,a                     ; OR (HL)           ; object in this slot?
;      inc  hl                         ; INC HL            ;
       jne  loc_a15e                   ; JR NZ,$A15E       ; jump if so
       movb @bytes+>31,a               ; LD A,$31          ; blank space
       inc  hl                         ; INC HL            ;
       jmp  !
loc_a15e:                              ; >a15e
       movb *hl+,a                     ; LD A,(HL)         ;
!:
       movb a,*ix                      ; LD (IX+$00),A     ; set graphic
       movb @e,@>03(ix)                ; LD (IX+$03),E     ; set xpos
       movb d,@>04(ix)                 ; LD (IX+$04),D     ; set ypos
       movb *hl+,a                     ; LD A,(HL)         ;
;      inc  hl                         ; INC HL            ;
       movb a,@>05(ix)                 ; LD (IX+$05),A     ; set attr
       .push hl                        ; PUSH HL           ; 
       .call @clear_sprite             ; CALL $A185        ; 
       .call @draw_entity              ; CALL $9F4A        ; draw entity graphic (no attrs)
       .call @set_entity_attrs         ; CALL $A00E        ; paint entity with its current attr colour
       .pop hl                         ; POP HL            ; 
       .pop ix                         ; POP IX            ; 
       .pop de                         ; POP DE            ; 
       .pop bc                         ; POP BC            ; 
       .endproc                        ; RET               ;

* add BC to current score
* 
* Used by the routines at #R$871a and #R$8988.
add_score_bc_bcd:                      ; >a19c
       li   hl,score_bcd+>0002         ; LD HL,$5E2C       ; end of score is 1s
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   @c,a                       ; ADD A,C           ; add 10s and 1s
       .daa                            ; DAA               ; 
       movb a,*hl                      ; LD (HL),A         ; 
       dec  hl                         ; DEC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   b,a                        ; ADC A,B           ; add 1000s and 100s
       .daa                            ; DAA               ; 
       movb a,*hl                      ; LD (HL),A         ; 
       dec  hl                         ; DEC HL            ; 
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   @zero,a                    ; ADC A,$00         ; carry 10000s
       .daa                            ; DAA               ; 
       movb a,*hl                      ; LD (HL),A         ; 
* This entry point is used by the routine at #R$a219.
loc_a1ae:                              ; >a1ae
       li   hl,digit_charset           ; LD HL,$BFCC       ; 
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   hl,>50C8                   ; LD HL,$50C8       ;

* print player score at position HL
* 
* Used by the routine at #R$9641.
print_score:                           ; >a1b7
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       li   de,score_bcd               ; LD DE,$5E2A       ; 
       movb @bytes+>03,b               ; LD B,$03          ; 3 bytes = 6 digits
* This entry point is used by the routines at #R$9607, #R$9641 and #R$a1c9.
print_bcd_bytes:                       ; >a1bf
       movb *de,a                      ; LD A,(DE)         ; print B BCD bytes at DE
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 
       ; RRCA                          ; RRCA              ; 
       srl  a,4
       andi a,>0f00                    ; AND $0F           ;
       .call @print_char               ; CALL $A1D3        ; print a single character

* print a single BCD digit
* 
* Used by the routine at #R$9607.
print_bcd_digit:                       ; >a1c9
       movb *de,a                      ; LD A,(DE)         ; 
       andi a,>0f00                    ; AND $0F           ; 
       .call @print_char               ; CALL $A1D3        ; print a single character
       inc  de                         ; INC DE            ; 
       sb   one,b                      ; DJNZ $A1BF        ; print B BCD bytes at DE
       jne  print_bcd_bytes            ;                   
       .endproc                        ; RET               ;

* print a single character
* 
* Used by the routines at #R$a1b7, #R$a1c9, #R$a1f3 and #R$a219.
*
* a: character to print
* hl: screen address
*
print_char:                            ; >a1d3
       seto @background_graphics_rom_bank
       .push bc                        ; PUSH BC           ;
       .push de                        ; PUSH DE           ; 
;      .push hl                        ; PUSH HL           ;
       movb a,@e                       ; LD L,A            ;
       sb   d,d                        ; LD H,$00          ;
;      a    hl,hl                      ; ADD HL,HL         ;
;      a    hl,hl                      ; ADD HL,HL         ;
;      a    hl,hl                      ; ADD HL,HL         ;
       sla  de,3
       a    @charset_addr,de           ; LD DE,($5E01)     ;
;      a    de,hl                      ; ADD HL,DE         ;
;      .ex_de_hl                       ; EX DE,HL          ;
;      .pop hl                         ; POP HL            ;
       movb @bytes+>08,b               ; LD B,$08          ; 8 lines in character cell
loc_a1e5:                              ; >a1e5
       movb *de+,*hl                   ; LD A,(DE)         ;
;      movb a,*hl                      ; LD (HL),A         ;
;      inc  de                         ; INC DE            ; next source byte
       ab   one,h                      ; INC H             ; next pixel line
       sb   one,b                      ; DJNZ $A1E5        ; 
       jne  loc_a1e5                   ;                   
       .pop de                         ; POP DE            ; 
       .pop bc                         ; POP BC            ; 
;      movb h,a                        ; LD A,H            ;
       sb   @bytes+>08,h               ; SUB $08           ; back to start address
;      movb a,h                        ; LD H,A            ;
       ab   one,@l                     ; INC L             ; next position to the right
       .ret                            ; RET               ; 

* show a line of text, first byte is attr
* 
* Used by the routines at #R$7caf, #R$8c35, #R$9641 and #R$96c9.
*
* hl: y,x coordinates
* de: text to print, prefixed by attribute
*
colour_text:                           ; >a1f3
       .proc
       jmp  !
colour_text_jump_target:
!      .push hl                        ; PUSH HL           ;
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       movb *de,a                      ; LD A,(DE)         ; text attr colour
       .ex_af_af_                      ; EX AF,AF'         ; 
       inc  de                         ; INC DE            ; 
       .exx                            ; EXX               ; display addr in HL
       .pop hl                         ; POP HL            ; 
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
* This entry point is used by the routine at #R$7d8a.
loc_a1ff:                              ; >a1ff
       .exx                            ; EXX               ; attr addr in HL'
       movb *de,a                      ; LD A,(DE)         ; 
       movb a,r0                       ; BIT 7,A           ; last character?
       andi r0,>8000                   ;                   
       jne  loc_a210                   ; JR NZ,$A210       ; jump if so
       .call @print_char               ; CALL $A1D3        ; print a single character
       inc  de                         ; INC DE            ; 
       .exx                            ; EXX               ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb a,*hl                      ; LD (HL),A         ; set attr
       ab   one,@l                     ; INC L             ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       jmp  loc_a1ff                   ; JR $A1FF          ; 
loc_a210:                              ; >a210
       andi a,>7f00                    ; AND $7F           ; strip end marker b7
       .call @print_char               ; CALL $A1D3        ; print a single character
       .exx                            ; EXX               ; 
       .ex_af_af_                      ; EX AF,AF'         ; 
       movb a,*hl                      ; LD (HL),A         ; set attr
       .endproc                        ; RET               ;

* draw side panel background scroll
* 
* Used by the routine at #R$7d9a.
draw_side_panel:                       ; >a219
       .proc
       seto @background_graphics_rom_bank
       li   hl,panel_chars             ; LD HL,$B03A       ;
       mov  hl,@charset_addr           ; LD ($5E01),HL     ; 
       li   hl,>00c0                   ; LD HL,$00C0       ; 
       li   de,panel_data              ; LD DE,$B32A       ; 
       li   bc,>0818                   ; LD BC,$0818       ; 8x24
loc_a228:                              ; >a228
       .push bc                        ; PUSH BC           ; 
       .push hl                        ; PUSH HL           ; 
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
loc_a22d:                              ; >a22d
       movb *de+,a                     ; LD A,(DE)         ;
;      inc  de                         ; INC DE            ;
       .call @print_char               ; CALL $A1D3        ; print a single character
       sb   one,b                      ; DJNZ $A22D        ; 
       jne  loc_a22d                   ;                   
       .pop hl                         ; POP HL            ; 
       movb h,a                        ; LD A,H            ; 
       ab   @bytes+>08,a               ; ADD A,$08         ; 
       movb a,h                        ; LD H,A            ; 
       .pop bc                         ; POP BC            ; 
       sb   one,@c                     ; DEC C             ; 
       jne  loc_a228                   ; JR NZ,$A228       ;
       b    @loc_a1ae                  ; JP $A1AE          ;

* draw side-panel colours, which follow room colour
* 
* Used by the routine at #R$9117.
draw_panel_attrs:                      ; >a240
       .proc
       li   hl,>00c0                   ; LD HL,$00C0       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       li   bc,>0818                   ; LD BC,$0818       ; 8x24
       movb @room_attr,a               ; LD A,($5E1A)      ; 
       inv  a                          ; CPL               ; invert for colour contrast
       andi a,>0700                    ; AND $07           ; 
       cb   a,@bytes+>02               ; CP $02            ; 
       jhe  loc_a255                   ; JR NC,$A255       ; red or brighter?
       movb @bytes+>44,a               ; LD A,$44          ; change blue to bright green
loc_a255:                              ; >a255
       movb a,@e                       ; LD E,A            ; save attr value
       .push de                        ; PUSH DE           ; 
loc_a257:                              ; >a257
       .push bc                        ; PUSH BC           ; 
       .push hl                        ; PUSH HL           ; 
loc_a259:                              ; >a259
       movb @e,*hl                     ; LD (HL),E         ; set panel attr
       ab   one,@l                     ; INC L             ; 
       sb   one,b                      ; DJNZ $A259        ; 
       jne  loc_a259                   ;                   
       .pop hl                         ; POP HL            ; 
       li   bc,>0020                   ; LD BC,$0020       ; line pitch
       a    bc,hl                      ; ADD HL,BC         ; down a row
       .pop bc                         ; POP BC            ; 
       sb   one,@c                     ; DEC C             ; 
       jne  loc_a257                   ; JR NZ,$A257       ;
;      Now set special attributes
       li   hl,>90c8                   ; LD HL,$90C8       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       movb @room_attr,a               ; LD A,($5E1A)      ;
       li   bc,>0303                   ; LD BC,$0303       ; 3x3 (rosette body)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       ab   one,@l                     ; INC L             ; 
       movb a,*hl                      ; LD (HL),A         ; 
       a    de,hl                      ; ADD HL,DE         ; 
       li   bc,>0202                   ; LD BC,$0202       ; 2x2 (rosette tail)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   hl,>98d0                   ; LD HL,$98D0       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       .pop de                         ; POP DE            ; 
       movb @e,*hl                     ; LD (HL),E         ; rosette centre
       li   hl,>7dc8                   ; LD HL,$7DC8       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       li   bc,>0603                   ; LD BC,$0603       ; 6x3
       movb @bytes+>47,a               ; LD A,$47          ; bright white (lives)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   hl,>5fc8                   ; LD HL,$5FC8       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       li   bc,>0604                   ; LD BC,$0604       ; 6x4
       movb @bytes+>46,a               ; LD A,$46          ; bright yellow (chicken)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   hl,>48C8                   ; LD HL,$48C8       ;
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       li   bc,>0601                   ; LD BC,$0601       ; 6x1
       movb @bytes+>45,a               ; LD A,$45          ; bright cyan (score caption)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   bc,>0601                   ; LD BC,$0601       ; 6x1
       movb @bytes+>47,a               ; LD A,$47          ; bright white (score)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   hl,>38c8                   ; LD HL,$38C8       ; 
       .call @xy_to_attr               ; CALL $9BD2        ; convert pixel coords in HL to attribute address
       li   bc,>0601                   ; LD BC,$0601       ; 6x1
       movb @bytes+>43,a               ; LD A,$43          ; bright magenta (time caption)
       .call @fill_bc_hl_a             ; CALL $809A        ; fill C rows of B columns of value A at address HL
       li   bc,>0601                   ; LD BC,$0601       ; 
       movb @bytes+>47,a               ; LD A,$47          ; bright white (time)
       .call @fill_bc_hl_a             ; JP $809A          ; fill C rows of B columns of value A at address HL
       .endproc

* draw lives sprites in side panel
* 
* Used by the routines at #R$7d9a and #R$9443.
draw_lives:                            ; >a2ce
       .proc
draw_lives_branch:
       seto @sprite_graphics_rom_bank
       .push ix                        ; PUSH IX           ;
       li   ix,entity_to_draw          ; LD IX,$A17D       ; 
       movb @menu_selection,a          ; LD A,($5E00)      ; 
       sla  a,1                        ; RLCA              ;
       andi a,>3000                    ; AND $30           ; extract character type from menu
       socb one,a                      ; OR $01            ; offset to first graphic
       movb a,*ix                      ; LD (IX+$00),A     ; character type
       movb @bytes+>47,@>05(ix)        ; LD (IX+$05),$47   ; bright white
       li   hl,>8dc8                   ; LD HL,$8DC8       ; coords of lives in side panel
       movb @l,@>03(ix)                ; LD (IX+$03),L     ; 
       movb h,@>04(ix)                 ; LD (IX+$04),H     ; 
       movb @lives,@c                  ; LD A,($5E21)      ;
;       movb a,@c                      ; LD C,A            ; number of lives to show
       movb @bytes+>03,b               ; LD B,$03          ; up to 3 lives to draw
loc_a2f2:                              ; >a2f2
       .push bc                        ; PUSH BC           ; 
       .call @clear_sprite             ; CALL $A185        ; clear lives location
       movb @c,a                       ; LD A,C            ; 
       ; AND A                         ; AND A             ; life to show?
       jeq  loc_a2fd                   ; JR Z,$A2FD        ; jump if not
       .call @draw_entity              ; CALL $9F4A        ; draw player character
loc_a2fd:                              ; >a2fd
;      movb @>03(ix),a                 ; LD A,(IX+$03)     ;
       ab   @bytes+>10,@>03(ix)        ; ADD A,$10         ; offset to next life position
;      movb a,@>03(ix)                 ; LD (IX+$03),A     ;
       .pop bc                         ; POP BC            ;
       cb   @c,@zero
       jeq  loc_a30c
       sb   one,@c                     ; DEC C             ;
;       jlt  loc_a30c                   ; JP P,$A30C        ;
;       sb   @c,@c                      ; LD C,$00          ; min lives is zero
loc_a30c:                              ; >a30c
       sb   one,b                      ; DJNZ $A2F2        ; draw remaining slots
       jne  loc_a2f2                   ;                   
       .pop ix                         ; POP IX            ; 
       .endproc                        ; RET               ;
