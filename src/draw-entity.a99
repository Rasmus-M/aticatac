*********************************************************************
*
* return address of sprite @saved_graphic in DE
*
* Used by the routine at #R$9f80.
*
get_saved_sprite_addr:                 ; >9e86
       movb @saved_graphic,a           ; LD A,($5E15)      ;
*
* return address of sprite A in DE
*
* Used by the routines at #R$8cb7, #R$8d45, #R$8e26 and #R$9e96.
*
get_sprite_addr:                       ; >9e89
       seto @sprite_graphics_rom_bank
       sb   one,a                      ; DEC A             ; one-based
       sb   h,h
       movb a,@l                       ; LD L,A            ;
;      sb   h,h                        ; LD H,$00          ;
;      a    hl,hl                      ; ADD HL,HL         ;
;      li   bc,sprite_table            ; LD BC,$A4BE       ;
;      a    bc,hl                      ; ADD HL,BC         ;
;      movb *hl,@e                     ; LD E,(HL)         ;
;      inc  hl                         ; INC HL            ;
;      movb *hl,d                      ; LD D,(HL)         ;
       sla  hl,1
       mov @sprite_table(hl),de
       .ret                            ; RET               ;
*
* return addr of entity sprite addr in DE
*
* Used by the routine at #R$9f9f.
get_sprite_addr_ix:                    ; >9e96
       movb *ix,a                      ; LD A,(IX+$00)     ;
       jmp  get_sprite_addr            ; JR $9E89          ; return address of sprite A in DE
*// get_sprite_addr

*********************************************************************
*
* This entry point is used by the routines at #R$9f4a, #R$9f56 and #R$9fca.
* Branch target
*
draw_sprite:                           ; >9e9b
       movb @c,a                       ; LD A,C            ;
       ; AND A                         ; AND A             ;
       jeq  _draw_sprite_3             ; JR Z,$9EAF        ;
       sb   one,@c                     ; DEC C             ;
       .call @draw_sprite_line23       ; CALL $9EDC        ;
       .exx                            ; EXX               ;
       movb @c,a                       ; LD A,C            ;
       ; AND A                         ; AND A             ;
       jeq  _draw_sprite_2             ; JR Z,$9EAC        ;
_draw_sprite_1:                        ; >9ea8
       sb   one,@c                     ; DEC C             ;
       .call @draw_sprite_line2        ; CALL $9F21        ;
_draw_sprite_2:                        ; >9eac
       .exx                            ; EXX               ;
       jmp  draw_sprite                ; JR $9E9B          ;
_draw_sprite_3:                        ; >9eaf             ; c is 0
       .exx                            ; EXX               ;
       movb @c,a                       ; LD A,C            ;
       ; AND A                         ; AND A             ;
       jne  _draw_sprite_1             ; JR NZ,$9EA8       ;
* This entry point is used by the routine at #R$9fca.
entry_from_draw_entity_32_2:           ; >9eb4
       .exx                            ; EXX               ;
* This entry point is used by the routine at #R$9fca.
entry_from_draw_entity_23_1:           ; >9eb5
       movb @height23,a                ; LD A,($5E18)      ;
       movb a,@c                       ; LD C,A            ;
       movb @height2,a                 ; LD A,($5E19)      ;
       socb @c,a                       ; OR C              ; both heights zero?
       jne  !                          ; RET Z             ; return if so
       .endproc                        ;
!
       sb   a,a                        ; XOR A             ;
       movb a,@height23                ; LD ($5E18),A      ;
       .exx                            ; EXX               ;
       movb @height2,a                 ; LD A,($5E19)      ;
       movb a,@c                       ; LD C,A            ;
       sb   a,a                        ; XOR A             ;
* This entry point is used by the routine at #R$9fca.
entry_from_draw_entity_32_3:           ; >9ec8
       movb a,@height2                 ; LD ($5E19),A      ;
       .exx                            ; EXX               ;
       jmp  draw_sprite                ; JR $9E9B          ;
*// draw_sprite_2_or_23

*********************************************************************
*
* Routine at 9ece
*
* hl=data bytes, de=data addr, screen address on stack
*
draw_unshifted23:                      ; >9ece
       .ex_de_hl                       ; EX DE,HL          ; hl=data addr, de=data bytes
       .ex_sp_hl                       ; EX (SP),HL        ; hl=screen addr, stack=data addr
*      First byte
       movb d,a                        ; LD A,D            ;
       ; XOR (HL)                      ; XOR (HL)          ;
       movb *hl,r0
       xor  r0,a
       movb a,*hl                      ; LD (HL),A         ;
*      Second byte
       ab   one,@l                     ; INC L             ;
       movb @e,a                       ; LD A,E            ;
       ; XOR (HL)                      ; XOR (HL)          ;
       movb *hl,r0
       xor  r0,a
       movb a,*hl                      ; LD (HL),A         ;
*      Next line
       .pop de                         ; POP DE            ;
       sb   one,@l                     ; DEC L             ;
       b    @pixel_line_up_branch      ; JP $9F03          ; move up 1 display line in HL

*********************************************************************
*
* Routine at 9edc
*
* Used by the routine at #R$9e96.
*
* de: sprite data address
* hl: screen address
*
draw_sprite_line23:                    ; >9edc
       .proc
       .ex_de_hl                       ; EX DE,HL          ; Now de=screen addr and hl=data addr
       .push de                        ; PUSH DE           ; Push screen address
       movb *hl+,d                     ; LD D,(HL)        ; Get data byte
;      inc  hl                         ; INC HL            ;
       movb *hl+,@e                    ; LD E,(HL)        ; Get data byte
;      inc  hl                         ; INC HL            ;
       .ex_de_hl                       ; EX DE,HL          ; Now hl=data bytes and de=data addr
       sb   a,a                        ; XOR A             ;
       movb h,@f                       ; Added, for shifting into a
jr_23:                                 ; >9ee4
       nop                             ; JR $9EE4          ; Self-modified, can jump to draw_unshifted23
                                                           ; or into the instructions below
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       .ex_de_hl                       ; EX DE,HL          ;
       .ex_sp_hl                       ; EX (SP),HL        ;
*      First byte
       ; XOR (HL)                      ; XOR (HL)          ;
       movb *hl,r0
       xor  r0,a
       movb a,*hl                      ; LD (HL),A         ;
       ab   one,@l                     ; INC L             ;
* This entry point is used by the routine at #R$9f21.
* Branch target
draw_2_bytes:                          ; >9ef9
*      Second byte
       movb d,a                        ; LD A,D            ;
       ; XOR (HL)                      ; XOR (HL)          ;
       movb *hl,r0
       xor  r0,a
       movb a,*hl                      ; LD (HL),A         ;
       ab   one,@l                     ; INC L             ;
*      Third byte
       movb @e,a                       ; LD A,E            ;
       ; XOR (HL)                      ; XOR (HL)          ;
       movb *hl,r0
       xor  r0,a
       movb a,*hl                      ; LD (HL),A         ;
*      Next line
       .pop de                         ; POP DE            ;
       sb   one,@l                     ; DEC L             ;
       sb   one,@l                     ; DEC L             ;
       b    @pixel_line_up_branch

*********************************************************************
* draw 2-byte unshifted graphic
*
* Used by the routine at #R$9f21.
*
* hl=data bytes, de=data addr, screen address on stack
*
draw_unshifted2:                       ; >9f13
       .ex_de_hl                       ; EX DE,HL          ; hl=data addr, de=data bytes
       .ex_sp_hl                       ; EX (SP),HL        ; hl=screen addr, stack=data addr
*      First byte
       movb d,a                        ; LD A,D            ;
       ; XOR (HL)                      ; XOR (HL)          ;
       movb *hl,r0
       xor  r0,a
       movb a,*hl                      ; LD (HL),A         ;
*      Second byte
       ab   one,@l                     ; INC L             ;
       movb @e,a                       ; LD A,E            ;
       ; XOR (HL)                      ; XOR (HL)          ;
       movb *hl,r0
       xor  r0,a
       movb a,*hl                      ; LD (HL),A         ;
*      Next line
       .pop de                         ; POP DE            ; de=data addr
       sb   one,@l                     ; DEC L             ;
       b    @pixel_line_up_branch      ; JP $9F03        ; move up 1 display line in HL

*********************************************************************
*
* Routine at 9f21
*
* Used by the routine at #R$9e96.
*
* de: sprite data address
* hl: screen address
*
; TODO: This is identical to draw_sprite_line23
draw_sprite_line2:                     ; >9f21
       .proc
       .ex_de_hl                       ; EX DE,HL          ; Now de=screen addr and hl=data addr
       .push de                        ; PUSH DE           ; Push screen address
       movb *hl+,d                     ; LD D,(HL)         ; Get data byte
;      inc  hl                         ; INC HL            ;
       movb *hl+,@e                    ; LD E,(HL)         ; Get data byte
;      inc  hl                         ; INC HL            ;
       .ex_de_hl                       ; EX DE,HL          ; Now hl=data bytes and de=data addr
       sb   a,a                        ; XOR A             ;
       movb h,@f                       ; Added, for shifting into a
jr_2:                                  ; >9f29
       nop                             ; JR $9F13          ; Self-modified, can jump to draw_unshifted2
                                                           ; or into the instructions below
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       sla  hl,1                       ; ADD HL,HL         ;
       sla  af,1                       ; ADC A,A           ;
       .ex_de_hl                       ; EX DE,HL          ;
       .ex_sp_hl                       ; EX (SP),HL        ;
*      First byte
       ; XOR (HL)                      ; XOR (HL)          ;
       movb *hl,r0
       xor  r0,a
       movb a,*hl                      ; LD (HL),A         ; first byte
       ab   one,@l                     ; INC L             ;
*      Second and third bytes
       jmp  draw_2_bytes               ; JR $9EF9          ;

;*********************************************************************
;*
;* Routine at 9f40
;draw2_entity:                          ; >9f40
;       .call @prepare_draw2_de         ; CALL $9FA2        ;
;       jmp  draw_entity_de             ; JR $9F4D          ;
;
;* Routine at 9f45
;undraw_entity_de:                      ; >9f45
;       .call @prepare_draw23_de        ; CALL $9F83        ;
;       jmp  loc_9f59                   ; JR $9F59          ;

*********************************************************************
*
* draw entity graphic (no attrs)
*
* Used by the routines at #R$814b, #R$83ea, #R$871a, #R$8862, #R$8aff, #R$8cb7,
* #R$9291, #R$9358, #R$9443, #R$95cc, #R$a14d, #R$a2ce and #R$a311.
*
* ix: entity
*
draw_entity:                           ; >9f4a
       .proc
       seto @sprite_graphics_rom_bank
       .call @prepare_draw2            ; CALL $9F9F        ; prepare for 2-byte drawing
* This entry point is used by the routine at #R$9f40.
draw_entity_de:                        ; >9f4d
       .exx                            ; EXX               ;
       sb   a,a                        ; XOR A             ;
       movb a,@height23                ; LD ($5E18),A      ;
       movb a,@c                       ; LD C,A            ;
       b    @draw_sprite               ; JP $9E9B          ;
*      Expecting draw_sprite to ret
*// draw_entity

*********************************************************************
*
* Routine at 9f56
*
* Used by the routines at #R$81f0, #R$871a, #R$8c63, #R$9326 and #R$98c8.
undraw_entity:                         ; >9f56
       .call @prepare_draw23           ; CALL $9F80        ; prepare for 2-3 byte drawing
* This entry point is used by the routine at #R$9f45.
loc_9f59:                              ; >9f59
       .exx                            ; EXX               ;
       sb   a,a                        ; XOR A             ;
       movb a,@c                       ; LD C,A            ;
       movb a,@height2                 ; LD ($5E19),A      ;
       movb @height23,a                ; LD A,($5E18)      ;
       movb a,@height_lines            ; LD ($5E11),A      ;
       movb @l,a                       ; LD A,L            ;
       andi a,>0700                    ; AND $07           ; aligned to cell boundary?
       movb @bytes+>02,a               ; LD A,$02          ; 2 bytes wide
       jeq  loc_9f6d                   ; JR Z,$9F6D        ; jump if so
       ab   one,a                      ; INC A             ; 3 bytes needed
loc_9f6d:                              ; >9f6d
       movb a,@width_bytes             ; LD ($5E10),A      ;
       .exx                            ; EXX               ;
       b    @draw_sprite               ; JP $9E9B          ;
       .push de                        ; PUSH DE           ;
       .call @prepare_draw23_de        ; CALL $9F83        ;
       .exx                            ; EXX               ;
       .pop de                         ; POP DE            ;
       .call @prepare_draw2_de         ; CALL $9FA2        ;
       .exx                            ; EXX               ;
       jmp  draw_entity_23_1                   ; JR $9FD1          ;

*********************************************************************
*
* prepare draw_sprite_line23 for drawing
*
* Used by the routines at #R$9f56 and #R$9fca.
prepare_draw23:                        ; >9f80
       .proc
       .call @get_saved_sprite_addr    ; CALL $9E86        ; return address of sprite A in DE
       jmp  !
* This entry point is used by the routines at #R$9f45 and #R$9f56.
prepare_draw23_de:                     ; >9f83
       .proc
!
;       mov  @saved_x,hl
       movb @saved_x,@l                ; LD HL,($5E16)     ;
       movb @saved_y,h
       movb @l,a                       ; LD A,L            ; xpos (b2-0 determine shifting)
       sb   one,a                      ; DEC A             ;
       sla  a,1                        ; RLCA              ; * 2 (bytes per
       andi a,>0e00                    ; AND $0E           ; relative jump offset)
       cb   a,@bytes+>0e               ; CP $0E            ; originally unshifted?
       jne  loc_9f91                   ; JR NZ,$9F91       ; jump if not (use calculated offset)
       li   a,(draw_unshifted23-jr_23-2)/2*256 ; LD A,$E8 jr offset back to 'draw_unshifted'
loc_9f91:                              ; >9f91
       movb a,@jr_23+1                 ; LD ($9EE5),A      ; set jr offset for data shifting
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       movb *de,a                      ; LD A,(DE)         ; Get height (but it's now de_?)
       movb a,@height23                ; LD ($5E18),A      ; Save height
       sb   @c,@c                      ; LD C,$00          ;
       inc  de                         ; INC DE            ; Advance to bitmap data
       .endproc                        ; RET               ;

*********************************************************************
*
* prepare draw_sprite_line2 drawing
*
* Used by the routines at #R$9f4a and #R$9fca.
prepare_draw2:                         ; >9f9f
       .proc
       .call @get_sprite_addr_ix        ; CALL $9E96        ; return addr of entity sprite addr in DE
       jmp  !
* This entry point is used by the routines at #R$9f40 and #R$9f56.
prepare_draw2_de:                      ; >9fa2
       .proc
!      movb @entity_x(ix),@l           ; LD L,(IX+$03)     ; x
       movb @entity_y(ix),h            ; LD H,(IX+$04)     ; y
       movb @l,a                       ; LD A,L            ; xpos (b2-0 determine shifting)
       sb   one,a                      ; DEC A             ;
       sla  a,1                        ; RLCA              ; * 2 (bytes per
       andi a,>0e00                    ; AND $0E           ; relative jump offset)
       movb a,r0
       cb   a,@bytes+>0e               ; CP $0E            ; originally unshifted?
       jne  loc_9fb3                   ; JR NZ,$9FB3       ; jump if not (use calculated offset)
       li   a,(draw_unshifted2-jr_2-2)/2*256              ; LD A,$E8 jr offset back to 'draw_unshifted_2'
loc_9fb3:                              ; >9fb3
       movb a,@jr_2+1                  ; LD ($9F2A),A      ; set jr offset for data shifting
       movb @bytes+>02,a               ; LD A,$02          ; 2 bytes wide
       cb   r0,@bytes+>0e
       jeq  loc_9fbb                   ; JR Z,$9FBB        ;
       ab   one,a                      ; INC A             ; any shift requires 3 bytes
loc_9fbb:                              ; >9fbb
       movb a,@width_bytes             ; LD ($5E10),A      ;
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       movb *de,a                      ; LD A,(DE)         ; Get height
       movb a,@height2                 ; LD ($5E19),A      ; Save height
       movb a,@height_lines            ; LD ($5E11),A      ; Save height
       sb   @c,@c                      ; LD C,$00          ;
       inc  de                         ; INC DE            ; Advance to bitmap data
       .endproc                        ; RET               ;

*********************************************************************
*
* draw entity to display (no attrs)
*
* Used by the routine at #R$8e26.
draw_entity_23:                        ; >9fca
       .proc
       seto @sprite_graphics_rom_bank
       .call @prepare_draw2            ; CALL $9F9F        ; prepare for 2-byte drawing
       .exx                            ; EXX               ;
       .call @prepare_draw23           ; CALL $9F80        ; prepare for 2-3 byte drawing
* This entry point is used by the routine at #R$9f56.
draw_entity_23_1:                      ; >9fd1
       movb @saved_y,a                 ; LD A,($5E17)      ;
       sb   @entity_y(ix),a            ; SUB (IX+$04)      ;
       jne  !                          ; JP Z,$9EB5        ;
*      If y is the same
       b    @entry_from_draw_entity_23_1                   ;
!
       jgt  draw_entity_23_2           ; JP M,$9FEC        ;
*      If new y is smaller
       movb a,@c                       ; LD C,A            ; Difference in y
       movb @height23,a                ; LD A,($5E18)      ; Height from graphics
       cb   a,@c                       ; CP C              ;
       jhe  !                          ; JP C,$9EB5        ;
       b    @entry_from_draw_entity_23_1                   ; If height23 < difference in y
!
       sb   @c,a                       ; SUB C             ; difference in y - height23
       movb a,@height23                ; LD ($5E18),A      ;
       b    @draw_sprite               ; JP $9E9B          ;
*      If new y is greater
draw_entity_23_2:                      ; >9fec
       .exx                            ; EXX               ;
       neg a                           ; NEG               ; - Difference in y
       movb a,@c                       ; LD C,A            ;
       movb @height2,a                 ; LD A,($5E19)      ;
       cb   a,@c                       ; CP C              ;
       jhe  !                          ; JP C,$9EB4        ;
       b    @entry_from_draw_entity_32_2                   ;
!
       sb   @c,a                       ; SUB C             ;
       b    @entry_from_draw_entity_32_3 ; JP $9EC8          ;

*********************************************************************
*
* save entity position for undraw
*
* Used by the routines at #R$81db, #R$81f0, #R$82f1, #R$8301, #R$845f, #R$85f7,
* #R$862e, #R$8672, #R$871a, #R$8787, #R$87a6, #R$8862, #R$8906, #R$8988,
* #R$89ed, #R$8a2f, #R$8a80, #R$8aff, #R$8c63, #R$8d77, #R$92f5 and #R$988b.
save_entity:                           ; >9ffb
       movb @entity_x(ix),@saved_x     ; LD A,(IX+$03)     ;
;      movb a,@saved_x                 ; LD ($5E16),A      ;
       movb @entity_y(ix),@saved_y     ; LD A,(IX+$04)     ;
;      movb a,@saved_y                 ; LD ($5E17),A      ;
       movb *ix,@saved_graphic         ; LD A,(IX+$00)     ;
;      movb a,@saved_graphic           ; LD ($5E15),A      ;
       .ret                            ; RET               ;

*********************************************************************
*
* Routine at a185
*
* Used by the routines at #R$a14d and #R$a2ce.
clear_sprite:                          ; >a185
       .proc
       movb @>03(ix),@l                ; LD L,(IX+$03)     ;
       movb @>04(ix),h                 ; LD H,(IX+$04)     ;
       .call @xy_to_display            ; CALL $9BA2        ; convert coords in HL to display address in HL
       movb @bytes+>14,b               ; LD B,$14          ; 20 pixels high
loc_a190:                              ; >a190
       sb   *hl,*hl                    ; LD (HL),$00       ; clear 2 bytes wide
       ab   one,@l                     ; INC L             ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       sb   one,@l                     ; DEC L             ;
       .call @pixel_line_up            ; CALL $9F03        ; move up 1 display line in HL
       sb   one,b                      ; DJNZ $A190        ;
       jne  loc_a190                   ;
       .endproc                        ; RET               ;
