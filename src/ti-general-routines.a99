*********************************************************************
*
* Setup environment
*
ti_setup_environment:
       mov  @rndsd,@rnd_seed
       li   one,>0100
       li   r0,>fffe
       mov  r0,@b255
       clr  @frame
       li   sp,stack
       .proc
       bl   @init_bits
       bl   @copy_to_pad
       bl   @graphics_mode
       .endproc
*// ti_setup_environment

*********************************************************************
*
* Init bits for bit operations
*
init_bits:
       li   r0,>0100
       li   r1,bits
       li   r2,8
init_bits_1:
       movb r0,*r1+
       sla  r0,1
       dec  r2
       jne  init_bits_1
       rt
*// init_bits

*********************************************************************
*
* Copy routines to pad
*
copy_to_pad:
;       li   r0,draw_display_buffer_start
;       li   r1,draw_display_buffer_pad
;       li   r2,draw_display_buffer_end-draw_display_buffer_start
;copy_to_pad_1:
;       mov  *r0+,*r1+
;       dect r2
;       jne  copy_to_pad_1
       rt
*// copy_to_pad

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       lwpi ti_wrksp
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@ti_r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Disable sprites
       li   r0,sprite_attr_table
       li   r1,>d000
       bl   @vsbw
*      Init color table
       li   r0,color_table
       li   r1,>f100
       li   r2,>1800
       bl   @vsmw
*      Init name tables
       li   r0,name_table
       bl   @vwad
       bl   @ti_init_name_table
       li   r0,name_table_2
       bl   @vwad
       bl   @ti_init_name_table
*      Sprite patterns
;       li   r0,sprite_pattern_table
;       li   r1,SPR0
;       li   r2,32
;       bl   @vmbw
       lwpi wrksp
       rt
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte name_table/>400            ; Name table
       byte >ff                        ; Color table
       byte pattern_table/>800+>03     ; Pattern table
       byte sprite_attr_table/>80      ; Sprite attribute table
       byte sprite_pattern_table/>800  ; Sprite pattern table
       byte >00                        ; Backdrop color
*// graphics_mode

*********************************************************************************
*
* Initialize name table for bitmap drawing
*
ti_init_name_table:
       clr  r1
       li   r2,768
ti_init_name_table_1:
       movb r1,@vdpwd
       ai   r1,>0100
       dec  r2
       jne  ti_init_name_table_1
       rt
*// ti_init_name_table

;*********************************************************************************
;*
;* Select name table 1
;*
;ti_select_name_table_1:
;       lwpi ti_wrksp
;       li   r0,>020e
;       bl   @vwtr
;       lwpi wrksp
;       rt
;*// ti_select_name_table_1
;
;*********************************************************************************
;*
;* Select name table 2
;*
;ti_select_name_table_2:
;       lwpi ti_wrksp
;       li   r0,>020f
;       bl   @vwtr
;       lwpi wrksp
;       rt
;*// ti_select_name_table_2

*********************************************************************************
*
* Display off
*
ti_display_off:
       lwpi ti_wrksp
       li   r0,>01a2
       bl   @vwtr
       lwpi wrksp
       rt
*// ti_display_off

*********************************************************************************
*
* Display off
*
ti_display_on:
       lwpi ti_wrksp
       li   r0,>01e2
       bl   @vwtr
       lwpi wrksp
       rt
*// ti_display_on

*********************************************************************************
*
* Clear screen
*
ti_clear_screen:
       .proc
       bl   @ti_display_off
;       bl   @module_player
       li   r1,vdpwd
       li   r0,pattern_table
       bl   @vwad
       bl   @ti_clear_screen_part
       bl   @ti_clear_screen_part
       bl   @ti_clear_screen_part
       li   r0,color_table
       bl   @vwad
       bl   @ti_clear_screen_part
       bl   @ti_clear_screen_part
       bl   @ti_clear_screen_part
       bl   @ti_display_on
       .endproc
*// ti_clear_screen

ti_clear_screen_part:
       .proc
       li   r2,>800
ti_clear_screen_part_1:
       clr  *r1
       dec  r2
       jne  ti_clear_screen_part_1
;       bl   @module_player
       .endproc

*********************************************************************************
*
* Set color of whole screen
*
* a: zx attribute
*
ti_set_screen_color:
       .proc
       bl   @ti_color
       movb r0,r1
       li   r0,color_table+(3*256)
       li   r2,5*256
       bl   @vsmw
;       bl   @module_player
       li   r0,color_table+(8*256)
       li   r2,5*256
       bl   @vsmw
;       bl   @module_player
       li   r0,color_table+(13*256)
       li   r2,5*256
       bl   @vsmw
;       bl   @module_player
       .endproc
*// ti_set_screen_color

*********************************************************************************
*
* Set border color
*
* a: zx color
*
ti_set_border_color:
       .proc
       bl   @ti_color
       srl  r0,12
       ori  r0,>0700
       bl   @vwtr
       .endproc
*// ti_set_border_color

*********************************************************************
*
* Draw graphics
*
* r0 (r13): VDP address
* r1 (r14): Source address
* r2 (r15) MSB: width in characters
* r2 (r15) LSB: height in characters
*
ti_draw_graphics:
       .proc
       lwpi ti_wrksp
       mov  r13,r0
       mov  r14,r1
       mov  r15,r2                     ; Width and height
       andi r2,>00ff                   ; Height
       mov  r15,r4                     ; Width and height
       srl  r4,8                       ; Width
       mov  @row_src_skip,r5
       li   r6,vdpwd
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
ti_draw_graphics_1:
       movb @ti_r0lb,@vdpwa            ; Send low byte of VDP RAM write address
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       mov  r4,r3                      ; Width in characters
ti_draw_graphics_2:
       movb *r1+,*r6
       movb *r1+,*r6
       movb *r1+,*r6
       movb *r1+,*r6
       movb *r1+,*r6
       movb *r1+,*r6
       movb *r1+,*r6
       movb *r1+,*r6
       dec  r3
       jne  ti_draw_graphics_2
       ai   r0,256                     ; Next character row
       a    r5,r1                      ; Skip source bytes
       dec  r2
       jne  ti_draw_graphics_1
       lwpi wrksp
;       bl   @module_player
       .endproc
row_src_skip:
       data 0
*// ti_draw_graphics

*********************************************************************
*
* Draw color area
*
* r0 (r13): VDP offset in color table
* r1 (r14) LSB: ZX attribute to draw
* r2 (r15) MSB: width in characters
* r2 (r15) LSB: height in characters
*
ti_draw_color_area:
       .proc
       lwpi ti_wrksp
       mov  r13,r0
       mov  r14,r1
       movb @ti_colors(r1),r1
       mov  r15,r2                     ; Width and height
       andi r2,>00ff                   ; Height
       mov  r15,r4                     ; Width and height
       srl  r4,8                       ; Width
       li   r6,vdpwd
       ori  r0,>4000 + color_table     ; Set read/write bits 14 and 15 to write (01) + color table base
ti_draw_color_area_1:
       movb @ti_r0lb,@vdpwa            ; Send low byte of VDP RAM write address
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       mov  r4,r3                      ; Width in characters
ti_draw_color_area_2:
       movb r1,*r6
       movb r1,*r6
       movb r1,*r6
       movb r1,*r6
       movb r1,*r6
       movb r1,*r6
       movb r1,*r6
       movb r1,*r6
       dec  r3
       jne  ti_draw_color_area_2
       ai   r0,256                     ; Next character row
       dec  r2
       jne  ti_draw_color_area_1
       lwpi wrksp
;       bl   @module_player
       .endproc
*// ti_draw_color_area

*********************************************************************************
*
* Draw attribute
*
* a: zx attribute
* r1: address in zx attribute file
*
ti_draw_attribute:
*      VDP write address
       ai   r1,-zx_attrs
       sla  r1,3
       ai   r1,color_table+>4000
*      Set VDP write address
       movb @r1lb,@vdpwa               ; Send low byte of VDP RAM write address
       movb r1,@vdpwa                ; Send high byte of VDP RAM write address
*      Color
       swpb a
       movb @ti_colors(a),r0
       swpb a
*      Draw
       li   r2,vdpwd
       movb r0,*r2
       movb r0,*r2
       movb r0,*r2
       movb r0,*r2
       movb r0,*r2
       movb r0,*r2
       movb r0,*r2
       movb r0,*r2
       rt
*// ti_draw_attribute

*********************************************************************************
*
* Get TI-99 color from ZX Spectrum color
*
* a: Colour-byte FBPPPIII
*  - I - Ink colour (0-7)
*  - P - Paper colour (0-7)
*  - B - Bright (0-No, 1-Yes)
*  - F - Flash  (0-No, 1-Yes)
*
* On return r0 MSB contains the TI color FFFFBBBB.
*
ti_color:
       clr  r0                       ; Result
       mov  a,r2
       andi r2,>4000                 ; Bright bit
       srl  r2,3
*      Foreground
       mov  a,r1
       andi r1,>0700                 ; Foreground bits
       soc  r2,r1
       swpb r1
       movb @ti_pal(r1),r0
       sla  r0,4
*      Background
       mov  a,r1
       andi r1,>3800                 ; Background bits
       srl  r1,3
       soc  r2,r1
       swpb r1
       socb @ti_pal(r1),r0
       rt

* Spectrum palette
* 0  Black,    1 D Blue,   2 D Red,     3 D Magenta
* 4  D Green,  5 D Cyan,   6 D Yellow,  7 Grey
* 8  Black,    9 Blue,    10 Red,      11 Magenta
* 12 Green,   13 Cyan,    14 Yellow,   15 White

* TI palette
* 0  Trans,    1 Black,    2 M Green,   3 L Green
* 4  D Blue,   5 L Blue,   6 D Red,     7 Cyan
* 8  M Red,    9 L Red,   10 D Yellow, 11 L Yellow
* 12 D Green, 13 Magenta, 14 Gray,     15 White

ti_pal  byte 1,4,6,13,12,7,10,14,1,5,8,13,2,7,11,15
* Not used: 3 L Green, 9 L Red
* Not available: D Cyan, D Magenta
*// ti_color

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       rt
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       rt
*// vwad

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,@vdpwd                  ; Write byte to VDP RAM
       rt
*// vsbw

*********************************************************************
*
* VDP multiple Byte Write
*
* R0: Write address in VDP RAM
* R1: Starting read address in CPU RAM
* R2: Number of bytes to send
*
vmbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
vmbw_1:
       movb *r1+,*r0                   ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_1
       rt
*// vmbw

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
* R2: Number of bytes to write to VDP RAM
*
vsmw:
       swpb r0
       movb  r0,@vdpwa                 ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
vsmw_1:
       movb r1,*r0                     ; Write byte to VDP RAM
       dec  r2                         ; Byte counter
       jne  vsmw_1
       rt
*// vsmw

*********************************************************************
*
* VDP Set Read Address
*
* R0: Read address in VDP RAM
*
;vrad:
;       swpb r0
;       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
;       swpb r0
;       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
;       rt
;*// vrad

;*********************************************************************
;*
;* VDP Single Byte Read
;*
;* R0:  Read address in VDP RAM
;* R1:  MSB of R1 set to byte from VDP RAM
;*
;vsbr:
;       swpb r0
;       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
;       swpb r0
;       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
;       nop
;       movb @vdprd,r1                  ; Read byte from VDP RAM
;       rt
;*// vsbr

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       swpb r0
       movb  r0,@vdpwa                 ; Send low byte of VDP RAM read address
       swpb r0
       andi r0,>3fff                   ; Set read/write bits 14 and 15 to read (00)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       li   r0,vdprd
vmbr_1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr_1                     ; Check if finished
       rt
*// vmbr

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
ti_check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// ti_check_key

***************************************************************************
*
* Check quit
*
ti_check_quit:
       clr  r1                         ; Test column 0
       li   r12,>0024                  ; Address for column selection
       ldcr r1,3                       ; Select column
       li   r12,>0006                  ; Address to read rows
       stcr r1,8
       andi r1,>1100
       jeq  ti_quit
*      Return
       rt
*      Quit
ti_quit:
       clr  @>83c4                     ; Reset user ISR address
       seto @>6000                     ; Select first ROM bank
       blwp @>0000
*// ti_check_quit

*********************************************************************
*
* Scan keyboard
*
ti_keyscan:
       .proc
       lwpi gplws
       movb @zero,@kscan_device
       bl   @kscan
       lwpi wrksp
       movb @kscan_status,a
       andi a,>2000
       jeq  !
       movb @kscan_key,a
!      .endproc
*// ti_keyscan

*********************************************************************
*
* Generate a pseudo random number within the given limit
*
* a: Maximum number (0 - 255) exclusive
*
* On return a contains the number [0; a[
*
ti_rnd_range:
       .proc                           ; Push return address onto the stack
       bl   @ti_rnd                    ; Generate a random number in r0
       andi r0,>00ff                 ; Clear MSB: [0-255]
       mov  af,r1                    ; range in MSB
       srl  r1,8                     ; range in LSB
       mpy  r1,r0                  ; range * [0-255]
       srl  r1,8                     ; (range * [0-255]) / 256
       mov  r1,a                     ; Copy result back
       swpb a                          ; to MSB
       .endproc                        ; Pop return address off the stack
*// ti_rnd_range

*********************************************************************
*
* Generate a pseudo random number
*
* On return r0 contains the number, which is also stored at @rnd_seed
*
* r1 and r2 are modified
*
ti_rnd:
       li   r1,28643                 ; A prime number to multiply by
       mpy  @rnd_seed,r1             ; Multiply by last random number
       ai   r2,31873                 ; Add a prime number
       src  r2,7                     ; Mix up the number to break odd/even pattern
       mov  r2,@rnd_seed             ; Save this number for next time
       mov  r2,r0
       rt
rnd_seed:
       data 0
*// ti_rnd

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
ti_vsync:
       .proc
       movb @vdpsta,@vdp_status
ti_vsync_1:
       clr  r12
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  ti_vsync_1
;       bl   @module_player
       .endproc
*// ti_vsync

*********************************************************************
*
* Wait for r0 frames
*
ti_delay:
       .proc
ti_delay_1:
       bl   @ti_vsync
       dec  r0
       jne  ti_delay_1
       .endproc
*// ti_delay

*********************************************************************
*
* For routines that set or reset the carry flag on return
*
return_with_carry:
       .pop  r11
return_with_carry_1:
       seto r0
       inc  r0
       rt

return_without_carry:
       .pop  r11
return_without_carry_1:
       clr  r0
       inc  r0
       rt

*********************************************************************
*
* EXX
*
exx_routine:
       mov  bc,r0
       mov  bc_,bc
       mov  r0,bc_
       mov  hl,r0
       mov  hl_,hl
       mov  r0,hl_
       mov  de,r0
       mov  de_,de
       mov  r0,de_
       rt

*********************************************************************
*
* Lookup tables
*
bytes:
       byte >00,>01,>02,>03,>04,>05,>06,>07,>08,>09,>0a,>0b,>0c,>0d,>0e,>0f
       byte >10,>11,>12,>13,>14,>15,>16,>17,>18,>19,>1a,>1b,>1c,>1d,>1e,>1f
       byte >20,>21,>22,>23,>24,>25,>26,>27,>28,>29,>2a,>2b,>2c,>2d,>2e,>2f
       byte >30,>31,>32,>33,>34,>35,>36,>37,>38,>39,>3a,>3b,>3c,>3d,>3e,>3f
       byte >40,>41,>42,>43,>44,>45,>46,>47,>48,>49,>4a,>4b,>4c,>4d,>4e,>4f
       byte >50,>51,>52,>53,>54,>55,>56,>57,>58,>59,>5a,>5b,>5c,>5d,>5e,>5f
       byte >60,>61,>62,>63,>64,>65,>66,>67,>68,>69,>6a,>6b,>6c,>6d,>6e,>6f
       byte >70,>71,>72,>73,>74,>75,>76,>77,>78,>79,>7a,>7b,>7c,>7d,>7e,>7f
       byte >80,>81,>82,>83,>84,>85,>86,>87,>88,>89,>8a,>8b,>8c,>8d,>8e,>8f
       byte >90,>91,>92,>93,>94,>95,>96,>97,>98,>99,>9a,>9b,>9c,>9d,>9e,>9f
       byte >a0,>a1,>a2,>a3,>a4,>a5,>a6,>a7,>a8,>a9,>aa,>ab,>ac,>ad,>ae,>af
       byte >b0,>b1,>b2,>b3,>b4,>b5,>b6,>b7,>b8,>b9,>ba,>bb,>bc,>bd,>be,>bf
       byte >c0,>c1,>c2,>c3,>c4,>c5,>c6,>c7,>c8,>c9,>ca,>cb,>cc,>cd,>ce,>cf
       byte >d0,>d1,>d2,>d3,>d4,>d5,>d6,>d7,>d8,>d9,>da,>db,>dc,>dd,>de,>df
       byte >e0,>e1,>e2,>e3,>e4,>e5,>e6,>e7,>e8,>e9,>ea,>eb,>ec,>ed,>ee,>ef
       byte >f0,>f1,>f2,>f3,>f4,>f5,>f6,>f7,>f8,>f9,>fa,>fb,>fc,>fd,>fe,>ff

ti_colors:
       byte >11,>41,>61,>d1,>c1,>71,>a1,>e1,>14,>44,>64,>d4,>c4,>74,>a4,>e4
       byte >16,>46,>66,>d6,>c6,>76,>a6,>e6,>1d,>4d,>6d,>dd,>cd,>7d,>ad,>ed
       byte >1c,>4c,>6c,>dc,>cc,>7c,>ac,>ec,>17,>47,>67,>d7,>c7,>77,>a7,>e7
       byte >1a,>4a,>6a,>da,>ca,>7a,>aa,>ea,>1e,>4e,>6e,>de,>ce,>7e,>ae,>ee
       byte >11,>51,>81,>d1,>21,>71,>b1,>f1,>15,>55,>85,>d5,>25,>75,>b5,>f5
       byte >18,>58,>88,>d8,>28,>78,>b8,>f8,>1d,>5d,>8d,>dd,>2d,>7d,>bd,>fd
       byte >12,>52,>82,>d2,>22,>72,>b2,>f2,>17,>57,>87,>d7,>27,>77,>b7,>f7
       byte >1b,>5b,>8b,>db,>2b,>7b,>bb,>fb,>1f,>5f,>8f,>df,>2f,>7f,>bf,>ff
       byte >11,>14,>16,>1d,>1c,>17,>1a,>1e,>41,>44,>46,>4d,>4c,>47,>4a,>4e
       byte >61,>64,>66,>6d,>6c,>67,>6a,>6e,>d1,>d4,>d6,>dd,>dc,>d7,>da,>de
       byte >c1,>c4,>c6,>cd,>cc,>c7,>ca,>ce,>71,>74,>76,>7d,>7c,>77,>7a,>7e
       byte >a1,>a4,>a6,>ad,>ac,>a7,>aa,>ae,>e1,>e4,>e6,>ed,>ec,>e7,>ea,>ee
       byte >11,>15,>18,>1d,>12,>17,>1b,>1f,>51,>55,>58,>5d,>52,>57,>5b,>5f
       byte >81,>85,>88,>8d,>82,>87,>8b,>8f,>d1,>d5,>d8,>dd,>d2,>d7,>db,>df
       byte >21,>25,>28,>2d,>22,>27,>2b,>2f,>71,>75,>78,>7d,>72,>77,>7b,>7f
       byte >b1,>b5,>b8,>bd,>b2,>b7,>bb,>bf,>f1,>f5,>f8,>fd,>f2,>f7,>fb,>ff
